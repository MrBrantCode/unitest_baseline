{
  "task_id": "taco_10656",
  "entry_point": "min_vertices_to_remove",
  "mutant_count": 153,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rad = K // 2",
      "mutated_line": "rad = K / 2",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K / 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rad = K // 2",
      "mutated_line": "rad = K * 2",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K * 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rad = K // 2",
      "mutated_line": "rad = K // 3",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 3\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rad = K // 2",
      "mutated_line": "rad = K // 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 1\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rad = K // 2",
      "mutated_line": "rad = K // 0",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 0\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rad = K // 2",
      "mutated_line": "rad = K // 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 1\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rad = K // 2",
      "mutated_line": "rad = K // -2",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // -2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(2, N + 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(2, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(0, N + 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(0, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(0, N + 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(0, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(-1, N + 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(-1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(1, N - 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N - 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(1, N * 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N * 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "anstmp = 0",
      "mutated_line": "anstmp = 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 1\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "anstmp = 0",
      "mutated_line": "anstmp = -1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = -1\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "anstmp = 0",
      "mutated_line": "anstmp = 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 1\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] / (len(graph[center]) + 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] / (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] + (len(graph[center]) + 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] + (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] ** (len(graph[center]) + 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] ** (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if K % 2:",
      "mutated_line": "if K * 2:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K * 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if K % 2:",
      "mutated_line": "if K + 2:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K + 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "anstmp += max(bonus)",
      "mutated_line": "anstmp -= max(bonus)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp -= max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max(ans, 0)",
      "mutated_line": "return max(ans, 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max(ans, 0)",
      "mutated_line": "return max(ans, -1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return max(ans, 0)",
      "mutated_line": "return max(ans, 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(1, N + 2):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 2):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(1, N + 0):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 0):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(1, N + 0):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 0):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for center in range(1, N + 1):",
      "mutated_line": "for center in range(1, N + -1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + -1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[center] = [0, 0]",
      "mutated_line": "dep[center] = [1, 0]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [1, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[center] = [0, 0]",
      "mutated_line": "dep[center] = [-1, 0]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [-1, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[center] = [0, 0]",
      "mutated_line": "dep[center] = [1, 0]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [1, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[center] = [0, 0]",
      "mutated_line": "dep[center] = [0, 1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 1]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[center] = [0, 0]",
      "mutated_line": "dep[center] = [0, -1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, -1]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[center] = [0, 0]",
      "mutated_line": "dep[center] = [0, 1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 1]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] * (len(graph[center]) - 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) - 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] * (len(graph[center]) * 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) * 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(2, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(0, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(0, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(-1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N - 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N * 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dep[i][0] <= rad:",
      "mutated_line": "if dep[i][0] < rad:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] < rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dep[i][0] <= rad:",
      "mutated_line": "if dep[i][0] > rad:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] > rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dep[i][0] <= rad:",
      "mutated_line": "if dep[i][0] == rad:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] == rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "anstmp += 1",
      "mutated_line": "anstmp -= 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp -= 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][0] != rad + 1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] != rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][1]] -= 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] -= 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if K % 2:",
      "mutated_line": "if K % 3:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 3:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if K % 2:",
      "mutated_line": "if K % 1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 1:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if K % 2:",
      "mutated_line": "if K % 0:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 0:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if K % 2:",
      "mutated_line": "if K % 1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 1:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if K % 2:",
      "mutated_line": "if K % -2:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % -2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(N - anstmp, ans)",
      "mutated_line": "ans = min(N + anstmp, ans)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N + anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(N - anstmp, ans)",
      "mutated_line": "ans = min(N * anstmp, ans)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N * anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N - 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N - 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N * 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N * 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[+1, -1] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[+1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, +1] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, +1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if x == center:",
      "mutated_line": "if x != center:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x != center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [1] * (len(graph[center]) + 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [1] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [-1] * (len(graph[center]) + 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [-1] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [1] * (len(graph[center]) + 1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [1] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] * (len(graph[center]) + 2)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 2)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] * (len(graph[center]) + 0)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 0)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] * (len(graph[center]) + 0)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 0)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "bonus = [0] * (len(graph[center]) + 1)",
      "mutated_line": "bonus = [0] * (len(graph[center]) + -1)",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + -1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 2):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 0):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 0):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + -1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "anstmp += 1",
      "mutated_line": "anstmp += 2",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 2\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "anstmp += 1",
      "mutated_line": "anstmp += 0",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 0\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "anstmp += 1",
      "mutated_line": "anstmp += 0",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 0\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "anstmp += 1",
      "mutated_line": "anstmp += -1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += -1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][0] == rad - 1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad - 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][0] == rad * 1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad * 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][1]] += 2",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 2\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][1]] += 0",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 0\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][1]] += 0",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 0\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][1]] += -1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += -1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 2)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 2)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 0)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 0)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 0)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 0)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + -1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + -1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-2, -1] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-2, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-0, -1] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-0, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-0, -1] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-0, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[--1, -1] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[--1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -2] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -2] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -0] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -0] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -0] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -0] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, --1] for _ in range(N + 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, --1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -1] for _ in range(N - 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N - 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -1] for _ in range(N * 1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N * 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][0] != -1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] != -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if dep[i][0] <= rad:",
      "mutated_line": "if dep[i][1] <= rad:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][1] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if dep[i][0] <= rad:",
      "mutated_line": "if dep[i][-1] <= rad:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][-1] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if dep[i][0] <= rad:",
      "mutated_line": "if dep[i][1] <= rad:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][1] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][1] == rad + 1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][1] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][-1] == rad + 1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][-1] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][1] == rad + 1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][1] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][0] == rad + 2:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 2:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][0] == rad + 0:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 0:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][0] == rad + 0:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 0:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if dep[i][0] == rad + 1:",
      "mutated_line": "if dep[i][0] == rad + -1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + -1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -1] for _ in range(N + 2)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 2)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -1] for _ in range(N + 0)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 0)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -1] for _ in range(N + 0)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 0)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dep = [[-1, -1] for _ in range(N + 1)]",
      "mutated_line": "dep = [[-1, -1] for _ in range(N + -1)]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + -1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [2, i + 1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [2, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [0, i + 1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [0, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [0, i + 1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [0, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [-1, i + 1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [-1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [1, i - 1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i - 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [1, i * 1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i * 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][0] == +1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == +1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][0] - 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] - 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][0] * 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] * 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][2]] += 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][2]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][0]] += 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][0]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][0]] += 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][0]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bonus[dep[i][1]] += 1",
      "mutated_line": "bonus[dep[i][-1]] += 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][-1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [1, i + 2]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 2]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [1, i + 0]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 0]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [1, i + 0]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 0]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dep[y] = [1, i + 1]",
      "mutated_line": "dep[y] = [1, i + -1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + -1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][1] == -1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][1] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][-1] == -1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][-1] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][1] == -1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][1] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][0] == -2:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -2:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][0] == -0:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -0:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][0] == -0:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -0:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif dep[y][0] == -1:",
      "mutated_line": "elif dep[y][0] == --1:",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == --1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][1] = dep[x][0] + 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][1] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][-1] = dep[x][0] + 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][-1] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][1] = dep[x][0] + 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][1] = dep[x][0] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][0] + 2",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 2\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][0] + 0",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 0\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][0] + 0",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 0\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][0] + -1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + -1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dep[y][1] = dep[x][1]",
      "mutated_line": "dep[y][2] = dep[x][1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][2] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dep[y][1] = dep[x][1]",
      "mutated_line": "dep[y][0] = dep[x][1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][0] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dep[y][1] = dep[x][1]",
      "mutated_line": "dep[y][0] = dep[x][1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][0] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dep[y][1] = dep[x][1]",
      "mutated_line": "dep[y][-1] = dep[x][1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][-1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dep[y][1] = dep[x][1]",
      "mutated_line": "dep[y][1] = dep[x][2]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][2]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dep[y][1] = dep[x][1]",
      "mutated_line": "dep[y][1] = dep[x][0]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][0]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dep[y][1] = dep[x][1]",
      "mutated_line": "dep[y][1] = dep[x][0]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][0]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dep[y][1] = dep[x][1]",
      "mutated_line": "dep[y][1] = dep[x][-1]",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][0] + 1\n                    dep[y][1] = dep[x][-1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][1] + 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][1] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][-1] + 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][-1] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dep[y][0] = dep[x][0] + 1",
      "mutated_line": "dep[y][0] = dep[x][1] + 1",
      "code": "def min_vertices_to_remove(N, K, edges):\n    from collections import deque\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = N\n    rad = K // 2\n    for center in range(1, N + 1):\n        stack = [center]\n        dep = [[-1, -1] for _ in range(N + 1)]\n        dep[center] = [0, 0]\n        while stack:\n            x = stack.pop()\n            for (i, y) in enumerate(graph[x]):\n                if x == center:\n                    dep[y] = [1, i + 1]\n                    stack.append(y)\n                elif dep[y][0] == -1:\n                    stack.append(y)\n                    dep[y][0] = dep[x][1] + 1\n                    dep[y][1] = dep[x][1]\n        anstmp = 0\n        bonus = [0] * (len(graph[center]) + 1)\n        for i in range(1, N + 1):\n            if dep[i][0] <= rad:\n                anstmp += 1\n            if dep[i][0] == rad + 1:\n                bonus[dep[i][1]] += 1\n        if K % 2:\n            anstmp += max(bonus)\n        ans = min(N - anstmp, ans)\n    return max(ans, 0)"
    }
  ]
}