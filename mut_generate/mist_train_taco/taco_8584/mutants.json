{
  "task_id": "taco_8584",
  "entry_point": "ncr",
  "mutant_count": 222,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "from collections import defaultdict\nMOD = 1000000008\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "from collections import defaultdict\nMOD = 1000000006\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "from collections import defaultdict\nMOD = 0\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "from collections import defaultdict\nMOD = 1\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "from collections import defaultdict\nMOD = -1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX = 100010",
      "mutated_line": "MX = 100011",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100011\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX = 100010",
      "mutated_line": "MX = 100009",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100009\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX = 100010",
      "mutated_line": "MX = 0",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 0\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX = 100010",
      "mutated_line": "MX = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 1\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MX = 100010",
      "mutated_line": "MX = -100010",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = -100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - 1] = 549915854",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915854\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - 1] = 549915852",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915852\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - 1] = 0",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 0\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - 1] = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 1\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - 1] = -549915853",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = -549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] / MX, [1] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] / MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] + MX, [1] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] + MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] ** MX, [1] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] ** MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] * MX, [1] / MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] / MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] * MX, [1] + MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] + MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] * MX, [1] ** MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] ** MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, MX):",
      "mutated_line": "for i in range(3, MX):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(3, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, MX):",
      "mutated_line": "for i in range(1, MX):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(1, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, MX):",
      "mutated_line": "for i in range(0, MX):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(0, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, MX):",
      "mutated_line": "for i in range(1, MX):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(1, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, MX):",
      "mutated_line": "for i in range(-2, MX):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(-2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] * i * MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i * MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] * i + MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i + MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX + 1] = 549915853",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX + 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX * 1] = 549915853",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX * 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX + 2, -1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX + 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX * 2, -1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX * 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, +1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, +1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, -1, +1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, +1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) * MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) * MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) + MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) + MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if n < r:",
      "mutated_line": "if n <= r:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n <= r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if n < r:",
      "mutated_line": "if n >= r:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n >= r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if n < r:",
      "mutated_line": "if n != r:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n != r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] * MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] * MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] + MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] + MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m != 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "normal_nodes = n - k",
      "mutated_line": "normal_nodes = n + k",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n + k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "normal_nodes = n - k",
      "mutated_line": "normal_nodes = n * k",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n * k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 1\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = -1\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 1\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] / i % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] / i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = (fact[i - 1] + i) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = (fact[i - 1] + i) % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] ** i % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] ** i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - 2] = 549915853",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 2] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - 0] = 549915853",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 0] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - 0] = 549915853",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 0] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv_fact[MX - 1] = 549915853",
      "mutated_line": "inv_fact[MX - -1] = 549915853",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - -1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 3, -1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 3, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 1, -1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 1, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 0, -1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 0, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 1, -1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 1, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - -2, -1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - -2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, -2, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -2, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, -0, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -0, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, -0, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -0, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, --1, -1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, --1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, -1, -2):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -2):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, -1, -0):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -0):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, -1, -0):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -0):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(MX - 2, -1, -1):",
      "mutated_line": "for i in range(MX - 2, -1, --1):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, --1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] / (i + 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] / (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = (inv_fact[i + 1] + (i + 1)) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = (inv_fact[i + 1] + (i + 1)) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] ** (i + 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] ** (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 1\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return -1\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 1\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return fact[n] * inv_fact[r] % MOD / inv_fact[n - r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD / inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return (fact[n] * inv_fact[r] % MOD + inv_fact[n - r]) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return (fact[n] * inv_fact[r] % MOD + inv_fact[n - r]) % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return (fact[n] * inv_fact[r] % MOD) ** inv_fact[n - r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return (fact[n] * inv_fact[r] % MOD) ** inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 1:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == -1:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 1:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fact[n] % MOD",
      "mutated_line": "return fact[n] * MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] * MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fact[n] % MOD",
      "mutated_line": "return fact[n] + MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] + MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "discon[u, v] = 1",
      "mutated_line": "discon[u, v] = 2",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 2\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "discon[u, v] = 1",
      "mutated_line": "discon[u, v] = 0",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 0\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "discon[u, v] = 1",
      "mutated_line": "discon[u, v] = 0",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 0\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "discon[u, v] = 1",
      "mutated_line": "discon[u, v] = -1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = -1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "discon[v, u] = 1",
      "mutated_line": "discon[v, u] = 2",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 2\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "discon[v, u] = 1",
      "mutated_line": "discon[v, u] = 0",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 0\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "discon[v, u] = 1",
      "mutated_line": "discon[v, u] = 0",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 0\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "discon[v, u] = 1",
      "mutated_line": "discon[v, u] = -1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = -1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if u not in faulty_nodes:",
      "mutated_line": "if u in faulty_nodes:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if v not in faulty_nodes:",
      "mutated_line": "if v in faulty_nodes:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[1 << i][i][0] = 2",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 2\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[1 << i][i][0] = 0",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 0\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[1 << i][i][0] = 0",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 0\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[1 << i][i][0] = -1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = -1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for mask in range(1, 1 << k):",
      "mutated_line": "for mask in range(2, 1 << k):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(2, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for mask in range(1, 1 << k):",
      "mutated_line": "for mask in range(0, 1 << k):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(0, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for mask in range(1, 1 << k):",
      "mutated_line": "for mask in range(0, 1 << k):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(0, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for mask in range(1, 1 << k):",
      "mutated_line": "for mask in range(-1, 1 << k):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(-1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([2] * MX, [1] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([2] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([0] * MX, [1] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([0] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([0] * MX, [1] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([0] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([-1] * MX, [1] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([-1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] * MX, [2] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [2] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] * MX, [0] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [0] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] * MX, [0] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [0] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(fact, inv_fact) = ([1] * MX, [1] * MX)",
      "mutated_line": "(fact, inv_fact) = ([1] * MX, [-1] * MX)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [-1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i - 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i - 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i * 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i * 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return fact[n] * inv_fact[r] * MOD * inv_fact[n - r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] * MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return (fact[n] * inv_fact[r] + MOD) * inv_fact[n - r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return (fact[n] * inv_fact[r] + MOD) * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "discon = defaultdict(lambda: 0)",
      "mutated_line": "discon = defaultdict(lambda : 1)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 1)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "discon = defaultdict(lambda: 0)",
      "mutated_line": "discon = defaultdict(lambda : -1)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : -1)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "discon = defaultdict(lambda: 0)",
      "mutated_line": "discon = defaultdict(lambda : 1)",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 1)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] / (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] / (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] + (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] + (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] ** (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] ** (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[1 << i][i][1] = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][1] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[1 << i][i][-1] = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][-1] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[1 << i][i][1] = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][1] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for mask in range(1, 1 << k):",
      "mutated_line": "for mask in range(1, 2 << k):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 2 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for mask in range(1, 1 << k):",
      "mutated_line": "for mask in range(1, 0 << k):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 0 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for mask in range(1, 1 << k):",
      "mutated_line": "for mask in range(1, 0 << k):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 0 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for mask in range(1, 1 << k):",
      "mutated_line": "for mask in range(1, -1 << k):",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, -1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i + 1] * i % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i + 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i * 1] * i % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i * 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i - 1] * (i + 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i - 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i * 1] * (i + 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i * 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 2) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 2) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 0) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 0) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 0) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 0) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + -1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + -1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return fact[n] / inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] / inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return (fact[n] + inv_fact[r]) % MOD * inv_fact[n - r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return (fact[n] + inv_fact[r]) % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return fact[n] ** inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] ** inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n + r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n + r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "mutated_line": "return fact[n] * inv_fact[r] % MOD * inv_fact[n * r] % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n * r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k - 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k - 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k * 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k * 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dp[mask][first_node][number_tied] > 0:",
      "mutated_line": "if dp[mask][first_node][number_tied] >= 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] >= 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dp[mask][first_node][number_tied] > 0:",
      "mutated_line": "if dp[mask][first_node][number_tied] <= 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] <= 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if dp[mask][first_node][number_tied] > 0:",
      "mutated_line": "if dp[mask][first_node][number_tied] != 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] != 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask != (1 << k) - 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask != (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 2] * i % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 2] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 0] * i % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 0] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 0] * i % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 0] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - -1] * i % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - -1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 2] * (i + 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 2] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 0] * (i + 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 0] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + 0] * (i + 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 0] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv_fact[i] = inv_fact[i + -1] * (i + 1) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + -1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[1] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[1] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[-1] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[-1] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[1] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[1] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 2) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 2) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 0) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 0) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 0) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 0) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + -1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + -1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k - 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k - 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k * 1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k * 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(2 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(2 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(0 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(0 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(0 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(0 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(-1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(-1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k - 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k - 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k * 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k * 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if dp[mask][first_node][number_tied] > 0:",
      "mutated_line": "if dp[mask][first_node][number_tied] > 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 1:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if dp[mask][first_node][number_tied] > 0:",
      "mutated_line": "if dp[mask][first_node][number_tied] > -1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > -1:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if dp[mask][first_node][number_tied] > 0:",
      "mutated_line": "if dp[mask][first_node][number_tied] > 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 1:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (1 << k) + 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) + 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (1 << k) * 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) * 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations * MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations * MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations + MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations + MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = (ans + get_ways) % MOD",
      "mutated_line": "ans = (ans + get_ways) * MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) * MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = (ans + get_ways) % MOD",
      "mutated_line": "ans = ans + get_ways + MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = ans + get_ways + MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 2)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 2)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 0)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 0)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 0)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 0)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + -1)] for _ in range(1 << k + 1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + -1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 2)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 2)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 0)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 0)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 0)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 0)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]",
      "mutated_line": "dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + -1)]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + -1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[2 << i][i][0] = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[2 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[0 << i][i][0] = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[0 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[0 << i][i][0] = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[0 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[1 << i][i][0] = 1",
      "mutated_line": "dp[-1 << i][i][0] = 1",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[-1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first & 1 != 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 != 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]",
      "mutated_line": "dp[new_mask][new_first][number_tied + edge_missing] -= dp[mask][first_node][number_tied]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] -= dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (1 << k) - 2:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 2:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (1 << k) - 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 0:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (1 << k) - 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 0:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (1 << k) - -1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - -1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] / normal_nodes_combinations % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] / normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = (ncr(n - number_tied, k) * dp[mask][first_node][number_tied] + normal_nodes_combinations) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = (ncr(n - number_tied, k) * dp[mask][first_node][number_tied] + normal_nodes_combinations) % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = (ncr(n - number_tied, k) * dp[mask][first_node][number_tied]) ** normal_nodes_combinations % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = (ncr(n - number_tied, k) * dp[mask][first_node][number_tied]) ** normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = (ans + get_ways) % MOD",
      "mutated_line": "ans = (ans - get_ways) % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans - get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = (ans + get_ways) % MOD",
      "mutated_line": "ans = ans * get_ways % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = ans * get_ways % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first | 1 == 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first | 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first & 1 == 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 1:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first & 1 == -1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == -1:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first & 1 == 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 1:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "new_mask = mask ^ 1 << new_first",
      "mutated_line": "new_mask = mask | 1 << new_first",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask | 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (2 << k) - 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (2 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (0 << k) - 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (0 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (0 << k) - 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (0 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mask == (1 << k) - 1:",
      "mutated_line": "if mask == (-1 << k) - 1:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (-1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = ncr(n - number_tied, k) / dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) / dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = (ncr(n - number_tied, k) + dp[mask][first_node][number_tied]) * normal_nodes_combinations % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = (ncr(n - number_tied, k) + dp[mask][first_node][number_tied]) * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = ncr(n - number_tied, k) ** dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) ** dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first & 2 == 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 2 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first & 0 == 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 0 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first & 0 == 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 0 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if mask >> new_first & 1 == 0:",
      "mutated_line": "if mask >> new_first & -1 == 0:",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & -1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]",
      "mutated_line": "dp[new_mask][new_first][number_tied - edge_missing] += dp[mask][first_node][number_tied]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied - edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]",
      "mutated_line": "dp[new_mask][new_first][number_tied * edge_missing] += dp[mask][first_node][number_tied]",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied * edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "new_mask = mask ^ 1 << new_first",
      "mutated_line": "new_mask = mask ^ 2 << new_first",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 2 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "new_mask = mask ^ 1 << new_first",
      "mutated_line": "new_mask = mask ^ 0 << new_first",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 0 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "new_mask = mask ^ 1 << new_first",
      "mutated_line": "new_mask = mask ^ 0 << new_first",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 0 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "new_mask = mask ^ 1 << new_first",
      "mutated_line": "new_mask = mask ^ -1 << new_first",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ -1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = ncr(n + number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n + number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "mutated_line": "get_ways = ncr(n * number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD",
      "code": "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n\ndef count_connected_permutations(n, m, disconnected_pairs):\n    if m == 0:\n        return fact[n] % MOD\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for (u, v) in disconnected_pairs:\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n * number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    return ans"
    }
  ]
}