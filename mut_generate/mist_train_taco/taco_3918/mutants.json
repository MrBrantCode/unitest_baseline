{
  "task_id": "taco_3918",
  "entry_point": "find_min_moves_to_meet",
  "mutant_count": 186,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if K1 >= K2:",
      "mutated_line": "if K1 > K2:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 > K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if K1 >= K2:",
      "mutated_line": "if K1 < K2:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 < K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if K1 >= K2:",
      "mutated_line": "if K1 == K2:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 == K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if K1 > K2:",
      "mutated_line": "if K1 >= K2:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 >= K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if K1 > K2:",
      "mutated_line": "if K1 <= K2:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 <= K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if K1 > K2:",
      "mutated_line": "if K1 != K2:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 != K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if K1 == K2:",
      "mutated_line": "if K1 != K2:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 != K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[0]][position[1]] = 1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 1\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[0]][position[1]] = -1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = -1\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[0]][position[1]] = 1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 1\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[0][M - 1] != sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] != sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "visit1 = [[False for _ in range(M)] for _ in range(N)]",
      "mutated_line": "visit1 = [[True for _ in range(M)] for _ in range(N)]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[True for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "visit2 = [[False for _ in range(M)] for _ in range(N)]",
      "mutated_line": "visit2 = [[True for _ in range(M)] for _ in range(N)]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[True for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return +1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d + 1, -1, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d + 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d * 1, -1, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d * 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "UOI",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, +1, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, +1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "UOI",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, -1, +1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, +1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "LCR",
      "lineno": 53,
      "original_line": "if visit1[x][y] and dist2[x][y] < value:",
      "mutated_line": "if visit1[x][y] or dist2[x][y] < value:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] or dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "return value if value != sys.maxsize else -1",
      "mutated_line": "return value if value == sys.maxsize else -1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value == sys.maxsize else -1"
    },
    {
      "operator": "UOI",
      "lineno": 55,
      "original_line": "return value if value != sys.maxsize else -1",
      "mutated_line": "return value if value != sys.maxsize else +1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else +1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[0]][position[2]] = 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[2]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[0]][position[0]] = 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[0]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[0]][position[0]] = 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[0]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[0]][position[-1]] = 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[-1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "point = queue[0]",
      "mutated_line": "point = queue[1]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[1]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "point = queue[0]",
      "mutated_line": "point = queue[-1]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[-1]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "point = queue[0]",
      "mutated_line": "point = queue[1]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[1]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visit1[i][j] = True",
      "mutated_line": "visit1[i][j] = False",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = False\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])",
      "mutated_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [1, 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [1, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])",
      "mutated_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [-1, 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [-1, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])",
      "mutated_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [1, 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [1, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])",
      "mutated_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 1])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])",
      "mutated_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, -1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, -1])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])",
      "mutated_line": "spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 1])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [1, M - 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [1, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [-1, M - 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [-1, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [1, M - 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [1, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M + 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M + 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M * 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M * 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])",
      "mutated_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [1, 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [1, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])",
      "mutated_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [-1, 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [-1, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])",
      "mutated_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [1, 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [1, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])",
      "mutated_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 1])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])",
      "mutated_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, -1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, -1])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])",
      "mutated_line": "listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 1])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [1, M - 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [1, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [-1, M - 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [-1, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [1, M - 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [1, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M + 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M + 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M * 1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M * 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[0][M + 1] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M + 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[0][M * 1] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M * 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -2\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -0\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -0\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return --1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 1) * 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) * 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 1) // 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) // 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 2, -1, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 2, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 0, -1, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 0, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 0, -1, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 0, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - -1, -1, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - -1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, -2, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -2, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, -0, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -0, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, -0, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -0, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, --1, -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, --1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, -1, -2):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -2):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, -1, -0):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -0):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, -1, -0):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -0):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(d - 1, -1, -1):",
      "mutated_line": "for i in range(d - 1, -1, --1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, --1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if visit1[x][y] and dist2[x][y] < value:",
      "mutated_line": "if visit1[x][y] and dist2[x][y] <= value:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] <= value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if visit1[x][y] and dist2[x][y] < value:",
      "mutated_line": "if visit1[x][y] and dist2[x][y] >= value:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] >= value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if visit1[x][y] and dist2[x][y] < value:",
      "mutated_line": "if visit1[x][y] and dist2[x][y] != value:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] != value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value if value != sys.maxsize else -1",
      "mutated_line": "return value if value != sys.maxsize else -2",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -2"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value if value != sys.maxsize else -1",
      "mutated_line": "return value if value != sys.maxsize else -0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value if value != sys.maxsize else -1",
      "mutated_line": "return value if value != sys.maxsize else -0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value if value != sys.maxsize else -1",
      "mutated_line": "return value if value != sys.maxsize else --1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else --1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[1]][position[1]] = 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[1]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[-1]][position[1]] = 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[-1]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dist[position[0]][position[1]] = 0",
      "mutated_line": "dist[position[1]][position[1]] = 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[1]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "startx = max(i - k, 0)",
      "mutated_line": "startx = max(i + k, 0)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i + k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "startx = max(i - k, 0)",
      "mutated_line": "startx = max(i * k, 0)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i * k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "startx = max(i - k, 0)",
      "mutated_line": "startx = max(i - k, 1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 1)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "startx = max(i - k, 0)",
      "mutated_line": "startx = max(i - k, -1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, -1)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "startx = max(i - k, 0)",
      "mutated_line": "startx = max(i - k, 1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 1)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endx = min(i + k, n - 1)",
      "mutated_line": "endx = min(i - k, n - 1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i - k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endx = min(i + k, n - 1)",
      "mutated_line": "endx = min(i * k, n - 1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i * k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endx = min(i + k, n - 1)",
      "mutated_line": "endx = min(i + k, n + 1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n + 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endx = min(i + k, n - 1)",
      "mutated_line": "endx = min(i + k, n * 1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n * 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for x in range(startx, endx + 1):",
      "mutated_line": "for x in range(startx, endx - 1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx - 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for x in range(startx, endx + 1):",
      "mutated_line": "for x in range(startx, endx * 1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx * 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue = queue[1:]",
      "mutated_line": "queue = queue[2:]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[2:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue = queue[1:]",
      "mutated_line": "queue = queue[0:]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[0:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue = queue[1:]",
      "mutated_line": "queue = queue[0:]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[0:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue = queue[1:]",
      "mutated_line": "queue = queue[-1:]",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[-1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 2])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 2])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 0])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 0])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])",
      "mutated_line": "spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - -1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - -1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 2])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 2])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 0])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 0])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 0])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])",
      "mutated_line": "listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - -1])",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - -1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[1][M - 1] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[1][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[-1][M - 1] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[-1][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[1][M - 1] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[1][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[0][M - 2] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 2] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[0][M - 0] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 0] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[0][M - 0] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 0] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dist1[0][M - 1] == sys.maxsize:",
      "mutated_line": "if dist1[0][M - -1] == sys.maxsize:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - -1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] - 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] - 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int(dist1[0][M - 1] * 1 / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int(dist1[0][M - 1] * 1 / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 1) / 3)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 3)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 1) / 1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 1)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 1) / 0)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 0)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 1) / 1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 1)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 1) / -2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / -2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "endx = min(i + k, n - 1)",
      "mutated_line": "endx = min(i + k, n - 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 2)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "endx = min(i + k, n - 1)",
      "mutated_line": "endx = min(i + k, n - 0)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 0)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "endx = min(i + k, n - 1)",
      "mutated_line": "endx = min(i + k, n - 0)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 0)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "endx = min(i + k, n - 1)",
      "mutated_line": "endx = min(i + k, n - -1)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - -1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for x in range(startx, endx + 1):",
      "mutated_line": "for x in range(startx, endx + 2):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 2):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for x in range(startx, endx + 1):",
      "mutated_line": "for x in range(startx, endx + 0):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 0):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for x in range(startx, endx + 1):",
      "mutated_line": "for x in range(startx, endx + 0):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 0):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for x in range(startx, endx + 1):",
      "mutated_line": "for x in range(startx, endx + -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + -1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(1, j + abs(x - i) - k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(1, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(-1, j + abs(x - i) - k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(-1, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(1, j + abs(x - i) - k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(1, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(0, j + abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) + k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(0, (j + abs(x - i)) * k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, (j + abs(x - i)) * k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m + 1, j - abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m + 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m * 1, j - abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m * 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 1, j - abs(x - i) - k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) - k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 1, (j - abs(x - i)) * k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, (j - abs(x - i)) * k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for y in range(starty, endy + 1):",
      "mutated_line": "for y in range(starty, endy - 1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy - 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for y in range(starty, endy + 1):",
      "mutated_line": "for y in range(starty, endy * 1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy * 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if a[x][y] == 0 and not visit1[x][y]:",
      "mutated_line": "if a[x][y] == 0 or not visit1[x][y]:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 or not visit1[x][y]:\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 2) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 2) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 0) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 0) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + 0) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 0) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 1] + -1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + -1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(0, j - abs(x - i) - k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j - abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(0, j * abs(x - i) - k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j * abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 2, j - abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 2, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 0, j - abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 0, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 0, j - abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 0, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - -1, j - abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - -1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 1, j + abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j + abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 1, j * abs(x - i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j * abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for y in range(starty, endy + 1):",
      "mutated_line": "for y in range(starty, endy + 2):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 2):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for y in range(starty, endy + 1):",
      "mutated_line": "for y in range(starty, endy + 0):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 0):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for y in range(starty, endy + 1):",
      "mutated_line": "for y in range(starty, endy + 0):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 0):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for y in range(starty, endy + 1):",
      "mutated_line": "for y in range(starty, endy + -1):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + -1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a[x][y] == 0 and not visit1[x][y]:",
      "mutated_line": "if a[x][y] != 0 and (not visit1[x][y]):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] != 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] >= dist[i][j] + 1:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] >= dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] <= dist[i][j] + 1:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] <= dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] != dist[i][j] + 1:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] != dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M + 1] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M + 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M * 1] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M * 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[x][y] == 0 and not visit1[x][y]:",
      "mutated_line": "if a[x][y] == 1 and (not visit1[x][y]):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 1 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[x][y] == 0 and not visit1[x][y]:",
      "mutated_line": "if a[x][y] == -1 and (not visit1[x][y]):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == -1 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[x][y] == 0 and not visit1[x][y]:",
      "mutated_line": "if a[x][y] == 1 and (not visit1[x][y]):",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 1 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] > dist[i][j] - 1:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] - 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] > dist[i][j] * 1:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] * 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[x][y] = dist[i][j] + 1",
      "mutated_line": "dist[x][y] = dist[i][j] - 1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] - 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[x][y] = dist[i][j] + 1",
      "mutated_line": "dist[x][y] = dist[i][j] * 1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] * 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[1][M - 1] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[1][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[-1][M - 1] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[-1][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[1][M - 1] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[1][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 2] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 2] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 0] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 0] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - 0] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 0] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return int((dist1[0][M - 1] + 1) / 2)",
      "mutated_line": "return int((dist1[0][M - -1] + 1) / 2)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - -1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(0, j + abs(x + i) - k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x + i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "starty = max(0, j + abs(x - i) - k)",
      "mutated_line": "starty = max(0, j + abs(x * i) - k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x * i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 1, j - abs(x + i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x + i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "endy = min(m - 1, j - abs(x - i) + k)",
      "mutated_line": "endy = min(m - 1, j - abs(x * i) + k)",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x * i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] > dist[i][j] + 2:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 2:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] > dist[i][j] + 0:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 0:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] > dist[i][j] + 0:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 0:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dist[x][y] > dist[i][j] + 1:",
      "mutated_line": "if dist[x][y] > dist[i][j] + -1:",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + -1:\n                                dist[x][y] = dist[i][j] + 1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[x][y] = dist[i][j] + 1",
      "mutated_line": "dist[x][y] = dist[i][j] + 2",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 2\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[x][y] = dist[i][j] + 1",
      "mutated_line": "dist[x][y] = dist[i][j] + 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 0\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[x][y] = dist[i][j] + 1",
      "mutated_line": "dist[x][y] = dist[i][j] + 0",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + 0\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[x][y] = dist[i][j] + 1",
      "mutated_line": "dist[x][y] = dist[i][j] + -1",
      "code": "import sys\n\ndef find_min_moves_to_meet(N, M, K1, K2, grid):\n\n    def spaces(a, n, m, k, visit1, visit2, dist, position):\n        queue = [position]\n        lastedit = []\n        dist[position[0]][position[1]] = 0\n        while queue:\n            point = queue[0]\n            (i, j) = point\n            if not visit1[i][j]:\n                visit1[i][j] = True\n                startx = max(i - k, 0)\n                endx = min(i + k, n - 1)\n                for x in range(startx, endx + 1):\n                    starty = max(0, j + abs(x - i) - k)\n                    endy = min(m - 1, j - abs(x - i) + k)\n                    for y in range(starty, endy + 1):\n                        if a[x][y] == 0 and (not visit1[x][y]):\n                            if visit2[x][y]:\n                                lastedit.append([x, y])\n                            if dist[x][y] > dist[i][j] + 1:\n                                dist[x][y] = dist[i][j] + -1\n                                queue.append([x, y])\n            queue = queue[1:]\n        return lastedit\n    value = sys.maxsize\n    listing = []\n    visit1 = [[False for _ in range(M)] for _ in range(N)]\n    visit2 = [[False for _ in range(M)] for _ in range(N)]\n    dist1 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    dist2 = [[sys.maxsize for _ in range(M)] for _ in range(N)]\n    if K1 >= K2:\n        spaces(grid, N, M, K1, visit1, visit2, dist1, [0, 0])\n    else:\n        spaces(grid, N, M, K2, visit1, visit2, dist1, [0, M - 1])\n        listing = spaces(grid, N, M, K1, visit2, visit1, dist2, [0, 0])\n    if K1 > K2:\n        listing = spaces(grid, N, M, K2, visit2, visit1, dist2, [0, M - 1])\n    if K1 == K2:\n        if dist1[0][M - 1] == sys.maxsize:\n            return -1\n        else:\n            return int((dist1[0][M - 1] + 1) / 2)\n    else:\n        d = len(listing)\n        for i in range(d - 1, -1, -1):\n            (x, y) = listing[i]\n            if visit1[x][y] and dist2[x][y] < value:\n                value = dist2[x][y]\n        return value if value != sys.maxsize else -1"
    }
  ]
}