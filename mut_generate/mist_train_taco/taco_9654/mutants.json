{
  "task_id": "taco_9654",
  "entry_point": "maximum_people_sunny_after_cloud_removal",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cloud_start_i = 0",
      "mutated_line": "cloud_start_i = 1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 1\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cloud_start_i = 0",
      "mutated_line": "cloud_start_i = -1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = -1\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cloud_start_i = 0",
      "mutated_line": "cloud_start_i = 1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 1\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cloud_end_i = 0",
      "mutated_line": "cloud_end_i = 1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 1\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cloud_end_i = 0",
      "mutated_line": "cloud_end_i = -1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = -1\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cloud_end_i = 0",
      "mutated_line": "cloud_end_i = 1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 1\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "free = 0",
      "mutated_line": "free = 1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 1\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "free = 0",
      "mutated_line": "free = -1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = -1\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "free = 0",
      "mutated_line": "free = 1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 1\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return max(d.values(), default=0) + free",
      "mutated_line": "return max(d.values(), default=0) - free",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) - free"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return max(d.values(), default=0) + free",
      "mutated_line": "return max(d.values(), default=0) * free",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) * free"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i < len(cloud_start) or cloud_start[cloud_start_i][0] <= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) or cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "cloud_start_i += 1",
      "mutated_line": "cloud_start_i -= 1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i -= 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i < len(cloud_end) or cloud_end[cloud_end_i][0] < town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) or cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "cloud_end_i += 1",
      "mutated_line": "cloud_end_i -= 1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i -= 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if len(clouds) == 1:",
      "mutated_line": "if len(clouds) != 1:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) != 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "d[list(clouds)[0]] += towns[town_i][1]",
      "mutated_line": "d[list(clouds)[0]] -= towns[town_i][1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] -= towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]",
      "mutated_line": "towns = [[town_locations[i], town_populations[i], +1] for i in range(len(town_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], +1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]",
      "mutated_line": "cloud_start = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]",
      "mutated_line": "cloud_start = [[cloud_locations[i] * cloud_ranges[i], i] for i in range(len(cloud_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] * cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]",
      "mutated_line": "cloud_end = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]",
      "mutated_line": "cloud_end = [[cloud_locations[i] * cloud_ranges[i], i] for i in range(len(cloud_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] * cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "town_x = towns[town_i][0]",
      "mutated_line": "town_x = towns[town_i][1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][1]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "town_x = towns[town_i][0]",
      "mutated_line": "town_x = towns[town_i][-1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][-1]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "town_x = towns[town_i][0]",
      "mutated_line": "town_x = towns[town_i][1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][1]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i <= len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i <= len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i >= len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i >= len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i != len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i != len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] < town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] < town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] > town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] > town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] == town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] == town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cloud_start_i += 1",
      "mutated_line": "cloud_start_i += 2",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 2\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cloud_start_i += 1",
      "mutated_line": "cloud_start_i += 0",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 0\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cloud_start_i += 1",
      "mutated_line": "cloud_start_i += 0",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 0\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cloud_start_i += 1",
      "mutated_line": "cloud_start_i += -1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += -1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i <= len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i <= len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i >= len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i >= len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i != len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i != len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] <= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] <= town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] >= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] >= town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] != town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] != town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cloud_end_i += 1",
      "mutated_line": "cloud_end_i += 2",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 2\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cloud_end_i += 1",
      "mutated_line": "cloud_end_i += 0",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 0\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cloud_end_i += 1",
      "mutated_line": "cloud_end_i += 0",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 0\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cloud_end_i += 1",
      "mutated_line": "cloud_end_i += -1",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += -1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if len(clouds) == 1:",
      "mutated_line": "if len(clouds) == 2:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 2:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if len(clouds) == 1:",
      "mutated_line": "if len(clouds) == 0:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 0:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if len(clouds) == 1:",
      "mutated_line": "if len(clouds) == 0:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 0:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if len(clouds) == 1:",
      "mutated_line": "if len(clouds) == -1:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == -1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif len(clouds) == 0:",
      "mutated_line": "elif len(clouds) != 0:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) != 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "free += towns[town_i][1]",
      "mutated_line": "free -= towns[town_i][1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free -= towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]",
      "mutated_line": "towns = [[town_locations[i], town_populations[i], -2] for i in range(len(town_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -2] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]",
      "mutated_line": "towns = [[town_locations[i], town_populations[i], -0] for i in range(len(town_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -0] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]",
      "mutated_line": "towns = [[town_locations[i], town_populations[i], -0] for i in range(len(town_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -0] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]",
      "mutated_line": "towns = [[town_locations[i], town_populations[i], --1] for i in range(len(town_locations))]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], --1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "towns[town_i][2] = list(clouds)[0]",
      "mutated_line": "towns[town_i][3] = list(clouds)[0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][3] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "towns[town_i][2] = list(clouds)[0]",
      "mutated_line": "towns[town_i][1] = list(clouds)[0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][1] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "towns[town_i][2] = list(clouds)[0]",
      "mutated_line": "towns[town_i][0] = list(clouds)[0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][0] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "towns[town_i][2] = list(clouds)[0]",
      "mutated_line": "towns[town_i][1] = list(clouds)[0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][1] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "towns[town_i][2] = list(clouds)[0]",
      "mutated_line": "towns[town_i][-2] = list(clouds)[0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][-2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "towns[town_i][2] = list(clouds)[0]",
      "mutated_line": "towns[town_i][2] = list(clouds)[1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[1]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "towns[town_i][2] = list(clouds)[0]",
      "mutated_line": "towns[town_i][2] = list(clouds)[-1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[-1]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "towns[town_i][2] = list(clouds)[0]",
      "mutated_line": "towns[town_i][2] = list(clouds)[1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[1]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[list(clouds)[0]] += towns[town_i][1]",
      "mutated_line": "d[list(clouds)[0]] += towns[town_i][2]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][2]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[list(clouds)[0]] += towns[town_i][1]",
      "mutated_line": "d[list(clouds)[0]] += towns[town_i][0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][0]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[list(clouds)[0]] += towns[town_i][1]",
      "mutated_line": "d[list(clouds)[0]] += towns[town_i][0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][0]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[list(clouds)[0]] += towns[town_i][1]",
      "mutated_line": "d[list(clouds)[0]] += towns[town_i][-1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][-1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif len(clouds) == 0:",
      "mutated_line": "elif len(clouds) == 1:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 1:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif len(clouds) == 0:",
      "mutated_line": "elif len(clouds) == -1:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == -1:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif len(clouds) == 0:",
      "mutated_line": "elif len(clouds) == 1:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 1:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max(d.values(), default=0) + free",
      "mutated_line": "return max(d.values(), default=1) + free",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=1) + free"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max(d.values(), default=0) + free",
      "mutated_line": "return max(d.values(), default=-1) + free",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=-1) + free"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max(d.values(), default=0) + free",
      "mutated_line": "return max(d.values(), default=1) + free",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=1) + free"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][1] <= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][1] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][-1] <= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][-1] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:",
      "mutated_line": "while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][1] <= town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][1] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "clouds.add(cloud_start[cloud_start_i][1])",
      "mutated_line": "clouds.add(cloud_start[cloud_start_i][2])",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][2])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "clouds.add(cloud_start[cloud_start_i][1])",
      "mutated_line": "clouds.add(cloud_start[cloud_start_i][0])",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][0])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "clouds.add(cloud_start[cloud_start_i][1])",
      "mutated_line": "clouds.add(cloud_start[cloud_start_i][0])",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][0])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "clouds.add(cloud_start[cloud_start_i][1])",
      "mutated_line": "clouds.add(cloud_start[cloud_start_i][-1])",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][-1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][1] < town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][1] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][-1] < town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][-1] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:",
      "mutated_line": "while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][1] < town_x:",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][1] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "clouds.remove(cloud_end[cloud_end_i][1])",
      "mutated_line": "clouds.remove(cloud_end[cloud_end_i][2])",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][2])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "clouds.remove(cloud_end[cloud_end_i][1])",
      "mutated_line": "clouds.remove(cloud_end[cloud_end_i][0])",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][0])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "clouds.remove(cloud_end[cloud_end_i][1])",
      "mutated_line": "clouds.remove(cloud_end[cloud_end_i][0])",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][0])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "clouds.remove(cloud_end[cloud_end_i][1])",
      "mutated_line": "clouds.remove(cloud_end[cloud_end_i][-1])",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][-1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[list(clouds)[0]] += towns[town_i][1]",
      "mutated_line": "d[list(clouds)[1]] += towns[town_i][1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[1]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[list(clouds)[0]] += towns[town_i][1]",
      "mutated_line": "d[list(clouds)[-1]] += towns[town_i][1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[-1]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "d[list(clouds)[0]] += towns[town_i][1]",
      "mutated_line": "d[list(clouds)[1]] += towns[town_i][1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[1]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][1]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "free += towns[town_i][1]",
      "mutated_line": "free += towns[town_i][2]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][2]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "free += towns[town_i][1]",
      "mutated_line": "free += towns[town_i][0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][0]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "free += towns[town_i][1]",
      "mutated_line": "free += towns[town_i][0]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][0]\n    return max(d.values(), default=0) + free"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "free += towns[town_i][1]",
      "mutated_line": "free += towns[town_i][-1]",
      "code": "from collections import defaultdict\n\ndef maximum_people_sunny_after_cloud_removal(town_populations, town_locations, cloud_locations, cloud_ranges):\n    towns = [[town_locations[i], town_populations[i], -1] for i in range(len(town_locations))]\n    cloud_start = [[cloud_locations[i] - cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    cloud_end = [[cloud_locations[i] + cloud_ranges[i], i] for i in range(len(cloud_locations))]\n    towns = sorted(towns)\n    cloud_start = sorted(cloud_start)\n    cloud_end = sorted(cloud_end)\n    cloud_start_i = 0\n    cloud_end_i = 0\n    clouds = set()\n    d = defaultdict(int)\n    free = 0\n    for town_i in range(len(towns)):\n        town_x = towns[town_i][0]\n        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:\n            clouds.add(cloud_start[cloud_start_i][1])\n            cloud_start_i += 1\n        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:\n            clouds.remove(cloud_end[cloud_end_i][1])\n            cloud_end_i += 1\n        if len(clouds) == 1:\n            towns[town_i][2] = list(clouds)[0]\n            d[list(clouds)[0]] += towns[town_i][1]\n        elif len(clouds) == 0:\n            free += towns[town_i][-1]\n    return max(d.values(), default=0) + free"
    }
  ]
}