{
  "task_id": "taco_3720",
  "entry_point": "check_macro_expression",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "ADD = A | S",
      "mutated_line": "ADD = A & S",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A & S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "ADD = A | S",
      "mutated_line": "ADD = A ^ S",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A ^ S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ANY = A | S | M | D",
      "mutated_line": "ANY = (A | S | M) & D",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = (A | S | M) & D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ANY = A | S | M | D",
      "mutated_line": "ANY = (A | S | M) ^ D",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = (A | S | M) ^ D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (2, 2, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (2, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (0, 2, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (0, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (0, 2, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (0, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (-1, 2, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (-1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 3, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 3, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 1, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 1, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 0, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 0, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 1, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 1, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, -2, 4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, -2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 5, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 5, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 3, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 3, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 0, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 0, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 1, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 1, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, -4, 8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, -4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 9, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 9, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 7, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 7, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 0, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 0, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 1, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 1, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, -8, 16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, -8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 8, 17)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 17)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 8, 15)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 15)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 8, 0)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 0)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 8, 1)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 1)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(P, A, S, M, D) = (1, 2, 4, 8, 16)",
      "mutated_line": "(P, A, S, M, D) = (1, 2, 4, 8, -16)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, -16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ANY = A | S | M | D",
      "mutated_line": "ANY = (A | S) & M | D",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = (A | S) & M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ANY = A | S | M | D",
      "mutated_line": "ANY = (A | S) ^ M | D",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = (A | S) ^ M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}",
      "mutated_line": "OP_BIT = {'': A, '-': S, '*': M, '/': D, ')': 0}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}",
      "mutated_line": "OP_BIT = {'+': A, '': S, '*': M, '/': D, ')': 0}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}",
      "mutated_line": "OP_BIT = {'+': A, '-': S, '': M, '/': D, ')': 0}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}",
      "mutated_line": "OP_BIT = {'+': A, '-': S, '*': M, '': D, ')': 0}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}",
      "mutated_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, '': 0}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, '': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}",
      "mutated_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 1}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 1}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}",
      "mutated_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': -1}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': -1}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}",
      "mutated_line": "OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 1}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 1}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}",
      "mutated_line": "UNSAFE_BEFORE = {P: 1, A: 0, S: ADD, M: ADD, D: ANY}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 1, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}",
      "mutated_line": "UNSAFE_BEFORE = {P: -1, A: 0, S: ADD, M: ADD, D: ANY}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: -1, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}",
      "mutated_line": "UNSAFE_BEFORE = {P: 1, A: 0, S: ADD, M: ADD, D: ANY}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 1, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}",
      "mutated_line": "UNSAFE_BEFORE = {P: 0, A: 1, S: ADD, M: ADD, D: ANY}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 1, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}",
      "mutated_line": "UNSAFE_BEFORE = {P: 0, A: -1, S: ADD, M: ADD, D: ANY}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: -1, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}",
      "mutated_line": "UNSAFE_BEFORE = {P: 0, A: 1, S: ADD, M: ADD, D: ANY}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 1, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: 1, A: 0, S: 0, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 1, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: -1, A: 0, S: 0, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: -1, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: 1, A: 0, S: 0, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 1, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: 0, A: 1, S: 0, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 1, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: 0, A: -1, S: 0, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: -1, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: 0, A: 1, S: 0, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 1, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 1, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 1, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: 0, A: 0, S: -1, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: -1, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}",
      "mutated_line": "UNSAFE_AFTER = {P: 0, A: 0, S: 1, M: ADD, D: ADD}",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 1, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if name and (not safe()):",
      "mutated_line": "if name or not safe():",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name or not safe():\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "s = token[0] == '#'",
      "mutated_line": "s = token[0] != '#'",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] != '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return 'OK' if result else 'Suspicious'",
      "mutated_line": "return '' if result else 'Suspicious'",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return '' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return 'OK' if result else 'Suspicious'",
      "mutated_line": "return 'OK' if result else ''",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else ''"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ANY = A | S | M | D",
      "mutated_line": "ANY = A & S | M | D",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A & S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ANY = A | S | M | D",
      "mutated_line": "ANY = A ^ S | M | D",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A ^ S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if naked <= pseudo:",
      "mutated_line": "if naked < pseudo:",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked < pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if naked <= pseudo:",
      "mutated_line": "if naked > pseudo:",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked > pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if naked <= pseudo:",
      "mutated_line": "if naked == pseudo:",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked == pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if c == '(':",
      "mutated_line": "if c != '(':",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c != '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 1\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return -1\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 1\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "token = ['#', 'define', macro_name, macro_expr]",
      "mutated_line": "token = ['', 'define', macro_name, macro_expr]",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "token = ['#', 'define', macro_name, macro_expr]",
      "mutated_line": "token = ['#', '', macro_name, macro_expr]",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', '', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "s = token[0] == '#'",
      "mutated_line": "s = token[0] == ''",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == ''\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return not unsafe_before[last_op] & naked",
      "mutated_line": "return not unsafe_before[last_op] | naked",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] | naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if c == '(':",
      "mutated_line": "if c == '':",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif c not in op_bit:",
      "mutated_line": "elif c in op_bit:",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "s = token[0] == '#'",
      "mutated_line": "s = token[1] == '#'",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[1] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "s = token[0] == '#'",
      "mutated_line": "s = token[-1] == '#'",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[-1] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "s = token[0] == '#'",
      "mutated_line": "s = token[1] == '#'",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[1] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 - s]] = expr(chars(2 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 - s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 * s]] = expr(chars(2 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 * s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 + s]] = expr(chars(2 - s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 - s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 + s]] = expr(chars(2 * s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 * s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "result = expr((c for c in expression if c != ' '))",
      "mutated_line": "result = expr((c for c in expression if c == ' '))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c == ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[2 + s]] = expr(chars(2 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[2 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[0 + s]] = expr(chars(2 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[0 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[0 + s]] = expr(chars(2 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[0 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[-1 + s]] = expr(chars(2 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[-1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 + s]] = expr(chars(3 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(3 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 + s]] = expr(chars(1 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(1 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 + s]] = expr(chars(0 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(0 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 + s]] = expr(chars(1 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(1 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "macro[token[1 + s]] = expr(chars(2 + s, token))",
      "mutated_line": "macro[token[1 + s]] = expr(chars(-2 + s, token))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(-2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "result = expr((c for c in expression if c != ' '))",
      "mutated_line": "result = expr((c for c in expression if c != ''))",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ''))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "naked = expand(''.join(name), pseudo)",
      "mutated_line": "naked = expand('MUTATED'.join(name), pseudo)",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand('MUTATED'.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 1\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return -1\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 1\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif c == ')':",
      "mutated_line": "elif c != ')':",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c != ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif c == ')':",
      "mutated_line": "elif c == '':",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == '':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if unsafe_after[last_op] & naked:",
      "mutated_line": "if unsafe_after[last_op] | naked:",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] | naked:\n                    return 0\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 1\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return -1\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def check_macro_expression(n, macros, expression):\n    (P, A, S, M, D) = (1, 2, 4, 8, 16)\n    ADD = A | S\n    ANY = A | S | M | D\n    OP_BIT = {'+': A, '-': S, '*': M, '/': D, ')': 0}\n    UNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\n    UNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n    macro = dict()\n\n    def expr(chars, pseudo=P, expand=macro.get, op_bit=OP_BIT, unsafe_before=UNSAFE_BEFORE, unsafe_after=UNSAFE_AFTER):\n        paren = []\n        push = paren.append\n        pop = paren.pop\n        name = []\n        keep = name.append\n        forget = name.clear\n        last_op = retval = naked = pseudo\n\n        def safe():\n            nonlocal naked\n            naked = expand(''.join(name), pseudo)\n            forget()\n            if naked <= pseudo:\n                return naked\n            return not unsafe_before[last_op] & naked\n        for c in chars:\n            if c == '(':\n                push(last_op)\n                last_op = pseudo\n            elif c not in op_bit:\n                keep(c)\n            elif not safe():\n                return 0\n            elif c == ')':\n                last_op = pop()\n            else:\n                last_op = op_bit[c]\n                if unsafe_after[last_op] & naked:\n                    return 1\n                if not paren:\n                    retval |= last_op\n        if name and (not safe()):\n            return 0\n        return retval\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n    for (macro_name, macro_expr) in macros:\n        token = ['#', 'define', macro_name, macro_expr]\n        s = token[0] == '#'\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n    result = expr((c for c in expression if c != ' '))\n    return 'OK' if result else 'Suspicious'"
    }
  ]
}