{
  "task_id": "taco_8637",
  "entry_point": "parorder",
  "mutant_count": 145,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "par = [0] * N",
      "mutated_line": "par = [0] / N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] / N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "par = [0] * N",
      "mutated_line": "par = [0] + N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] + N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "par = [0] * N",
      "mutated_line": "par = [0] ** N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] ** N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "par[p] = -1",
      "mutated_line": "par[p] = +1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = +1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "Leaf = [0] * N",
      "mutated_line": "Leaf = [0] / N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] / N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "Leaf = [0] * N",
      "mutated_line": "Leaf = [0] + N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] + N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "Leaf = [0] * N",
      "mutated_line": "Leaf = [0] ** N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] ** N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "Leaf[a] += 1",
      "mutated_line": "Leaf[a] -= 1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] -= 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "Leaf[b] += 1",
      "mutated_line": "Leaf[b] -= 1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] -= 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 9 - 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 - 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 9 * 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 * 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] - [randrange(1, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] - [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] * [randrange(1, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] * [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] -= 1 + max(0, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] -= 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par[p] = -1",
      "mutated_line": "par[p] = -2",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -2\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par[p] = -1",
      "mutated_line": "par[p] = -0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -0\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par[p] = -1",
      "mutated_line": "par[p] = -0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -0\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par[p] = -1",
      "mutated_line": "par[p] = --1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = --1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (i, v) in enumerate(p[1:], 1):",
      "mutated_line": "for (i, v) in enumerate(p[1:], 2):",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 2):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (i, v) in enumerate(p[1:], 1):",
      "mutated_line": "for (i, v) in enumerate(p[1:], 0):",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 0):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (i, v) in enumerate(p[1:], 1):",
      "mutated_line": "for (i, v) in enumerate(p[1:], 0):",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 0):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (i, v) in enumerate(p[1:], 1):",
      "mutated_line": "for (i, v) in enumerate(p[1:], -1):",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], -1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "Leaf[a] += 1",
      "mutated_line": "Leaf[a] += 2",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 2\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "Leaf[a] += 1",
      "mutated_line": "Leaf[a] += 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 0\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "Leaf[a] += 1",
      "mutated_line": "Leaf[a] += 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 0\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "Leaf[a] += 1",
      "mutated_line": "Leaf[a] += -1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += -1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Leaf[b] += 1",
      "mutated_line": "Leaf[b] += 2",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 2\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Leaf[b] += 1",
      "mutated_line": "Leaf[b] += 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 0\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Leaf[b] += 1",
      "mutated_line": "Leaf[b] += 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 0\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Leaf[b] += 1",
      "mutated_line": "Leaf[b] += -1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += -1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 * 9 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 * 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 + 9 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 + 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 9 + 8",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 8\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 9 + 6",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 6\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 9 + 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 0\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 9 + 1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 1\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 9 + -7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + -7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "dp = [0] * N",
      "mutated_line": "dp = [0] / N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] / N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "dp = [0] * N",
      "mutated_line": "dp = [0] + N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] + N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "dp = [0] * N",
      "mutated_line": "dp = [0] ** N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] ** N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "countone = [0] * N",
      "mutated_line": "countone = [0] / N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] / N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "countone = [0] * N",
      "mutated_line": "countone = [0] + N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] + N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "countone = [0] * N",
      "mutated_line": "countone = [0] ** N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] ** N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] -= 1 + max(0, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] -= 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "dp[p] += dp[l] - 1",
      "mutated_line": "dp[p] -= dp[l] - 1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] -= dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 - max(0, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 - max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 * max(0, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 * max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "par = [0] * N",
      "mutated_line": "par = [1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [1] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "par = [0] * N",
      "mutated_line": "par = [-1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [-1] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "par = [0] * N",
      "mutated_line": "par = [1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [1] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if vf in visited:",
      "mutated_line": "if vf not in visited:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf not in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "Leaf = [0] * N",
      "mutated_line": "Leaf = [1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [1] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "Leaf = [0] * N",
      "mutated_line": "Leaf = [-1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [-1] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "Leaf = [0] * N",
      "mutated_line": "Leaf = [1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [1] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "Leaf = [i for i in range(N) if Leaf[i] == 1]",
      "mutated_line": "Leaf = [i for i in range(N) if Leaf[i] != 1]",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] != 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 11 ** 9 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 11 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 9 ** 9 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 9 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 0 ** 9 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 0 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 1 ** 9 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 1 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = -10 ** 9 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = -10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 10 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 10 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 8 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 8 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 0 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 0 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** 1 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 1 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ANS = 10 ** 9 + 7",
      "mutated_line": "ANS = 10 ** -9 + 7",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** -9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [1] + [randrange(1, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [1] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [-1] + [randrange(1, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [-1] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [1] + [randrange(1, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [1] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 - max(0, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 - max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 * max(0, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 * max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if dp[l] == 1:",
      "mutated_line": "if dp[l] != 1:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] != 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "countone[p] += 1",
      "mutated_line": "countone[p] -= 1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] -= 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "dp[p] += dp[l] - 1",
      "mutated_line": "dp[p] += dp[l] + 1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] + 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "dp[p] += dp[l] - 1",
      "mutated_line": "dp[p] += dp[l] * 1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] * 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 2 + max(0, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 2 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 0 + max(0, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 0 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 0 + max(0, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 0 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += -1 + max(0, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += -1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (i, v) in enumerate(p[1:], 1):",
      "mutated_line": "for (i, v) in enumerate(p[2:], 1):",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[2:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (i, v) in enumerate(p[1:], 1):",
      "mutated_line": "for (i, v) in enumerate(p[0:], 1):",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[0:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (i, v) in enumerate(p[1:], 1):",
      "mutated_line": "for (i, v) in enumerate(p[0:], 1):",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[0:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (i, v) in enumerate(p[1:], 1):",
      "mutated_line": "for (i, v) in enumerate(p[-1:], 1):",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[-1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "Leaf = [i for i in range(N) if Leaf[i] == 1]",
      "mutated_line": "Leaf = [i for i in range(N) if Leaf[i] == 2]",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 2]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "Leaf = [i for i in range(N) if Leaf[i] == 1]",
      "mutated_line": "Leaf = [i for i in range(N) if Leaf[i] == 0]",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 0]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "Leaf = [i for i in range(N) if Leaf[i] == 1]",
      "mutated_line": "Leaf = [i for i in range(N) if Leaf[i] == 0]",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 0]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "Leaf = [i for i in range(N) if Leaf[i] == 1]",
      "mutated_line": "Leaf = [i for i in range(N) if Leaf[i] == -1]",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == -1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(2, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(2, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(0, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(0, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(0, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(0, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(-1, M) for _ in range(10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(-1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dp = [0] * N",
      "mutated_line": "dp = [1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [1] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dp = [0] * N",
      "mutated_line": "dp = [-1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [-1] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dp = [0] * N",
      "mutated_line": "dp = [1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [1] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "countone = [0] * N",
      "mutated_line": "countone = [1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [1] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "countone = [0] * N",
      "mutated_line": "countone = [-1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [-1] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "countone = [0] * N",
      "mutated_line": "countone = [1] * N",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [1] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::-1][:+1]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:+1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 2 + max(0, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 2 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 0 + max(0, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 0 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 0 + max(0, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 0 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += -1 + max(0, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += -1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dp[l] == 1:",
      "mutated_line": "if dp[l] == 2:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 2:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dp[l] == 1:",
      "mutated_line": "if dp[l] == 0:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 0:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dp[l] == 1:",
      "mutated_line": "if dp[l] == 0:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 0:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if dp[l] == 1:",
      "mutated_line": "if dp[l] == -1:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == -1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "countone[p] += 1",
      "mutated_line": "countone[p] += 2",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 2\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "countone[p] += 1",
      "mutated_line": "countone[p] += 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 0\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "countone[p] += 1",
      "mutated_line": "countone[p] += 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 0\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "countone[p] += 1",
      "mutated_line": "countone[p] += -1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += -1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dp[p] += dp[l] - 1",
      "mutated_line": "dp[p] += dp[l] - 2",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 2\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dp[p] += dp[l] - 1",
      "mutated_line": "dp[p] += dp[l] - 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 0\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dp[p] += dp[l] - 1",
      "mutated_line": "dp[p] += dp[l] - 0",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 0\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dp[p] += dp[l] - 1",
      "mutated_line": "dp[p] += dp[l] - -1",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - -1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(1, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(1, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(-1, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(-1, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(1, countone[root] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(1, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(0, countone[root] + 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] + 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(0, countone[root] * 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] * 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(1, M) for _ in range(11)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(11)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(1, M) for _ in range(9)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(9)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(1, M) for _ in range(0)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(0)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(1, M) for _ in range(1)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(1)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for idx in [0] + [randrange(1, M) for _ in range(10)]:",
      "mutated_line": "for idx in [0] + [randrange(1, M) for _ in range(-10)]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(-10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::+1][:-1]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::+1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::-1][:-2]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-2]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::-1][:-0]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-0]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::-1][:-0]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-0]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::-1][:--1]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:--1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(1, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(1, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(-1, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(-1, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(1, countone[l] - 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(1, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(0, countone[l] + 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] + 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(0, countone[l] * 1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] * 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(0, countone[root] - 2)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 2)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(0, countone[root] - 0)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 0)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(0, countone[root] - 0)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 0)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "dp[root] += 1 + max(0, countone[root] - 1)",
      "mutated_line": "dp[root] += 1 + max(0, countone[root] - -1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - -1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::-2][:-1]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-2][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::-0][:-1]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-0][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::-0][:-1]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-0][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for l in L[::-1][:-1]:",
      "mutated_line": "for l in L[::--1][:-1]:",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::--1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(0, countone[l] - 2)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 2)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(0, countone[l] - 0)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 0)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(0, countone[l] - 0)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - 0)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "dp[l] += 1 + max(0, countone[l] - 1)",
      "mutated_line": "dp[l] += 1 + max(0, countone[l] - -1)",
      "code": "import sys\nfrom collections import Counter\nfrom random import randrange\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0] * N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return (par, order)\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for (i, v) in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef minimum_antennas(N, edges):\n    Edge = [[] for _ in range(N)]\n    Leaf = [0] * N\n    for (a, b) in edges:\n        Leaf[a] += 1\n        Leaf[b] += 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Leaf = [i for i in range(N) if Leaf[i] == 1]\n    M = len(Leaf)\n    ANS = 10 ** 9 + 7\n    for idx in [0] + [randrange(1, M) for _ in range(10)]:\n        root = Leaf[idx]\n        (P, L) = parorder(Edge, root)\n        C = getcld(P)\n        dp = [0] * N\n        countone = [0] * N\n        for l in L[::-1][:-1]:\n            p = P[l]\n            dp[l] += 1 + max(0, countone[l] - -1)\n            if dp[l] == 1:\n                countone[p] += 1\n            dp[p] += dp[l] - 1\n        dp[root] += 1 + max(0, countone[root] - 1)\n        ANS = min(ANS, dp[root])\n    return ANS"
    }
  ]
}