{
  "task_id": "taco_9059",
  "entry_point": "minimum_multiplications",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('inf')] / 100000",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] / 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('inf')] + 100000",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] + 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('inf')] ** 100000",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] ** 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance[start] = 0",
      "mutated_line": "distance[start] = 1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 1\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance[start] = 0",
      "mutated_line": "distance[start] = -1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = -1\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance[start] = 0",
      "mutated_line": "distance[start] = 1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 1\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('inf')] * 100001",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100001\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('inf')] * 99999",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 99999\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('inf')] * 0",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 0\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('inf')] * 1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 1\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('inf')] * -100000",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * -100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "que.append((start, 0))",
      "mutated_line": "que.append((start, 1))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 1))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "que.append((start, 0))",
      "mutated_line": "que.append((start, -1))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, -1))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "que.append((start, 0))",
      "mutated_line": "que.append((start, 1))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 1))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step + 1 <= distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 <= distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step + 1 >= distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 >= distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step + 1 != distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 != distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance = [float('inf')] * 100000",
      "mutated_line": "distance = [float('')] * 100000",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum * num * 100000)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num * 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum * num + 100000)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num + 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step - 1 < distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step - 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step * 1 < distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step * 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nextnum == end:",
      "mutated_line": "if nextnum != end:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum != end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "distance[nextnum] = step + 1",
      "mutated_line": "distance[nextnum] = step - 1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step - 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "distance[nextnum] = step + 1",
      "mutated_line": "distance[nextnum] = step * 1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step * 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum / num % 100000)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum / num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int((currNum + num) % 100000)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int((currNum + num) % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum ** num % 100000)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum ** num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum * num % 100001)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100001)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum * num % 99999)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 99999)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum * num % 0)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 0)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum * num % 1)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 1)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nextnum = int(currNum * num % 100000)",
      "mutated_line": "nextnum = int(currNum * num % -100000)",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % -100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step + 2 < distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 2 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step + 0 < distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 0 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step + 0 < distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 0 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if step + 1 < distance[nextnum]:",
      "mutated_line": "if step + -1 < distance[nextnum]:",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + -1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return step + 1",
      "mutated_line": "return step - 1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step - 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return step + 1",
      "mutated_line": "return step * 1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step * 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distance[nextnum] = step + 1",
      "mutated_line": "distance[nextnum] = step + 2",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distance[nextnum] = step + 1",
      "mutated_line": "distance[nextnum] = step + 0",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distance[nextnum] = step + 1",
      "mutated_line": "distance[nextnum] = step + 0",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "distance[nextnum] = step + 1",
      "mutated_line": "distance[nextnum] = step + -1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + -1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "que.append((nextnum, step + 1))",
      "mutated_line": "que.append((nextnum, step - 1))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step - 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "que.append((nextnum, step + 1))",
      "mutated_line": "que.append((nextnum, step * 1))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step * 1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return step + 1",
      "mutated_line": "return step + 2",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 2\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return step + 1",
      "mutated_line": "return step + 0",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 0\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return step + 1",
      "mutated_line": "return step + 0",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + 0\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return step + 1",
      "mutated_line": "return step + -1",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 1))\n                if nextnum == end:\n                    return step + -1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "que.append((nextnum, step + 1))",
      "mutated_line": "que.append((nextnum, step + 2))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 2))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "que.append((nextnum, step + 1))",
      "mutated_line": "que.append((nextnum, step + 0))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 0))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "que.append((nextnum, step + 1))",
      "mutated_line": "que.append((nextnum, step + 0))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + 0))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "que.append((nextnum, step + 1))",
      "mutated_line": "que.append((nextnum, step + -1))",
      "code": "from typing import List\nimport collections\n\ndef minimum_multiplications(arr: List[int], start: int, end: int) -> int:\n    que = collections.deque()\n    que.append((start, 0))\n    distance = [float('inf')] * 100000\n    distance[start] = 0\n    while que:\n        (currNum, step) = que.popleft()\n        for num in arr:\n            nextnum = int(currNum * num % 100000)\n            if step + 1 < distance[nextnum]:\n                que.append((nextnum, step + -1))\n                if nextnum == end:\n                    return step + 1\n                distance[nextnum] = step + 1\n    return -1"
    }
  ]
}