{
  "task_id": "taco_1704",
  "entry_point": "minimize_hamming_distance",
  "mutant_count": 51,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res + (2 if swap2 else 1 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res + (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res * (2 if swap2 else 1 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res * (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (1, -1, -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (1, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (-1, -1, -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (-1, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (1, -1, -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (1, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, +1, -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, +1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, -1, +1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, +1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if S[i] != T[i]:",
      "mutated_line": "if S[i] == T[i]:",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] == T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "res += 1",
      "mutated_line": "res -= 1",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res -= 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "swap1, swap2 = False, False",
      "mutated_line": "(swap1, swap2) = (True, False)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (True, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "swap1, swap2 = False, False",
      "mutated_line": "(swap1, swap2) = (False, True)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, True)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if S[i] in dic:",
      "mutated_line": "if S[i] not in dic:",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] not in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, -2, -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -2, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, -0, -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -0, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, -0, -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -0, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, --1, -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, --1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, -1, -2)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -2)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, -1, -0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -0)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, -1, -0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -0)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res, res1, res2 = 0, -1, -1",
      "mutated_line": "(res, res1, res2) = (0, -1, --1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, --1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res += 1",
      "mutated_line": "res += 2",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 2\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res += 1",
      "mutated_line": "res += 0",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 0\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res += 1",
      "mutated_line": "res += 0",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 0\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res += 1",
      "mutated_line": "res += -1",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += -1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "swap1 = True",
      "mutated_line": "swap1 = False",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = False\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "res1 = i + 1",
      "mutated_line": "res1 = i - 1",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i - 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "res1 = i + 1",
      "mutated_line": "res1 = i * 1",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i * 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "res2 = j + 1",
      "mutated_line": "res2 = j - 1",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j - 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "res2 = j + 1",
      "mutated_line": "res2 = j * 1",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j * 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if S[j] == T[i]:",
      "mutated_line": "if S[j] != T[i]:",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] != T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (3 if swap2 else 1 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (3 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (1 if swap2 else 1 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (1 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (0 if swap2 else 1 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (0 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (1 if swap2 else 1 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (1 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (-2 if swap2 else 1 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (-2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res1 = i + 1",
      "mutated_line": "res1 = i + 2",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 2\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res1 = i + 1",
      "mutated_line": "res1 = i + 0",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 0\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res1 = i + 1",
      "mutated_line": "res1 = i + 0",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 0\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res1 = i + 1",
      "mutated_line": "res1 = i + -1",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + -1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res2 = j + 1",
      "mutated_line": "res2 = j + 2",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 2\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res2 = j + 1",
      "mutated_line": "res2 = j + 0",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 0\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res2 = j + 1",
      "mutated_line": "res2 = j + 0",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 0\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res2 = j + 1",
      "mutated_line": "res2 = j + -1",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + -1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swap2 = True",
      "mutated_line": "swap2 = False",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = False\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (2 if swap2 else 2 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 2 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (2 if swap2 else 0 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 0 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (2 if swap2 else 0 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 0 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (2 if swap2 else -1 if swap1 else 0)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else -1 if swap1 else 0)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 1)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (2 if swap2 else 1 if swap1 else -1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else -1)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 0)",
      "mutated_line": "min_distance = res - (2 if swap2 else 1 if swap1 else 1)",
      "code": "def minimize_hamming_distance(n, S, T):\n    (dic, diff) = ({}, [])\n    (res, res1, res2) = (0, -1, -1)\n    for i in range(n):\n        if S[i] != T[i]:\n            res += 1\n            diff.append(i)\n            dic[T[i]] = i\n    (swap1, swap2) = (False, False)\n    for i in diff:\n        if S[i] in dic:\n            swap1 = True\n            res1 = i + 1\n            j = dic[S[i]]\n            res2 = j + 1\n            if S[j] == T[i]:\n                swap2 = True\n                break\n    min_distance = res - (2 if swap2 else 1 if swap1 else 1)\n    swap_indices = (res1, res2)\n    return (min_distance, swap_indices)"
    }
  ]
}