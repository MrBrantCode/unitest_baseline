{
  "task_id": "taco_90",
  "entry_point": "calculate_subsequence_sum",
  "mutant_count": 173,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "MOD = 998244354\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "MOD = 998244352\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "MOD = -998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 1\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = -1\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 1\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(a) == 2:",
      "mutated_line": "if len(a) != 2:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) != 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(a) == 2:",
      "mutated_line": "if len(a) == 3:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 3:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(a) == 2:",
      "mutated_line": "if len(a) == 1:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 1:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(a) == 2:",
      "mutated_line": "if len(a) == 0:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 0:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(a) == 2:",
      "mutated_line": "if len(a) == 1:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 1:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(a) == 2:",
      "mutated_line": "if len(a) == -2:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == -2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] / (n + 1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] / (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] + (n + 1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] + (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] ** (n + 1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] ** (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[0] = 2",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 2\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[0] = 0",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 0\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[0] = 0",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 0\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[0] = -1",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = -1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) * MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) * MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = ans + (sum(dp) - dp[0]) * arr[cur] + MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = ans + (sum(dp) - dp[0]) * arr[cur] + MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "arr.append(0)",
      "mutated_line": "arr.append(1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(1)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "arr.append(0)",
      "mutated_line": "arr.append(-1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(-1)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "arr.append(0)",
      "mutated_line": "arr.append(1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(1)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n - 1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n - 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n * 1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n * 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[1] = 1",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[1] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[-1] = 1",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[-1] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0] = 1",
      "mutated_line": "dp[1] = 1",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[1] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if j == cur:",
      "mutated_line": "if j != cur:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j != cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans - (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans - (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = ans * ((sum(dp) - dp[0]) * arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = ans * ((sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [1] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [-1] * (n + 1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [-1] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [1] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 2)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 2)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 0)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 0)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + -1)",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + -1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp = [0] + dp[:n]",
      "mutated_line": "dp = [0] - dp[:n]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] - dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp = [0] + dp[:n]",
      "mutated_line": "dp = [0] * dp[:n]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] * dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif a == 0:",
      "mutated_line": "elif a != 0:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a != 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + (sum(dp) - dp[0]) / arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) / arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + (sum(dp) - dp[0] + arr[cur])) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0] + arr[cur])) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + (sum(dp) - dp[0]) ** arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) ** arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "arr.append(int(a[1]))",
      "mutated_line": "arr.append(int(a[2]))",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[2]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "arr.append(int(a[1]))",
      "mutated_line": "arr.append(int(a[0]))",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[0]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "arr.append(int(a[1]))",
      "mutated_line": "arr.append(int(a[0]))",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[0]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "arr.append(int(a[1]))",
      "mutated_line": "arr.append(int(a[-1]))",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[-1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif a == 0:",
      "mutated_line": "elif a == 1:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 1:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif a == 0:",
      "mutated_line": "elif a == -1:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == -1:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif a == 0:",
      "mutated_line": "elif a == 1:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 1:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[0] + dp[1]) * MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) * MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = 2 * dp[0] + dp[1] + MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = 2 * dp[0] + dp[1] + MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a < arr[cur] and (a == arr[cur] and j < cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] and (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + (sum(dp) + dp[0]) * arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) + dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + sum(dp) * dp[0] * arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + sum(dp) * dp[0] * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp = [0] + dp[:n]",
      "mutated_line": "dp = [1] + dp[:n]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [1] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp = [0] + dp[:n]",
      "mutated_line": "dp = [-1] + dp[:n]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [-1] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp = [0] + dp[:n]",
      "mutated_line": "dp = [1] + dp[:n]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [1] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[1] = (2 * dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[1] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[-1] = (2 * dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[-1] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[1] = (2 * dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[1] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[0] - dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] - dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = 2 * dp[0] * dp[1] % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = 2 * dp[0] * dp[1] % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(2, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(0, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(0, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(-1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = (dp[i] + dp[i + 1]) * MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) * MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = dp[i] + dp[i + 1] + MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = dp[i] + dp[i + 1] + MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a <= arr[cur] or (a == arr[cur] and j < cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a <= arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a >= arr[cur] or (a == arr[cur] and j < cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a >= arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a != arr[cur] or (a == arr[cur] and j < cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a != arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a < arr[cur] or (a == arr[cur] or j < cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] or j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j < cur:",
      "mutated_line": "if j <= cur:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j <= cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j < cur:",
      "mutated_line": "if j >= cur:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j >= cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j < cur:",
      "mutated_line": "if j != cur:",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j != cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 / dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 / dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 + dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 + dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 ** dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 ** dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = (dp[i] - dp[i + 1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] - dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = dp[i] * dp[i + 1] % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = dp[i] * dp[i + 1] % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a < arr[cur] or (a != arr[cur] and j < cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a != arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a < arr[cur] or (a == arr[cur] and j <= cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j <= cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a < arr[cur] or (a == arr[cur] and j >= cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j >= cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif a < arr[cur] or (a == arr[cur] and j < cur):",
      "mutated_line": "elif a < arr[cur] or (a == arr[cur] and j != cur):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j != cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] * 2 * MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 * MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] * 2 + MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 + MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d * 2 * MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 * MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d * 2 + MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 + MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + (sum(dp) - dp[1]) * arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[1]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + (sum(dp) - dp[-1]) * arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[-1]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD",
      "mutated_line": "ans = (ans + (sum(dp) - dp[1]) * arr[cur]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[1]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (3 * dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (3 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (1 * dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (1 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (0 * dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (0 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (1 * dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (1 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (-2 * dp[0] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (-2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[0] + dp[2]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[2]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[0] + dp[0]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[0]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[0] + dp[0]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[0]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[0] + dp[-1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[-1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 1, -1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, -1, -1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, -1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 1, -1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, +1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, +1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 1] + dp[i]) * MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) * MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = dp[i - 1] + dp[i] + MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = dp[i - 1] + dp[i] + MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, 2, -1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 2, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, 0, -1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, 0, -1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, -1, -1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, -1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, 1, +1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, +1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 1] + dp[i]) * MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) * MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = dp[i - 1] + dp[i] + MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = dp[i - 1] + dp[i] + MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[1] = dp[0] * 2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[1] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[-1] = dp[0] * 2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[-1] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[1] = dp[0] * 2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[1] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] / 2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] / 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = (dp[0] + 2) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = (dp[0] + 2) % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] ** 2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] ** 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d / 2 % MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d / 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [(d + 2) % MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [(d + 2) % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d ** 2 % MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d ** 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[1] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[1] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[-1] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[-1] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[0] = (2 * dp[0] + dp[1]) % MOD",
      "mutated_line": "dp[0] = (2 * dp[1] + dp[1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[1] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = (dp[i] + dp[i - 1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i - 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = (dp[i] + dp[i * 1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i * 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -2):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -2):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -0):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -0):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -0):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -0):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, --1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, --1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 1] - dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] - dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = dp[i - 1] * dp[i] % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = dp[i - 1] * dp[i] % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, 1, -2):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -2):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, 1, -0):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -0):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, 1, -0):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -0):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(n, 1, -1):",
      "mutated_line": "for i in range(n, 1, --1):",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, --1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 1] - dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] - dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = dp[i - 1] * dp[i] % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = dp[i - 1] * dp[i] % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] * 3 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 3 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] * 1 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 1 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] * 0 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 0 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] * 1 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 1 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[0] * -2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * -2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d * 3 % MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 3 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d * 1 % MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 1 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d * 0 % MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 0 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d * 1 % MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 1 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp = [d * 2 % MOD for d in dp]",
      "mutated_line": "dp = [d * -2 % MOD for d in dp]",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * -2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = (dp[i] + dp[i + 2]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 2]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = (dp[i] + dp[i + 0]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 0]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = (dp[i] + dp[i + 0]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 0]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i] = (dp[i] + dp[i + 1]) % MOD",
      "mutated_line": "dp[i] = (dp[i] + dp[i + -1]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + -1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[1] * 2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[1] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[-1] * 2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[-1] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = dp[0] * 2 % MOD",
      "mutated_line": "dp[0] = dp[1] * 2 % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[1] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i + 1] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i + 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i * 1] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i * 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i + 1] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i + 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i * 1] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i * 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 2] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 2] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 0] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 0] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 0] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 0] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - -1] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - -1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 2] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 2] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 0] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 0] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - 0] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - 0] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[i] = (dp[i - 1] + dp[i]) % MOD",
      "mutated_line": "dp[i] = (dp[i - -1] + dp[i]) % MOD",
      "code": "MOD = 998244353\n\ndef calculate_subsequence_sum(n, sequence):\n    ans = 0\n    arr = []\n    for i in range(n):\n        a = sequence[i].split()\n        if len(a) == 2:\n            arr.append(int(a[1]))\n        else:\n            arr.append(0)\n    for cur in range(n):\n        if arr[cur]:\n            dp = [0] * (n + 1)\n            dp[0] = 1\n            for (j, a) in enumerate(arr):\n                if j == cur:\n                    dp = [0] + dp[:n]\n                elif a == 0:\n                    dp[0] = (2 * dp[0] + dp[1]) % MOD\n                    for i in range(1, n):\n                        dp[i] = (dp[i] + dp[i + 1]) % MOD\n                elif a < arr[cur] or (a == arr[cur] and j < cur):\n                    if j < cur:\n                        for i in range(n, 0, -1):\n                            dp[i] = (dp[i - 1] + dp[i]) % MOD\n                    else:\n                        for i in range(n, 1, -1):\n                            dp[i] = (dp[i - -1] + dp[i]) % MOD\n                        dp[0] = dp[0] * 2 % MOD\n                else:\n                    dp = [d * 2 % MOD for d in dp]\n            ans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\n    return ans"
    }
  ]
}