{
  "task_id": "taco_8550",
  "entry_point": "check_flood_avoidance",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "d[x - p] += 1",
      "mutated_line": "d[x - p] -= 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] -= 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "d[x] -= 2",
      "mutated_line": "d[x] += 2",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] += 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "d[x + p] += 1",
      "mutated_line": "d[x + p] -= 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] -= 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "d[y] += d[x]",
      "mutated_line": "d[y] -= d[x]",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] -= d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 1\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p = 0",
      "mutated_line": "p = -1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = -1\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 1\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "p += d[x] * (y - x)",
      "mutated_line": "p -= d[x] * (y - x)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p -= d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d[x - p] += 1",
      "mutated_line": "d[x - p] += 2",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 2\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d[x - p] += 1",
      "mutated_line": "d[x - p] += 0",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 0\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d[x - p] += 1",
      "mutated_line": "d[x - p] += 0",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 0\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d[x - p] += 1",
      "mutated_line": "d[x - p] += -1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += -1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[x] -= 2",
      "mutated_line": "d[x] -= 3",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 3\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[x] -= 2",
      "mutated_line": "d[x] -= 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 1\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[x] -= 2",
      "mutated_line": "d[x] -= 0",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 0\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[x] -= 2",
      "mutated_line": "d[x] -= 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 1\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[x] -= 2",
      "mutated_line": "d[x] -= -2",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= -2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[x + p] += 1",
      "mutated_line": "d[x + p] += 2",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 2\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[x + p] += 1",
      "mutated_line": "d[x + p] += 0",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 0\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[x + p] += 1",
      "mutated_line": "d[x + p] += 0",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 0\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[x + p] += 1",
      "mutated_line": "d[x + p] += -1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += -1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "(l, r) = (math.inf, -math.inf)",
      "mutated_line": "(l, r) = (math.inf, +math.inf)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, +math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p += d[x] * (y - x)",
      "mutated_line": "p += d[x] / (y - x)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] / (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p += d[x] * (y - x)",
      "mutated_line": "p += d[x] + (y - x)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] + (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p += d[x] * (y - x)",
      "mutated_line": "p += d[x] ** (y - x)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] ** (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if p > m:",
      "mutated_line": "if p >= m:",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p >= m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if p > m:",
      "mutated_line": "if p <= m:",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p <= m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if p > m:",
      "mutated_line": "if p != m:",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p != m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "d[x - p] += 1",
      "mutated_line": "d[x + p] += 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x + p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "d[x - p] += 1",
      "mutated_line": "d[x * p] += 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x * p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "d[x + p] += 1",
      "mutated_line": "d[x - p] += 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x - p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "d[x + p] += 1",
      "mutated_line": "d[x * p] += 1",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x * p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p += d[x] * (y - x)",
      "mutated_line": "p += d[x] * (y + x)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y + x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p += d[x] * (y - x)",
      "mutated_line": "p += d[x] * (y * x)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y * x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = 'MUTATED'.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = 'MUTATED'.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for (x, y) in zip(centres, centres[1:]):",
      "mutated_line": "for (x, y) in zip(centres, centres[2:]):",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[2:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for (x, y) in zip(centres, centres[1:]):",
      "mutated_line": "for (x, y) in zip(centres, centres[0:]):",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[0:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for (x, y) in zip(centres, centres[1:]):",
      "mutated_line": "for (x, y) in zip(centres, centres[0:]):",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[0:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for (x, y) in zip(centres, centres[1:]):",
      "mutated_line": "for (x, y) in zip(centres, centres[-1:]):",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[-1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (x, y) in zip(centres, centres[1:]):",
      "mutated_line": "for (x, y) in zip(centres, centres[2:]):",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[2:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (x, y) in zip(centres, centres[1:]):",
      "mutated_line": "for (x, y) in zip(centres, centres[0:]):",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[0:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (x, y) in zip(centres, centres[1:]):",
      "mutated_line": "for (x, y) in zip(centres, centres[0:]):",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[0:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for (x, y) in zip(centres, centres[1:]):",
      "mutated_line": "for (x, y) in zip(centres, centres[-1:]):",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[-1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "l = min(l, y - (p - m))",
      "mutated_line": "l = min(l, y + (p - m))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y + (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "l = min(l, y - (p - m))",
      "mutated_line": "l = min(l, y * (p - m))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y * (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = max(r, y + (p - m))",
      "mutated_line": "r = max(r, y - (p - m))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y - (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = max(r, y + (p - m))",
      "mutated_line": "r = max(r, y * (p - m))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y * (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "l = min(l, y - (p - m))",
      "mutated_line": "l = min(l, y - (p + m))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p + m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "l = min(l, y - (p - m))",
      "mutated_line": "l = min(l, y - p * m)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - p * m)\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = max(r, y + (p - m))",
      "mutated_line": "r = max(r, y + (p + m))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p + m))\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = max(r, y + (p - m))",
      "mutated_line": "r = max(r, y + p * m)",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + p * m)\n        result = ''.join((str(int(x - p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p <= l or x + p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l or x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p < l and x + p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p < l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p > l and x + p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p > l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p == l and x + p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p == l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p <= l and x + p > r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p > r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p <= l and x + p < r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p < r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p <= l and x + p == r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x + p == r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x + p <= l and x + p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x + p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x * p <= l and x + p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x * p <= l and x + p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p <= l and x - p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x - p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "result = ''.join(str(int(x - p <= l and x + p >= r)) for (x, p) in rains)",
      "mutated_line": "result = ''.join((str(int(x - p <= l and x * p >= r)) for (x, p) in rains))",
      "code": "import math\nimport collections\n\ndef check_flood_avoidance(test_cases):\n    results = []\n    for (n, m, rains) in test_cases:\n        d = collections.defaultdict(int)\n        for (x, p) in rains:\n            d[x - p] += 1\n            d[x] -= 2\n            d[x + p] += 1\n        centres = sorted(d)\n        for (x, y) in zip(centres, centres[1:]):\n            d[y] += d[x]\n        (l, r) = (math.inf, -math.inf)\n        p = 0\n        for (x, y) in zip(centres, centres[1:]):\n            p += d[x] * (y - x)\n            if p > m:\n                l = min(l, y - (p - m))\n                r = max(r, y + (p - m))\n        result = ''.join((str(int(x - p <= l and x * p >= r)) for (x, p) in rains))\n        results.append(result)\n    return results"
    }
  ]
}