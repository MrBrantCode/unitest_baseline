{
  "task_id": "taco_3484",
  "entry_point": "min_operations_to_star_tree",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] / (n + 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] / (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] + (n + 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] + (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] ** (n + 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] ** (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "C[1] = 0",
      "mutated_line": "C[1] = 1",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 1\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "C[1] = 0",
      "mutated_line": "C[1] = -1",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = -1\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "C[1] = 0",
      "mutated_line": "C[1] = 1",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 1\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return min(B, W) - 1",
      "mutated_line": "return min(B, W) + 1",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return min(B, W) - 1",
      "mutated_line": "return min(B, W) * 1",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) * 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n - 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n - 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n * 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n * 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Q = [1]",
      "mutated_line": "Q = [2]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [2]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Q = [1]",
      "mutated_line": "Q = [0]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [0]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Q = [1]",
      "mutated_line": "Q = [0]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [0]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Q = [1]",
      "mutated_line": "Q = [-1]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [-1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "C[1] = 0",
      "mutated_line": "C[2] = 0",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[2] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "C[1] = 0",
      "mutated_line": "C[0] = 0",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[0] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "C[1] = 0",
      "mutated_line": "C[0] = 0",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[0] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "C[1] = 0",
      "mutated_line": "C[-1] = 0",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[-1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B = C.count(0)",
      "mutated_line": "B = C.count(1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(1)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B = C.count(0)",
      "mutated_line": "B = C.count(-1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(-1)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B = C.count(0)",
      "mutated_line": "B = C.count(1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(1)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "W = C.count(1)",
      "mutated_line": "W = C.count(2)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(2)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "W = C.count(1)",
      "mutated_line": "W = C.count(0)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(0)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "W = C.count(1)",
      "mutated_line": "W = C.count(0)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(0)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "W = C.count(1)",
      "mutated_line": "W = C.count(-1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(-1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(B, W) - 1",
      "mutated_line": "return min(B, W) - 2",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(B, W) - 1",
      "mutated_line": "return min(B, W) - 0",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(B, W) - 1",
      "mutated_line": "return min(B, W) - 0",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return min(B, W) - 1",
      "mutated_line": "return min(B, W) - -1",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [+1] * (n + 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [+1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n + 2)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 2)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n + 0)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 0)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n + 0)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 0)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-1] * (n + -1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + -1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if C[to] == -1:",
      "mutated_line": "if C[to] != -1:",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] != -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n - 1)]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n * 1)]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-2] * (n + 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-2] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-0] * (n + 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-0] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [-0] * (n + 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-0] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [-1] * (n + 1)",
      "mutated_line": "C = [--1] * (n + 1)",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [--1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "if C[to] == -1:",
      "mutated_line": "if C[to] == +1:",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == +1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "C[to] = 1 - C[x]",
      "mutated_line": "C[to] = 1 + C[x]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 + C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "C[to] = 1 - C[x]",
      "mutated_line": "C[to] = 1 * C[x]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 * C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n + 2)]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n + 0)]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n + 0)]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n + -1)]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C[to] == -1:",
      "mutated_line": "if C[to] == -2:",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -2:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C[to] == -1:",
      "mutated_line": "if C[to] == -0:",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -0:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C[to] == -1:",
      "mutated_line": "if C[to] == -0:",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -0:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C[to] == -1:",
      "mutated_line": "if C[to] == --1:",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == --1:\n                C[to] = 1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "C[to] = 1 - C[x]",
      "mutated_line": "C[to] = 2 - C[x]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 2 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "C[to] = 1 - C[x]",
      "mutated_line": "C[to] = 0 - C[x]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 0 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "C[to] = 1 - C[x]",
      "mutated_line": "C[to] = 0 - C[x]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = 0 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "C[to] = 1 - C[x]",
      "mutated_line": "C[to] = -1 - C[x]",
      "code": "def min_operations_to_star_tree(n, edges):\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    C = [-1] * (n + 1)\n    Q = [1]\n    C[1] = 0\n    while Q:\n        x = Q.pop()\n        for to in E[x]:\n            if C[to] == -1:\n                C[to] = -1 - C[x]\n                Q.append(to)\n    B = C.count(0)\n    W = C.count(1)\n    return min(B, W) - 1"
    }
  ]
}