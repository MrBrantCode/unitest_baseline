{
  "task_id": "taco_15465",
  "entry_point": "calculate_optimal_city_configuration",
  "mutant_count": 127,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "total_operations = len(ans) + len(first)",
      "mutated_line": "total_operations = len(ans) - len(first)",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) - len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "total_operations = len(ans) + len(first)",
      "mutated_line": "total_operations = len(ans) * len(first)",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) * len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "operations = first + ans",
      "mutated_line": "operations = first - ans",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first - ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "operations = first + ans",
      "mutated_line": "operations = first * ans",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first * ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = [[0 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "a = [[1 for _ in range(m)] for _ in range(n)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[1 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = [[0 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "a = [[-1 for _ in range(m)] for _ in range(n)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[-1 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = [[0 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "a = [[1 for _ in range(m)] for _ in range(n)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[1 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if grid[i][j] == '#':",
      "mutated_line": "if grid[i][j] != '#':",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a[i][j] != -1:",
      "mutated_line": "if a[i][j] == -1:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "d = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == '#':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "a[i][j] = -1",
      "mutated_line": "a[i][j] = +1",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = +1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "if a[i][j] != -1:",
      "mutated_line": "if a[i][j] != +1:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != +1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i][j] = -1",
      "mutated_line": "a[i][j] = -2",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -2\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i][j] = -1",
      "mutated_line": "a[i][j] = -0",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -0\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i][j] = -1",
      "mutated_line": "a[i][j] = -0",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -0\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i][j] = -1",
      "mutated_line": "a[i][j] = --1",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = --1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[i][j] != -1:",
      "mutated_line": "if a[i][j] != -2:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -2:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[i][j] != -1:",
      "mutated_line": "if a[i][j] != -0:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -0:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[i][j] != -1:",
      "mutated_line": "if a[i][j] != -0:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -0:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[i][j] != -1:",
      "mutated_line": "if a[i][j] != --1:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != --1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if a[x][y] == -1:",
      "mutated_line": "if a[x][y] != -1:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] != -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "a[x][y] = -1",
      "mutated_line": "a[x][y] = +1",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = +1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (x, y) != (i, j):",
      "mutated_line": "if (x, y) == (i, j):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) == (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'{i + 1} {j + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'{i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 1}{j + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1}{j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if a[x][y] == -1:",
      "mutated_line": "if a[x][y] == +1:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == +1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a[x][y] = -1",
      "mutated_line": "a[x][y] = -2",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -2\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a[x][y] = -1",
      "mutated_line": "a[x][y] = -0",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -0\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a[x][y] = -1",
      "mutated_line": "a[x][y] = -0",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -0\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a[x][y] = -1",
      "mutated_line": "a[x][y] = --1",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = --1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "x1 = x + dx",
      "mutated_line": "x1 = x - dx",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x - dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "x1 = x + dx",
      "mutated_line": "x1 = x * dx",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x * dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "y1 = y + dy",
      "mutated_line": "y1 = y - dy",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y - dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "y1 = y + dy",
      "mutated_line": "y1 = y * dy",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y * dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n or 0 <= y1 < m or a[x1][y1] != -1:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n or 0 <= y1 < m or a[x1][y1] != -1:\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i - 1} {j + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i - 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i * 1} {j + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i * 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 1} {j - 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j - 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 1} {j * 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j * 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if a[x][y] == -1:",
      "mutated_line": "if a[x][y] == -2:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -2:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if a[x][y] == -1:",
      "mutated_line": "if a[x][y] == -0:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -0:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if a[x][y] == -1:",
      "mutated_line": "if a[x][y] == -0:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -0:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if a[x][y] == -1:",
      "mutated_line": "if a[x][y] == --1:",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == --1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 < x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 < x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 > x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 > x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 == x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 == x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 < y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 < y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 > y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 > y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 == y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 == y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] == -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] == -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 2} {j + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 2} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 0} {j + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 0} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 0} {j + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 0} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + -1} {j + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + -1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 1} {j + 2}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 2}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 1} {j + 0}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 0}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 1} {j + 0}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 0}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "first.append(f'B {i + 1} {j + 1}')",
      "mutated_line": "first.append(f'B {i + 1} {j + -1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + -1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'{x + 1} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'{x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 1}{y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1}{y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'{x + 1} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'{x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 1}{y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1}{y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 1 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 1 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if -1 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if -1 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 1 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 1 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 1 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 1 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and -1 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and -1 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 1 <= y1 < m and (a[x1][y1] != -1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 1 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != +1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != +1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x - 1} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x - 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x * 1} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x * 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 1} {y - 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y - 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 1} {y * 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y * 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x - 1} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x - 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x * 1} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x * 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 1} {y - 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y - 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 1} {y * 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y * 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -2):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -2):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -0):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -0):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -0):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -0):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):",
      "mutated_line": "if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != --1):",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != --1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 2} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 2} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 0} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 0} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 0} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 0} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + -1} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + -1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 1} {y + 2}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 2}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 1} {y + 0}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 0}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 1} {y + 0}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 0}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(f'R {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'R {x + 1} {y + -1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + -1}')\n                        ans.append(f'D {x + 1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 2} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 2} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 0} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 0} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 0} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 0} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + -1} {y + 1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + -1} {y + 1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 1} {y + 2}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 2}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 1} {y + 0}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 0}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 1} {y + 0}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + 0}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append(f'D {x + 1} {y + 1}')",
      "mutated_line": "ans.append(f'D {x + 1} {y + -1}')",
      "code": "def calculate_optimal_city_configuration(n, m, grid):\n    a = [[0 for _ in range(m)] for _ in range(n)]\n    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque()\n    ans = []\n    first = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                a[i][j] = -1\n            else:\n                first.append(f'B {i + 1} {j + 1}')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != -1:\n                q.append((i, j))\n                while q:\n                    (x, y) = q.pop()\n                    if a[x][y] == -1:\n                        continue\n                    a[x][y] = -1\n                    if (x, y) != (i, j):\n                        ans.append(f'R {x + 1} {y + 1}')\n                        ans.append(f'D {x + 1} {y + -1}')\n                    for (dx, dy) in d:\n                        x1 = x + dx\n                        y1 = y + dy\n                        if 0 <= x1 < n and 0 <= y1 < m and (a[x1][y1] != -1):\n                            q.appendleft((x1, y1))\n    ans.reverse()\n    total_operations = len(ans) + len(first)\n    operations = first + ans\n    return (total_operations, operations)"
    }
  ]
}