{
  "task_id": "taco_8485",
  "entry_point": "find_optimal_village",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] / (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] / (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] + (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] + (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] ** (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] ** (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] / (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] / (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] + (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] + (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] ** (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] ** (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "x = -1",
      "mutated_line": "x = +1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = +1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] * (n - 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n - 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] * (n * 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n * 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n - 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n - 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n * 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n * 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "stack = [1]",
      "mutated_line": "stack = [2]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [2]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "stack = [1]",
      "mutated_line": "stack = [0]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [0]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "stack = [1]",
      "mutated_line": "stack = [0]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [0]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "stack = [1]",
      "mutated_line": "stack = [-1]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [-1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "w = float('inf')",
      "mutated_line": "w = float('')",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = -1",
      "mutated_line": "x = -2",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -2\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = -1",
      "mutated_line": "x = -0",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -0\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = -1",
      "mutated_line": "x = -0",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -0\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = -1",
      "mutated_line": "x = --1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = --1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if node not in visited:",
      "mutated_line": "if node in visited:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [+1] * (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [+1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] * (n + 2)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 2)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] * (n + 0)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 0)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] * (n + 0)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 0)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-1] * (n + -1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + -1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [1] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [-1] * (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [-1] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [1] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 2)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 2)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 0)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 0)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + -1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + -1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[+1]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[+1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 1\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = -1\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 1\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if node == 1:",
      "mutated_line": "if node != 1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node != 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "count -= 1",
      "mutated_line": "count += 1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count += 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if count == len(edges[node]) - 1:",
      "mutated_line": "if count != len(edges[node]) - 1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count != len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "dp[node] += 1",
      "mutated_line": "dp[node] -= 1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] -= 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-2] * (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-2] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-0] * (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-0] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [-0] * (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-0] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "parents = [-1] * (n + 1)",
      "mutated_line": "parents = [--1] * (n + 1)",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [--1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[-2]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-2]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[-0]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-0]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[-0]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-0]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[--1]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[--1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if parents[kid] == -1:",
      "mutated_line": "if parents[kid] != -1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] != -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if node == 1:",
      "mutated_line": "if node == 2:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 2:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if node == 1:",
      "mutated_line": "if node == 0:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 0:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if node == 1:",
      "mutated_line": "if node == 0:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 0:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if node == 1:",
      "mutated_line": "if node == -1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == -1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "count -= 1",
      "mutated_line": "count -= 2",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 2\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "count -= 1",
      "mutated_line": "count -= 0",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 0\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "count -= 1",
      "mutated_line": "count -= 0",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 0\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "count -= 1",
      "mutated_line": "count -= -1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= -1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if count == len(edges[node]) - 1:",
      "mutated_line": "if count == len(edges[node]) + 1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) + 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if count == len(edges[node]) - 1:",
      "mutated_line": "if count == len(edges[node]) * 1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) * 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "max_val = 0",
      "mutated_line": "max_val = 1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 1\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "max_val = 0",
      "mutated_line": "max_val = -1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = -1\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "max_val = 0",
      "mutated_line": "max_val = 1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 1\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "dp[node] += dp[kid]",
      "mutated_line": "dp[node] -= dp[kid]",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] -= dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[node] += 1",
      "mutated_line": "dp[node] += 2",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 2\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[node] += 1",
      "mutated_line": "dp[node] += 0",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 0\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[node] += 1",
      "mutated_line": "dp[node] += 0",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 0\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[node] += 1",
      "mutated_line": "dp[node] += -1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += -1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if max_val < w:",
      "mutated_line": "if max_val <= w:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val <= w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if max_val < w:",
      "mutated_line": "if max_val >= w:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val >= w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if max_val < w:",
      "mutated_line": "if max_val != w:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val != w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "if parents[kid] == -1:",
      "mutated_line": "if parents[kid] == +1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == +1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if kid != 1:",
      "mutated_line": "if kid == 1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid == 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif kid != parents[node]:",
      "mutated_line": "elif kid == parents[node]:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid == parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if count == len(edges[node]) - 1:",
      "mutated_line": "if count == len(edges[node]) - 2:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 2:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if count == len(edges[node]) - 1:",
      "mutated_line": "if count == len(edges[node]) - 0:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 0:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if count == len(edges[node]) - 1:",
      "mutated_line": "if count == len(edges[node]) - 0:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 0:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if count == len(edges[node]) - 1:",
      "mutated_line": "if count == len(edges[node]) - -1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - -1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "max_val = max(max_val, n - dp[node])",
      "mutated_line": "max_val = max(max_val, n + dp[node])",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n + dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "max_val = max(max_val, n - dp[node])",
      "mutated_line": "max_val = max(max_val, n * dp[node])",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n * dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif max_val == w:",
      "mutated_line": "elif max_val != w:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val != w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if parents[kid] == -1:",
      "mutated_line": "if parents[kid] == -2:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -2:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if parents[kid] == -1:",
      "mutated_line": "if parents[kid] == -0:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -0:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if parents[kid] == -1:",
      "mutated_line": "if parents[kid] == -0:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -0:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if parents[kid] == -1:",
      "mutated_line": "if parents[kid] == --1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == --1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if kid != 1:",
      "mutated_line": "if kid != 2:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 2:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if kid != 1:",
      "mutated_line": "if kid != 0:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 0:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if kid != 1:",
      "mutated_line": "if kid != 0:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 0:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if kid != 1:",
      "mutated_line": "if kid != -1:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != -1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if kid in visited:",
      "mutated_line": "if kid not in visited:",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid not in visited:\n                        count += 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count -= 1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 2\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 0\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += 0\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def find_optimal_village(n, edges):\n    visited = set()\n    parents = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [1]\n    w = float('inf')\n    x = -1\n    while stack:\n        node = stack[-1]\n        if node not in visited:\n            count = 0\n            for kid in edges[node]:\n                if parents[kid] == -1:\n                    if kid != 1:\n                        parents[kid] = node\n                elif kid != parents[node]:\n                    if kid in visited:\n                        count += -1\n                    else:\n                        stack.append(kid)\n            if node == 1:\n                count -= 1\n            if count == len(edges[node]) - 1:\n                stack.pop()\n                visited.add(node)\n                max_val = 0\n                for kid in edges[node]:\n                    dp[node] += dp[kid]\n                    max_val = max(max_val, dp[kid])\n                dp[node] += 1\n                max_val = max(max_val, n - dp[node])\n                if max_val < w:\n                    w = max_val\n                    x = node\n                elif max_val == w:\n                    x = min(x, node)\n    return (x, w)"
    }
  ]
}