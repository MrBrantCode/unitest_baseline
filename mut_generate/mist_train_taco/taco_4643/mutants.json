{
  "task_id": "taco_4643",
  "entry_point": "find_max_moves_in_maze",
  "mutant_count": 170,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "max_moves = 0",
      "mutated_line": "max_moves = 1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 1\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "max_moves = 0",
      "mutated_line": "max_moves = -1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = -1\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "max_moves = 0",
      "mutated_line": "max_moves = 1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 1\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if M[i][j] != '.':",
      "mutated_line": "if M[i][j] == '.':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] == '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "checked[i][j] = 1",
      "mutated_line": "checked[i][j] = 2",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 2\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "checked[i][j] = 1",
      "mutated_line": "checked[i][j] = 0",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 0\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "checked[i][j] = 1",
      "mutated_line": "checked[i][j] = 0",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 0\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "checked[i][j] = 1",
      "mutated_line": "checked[i][j] = -1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = -1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 1\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a = 0",
      "mutated_line": "a = -1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = -1\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 1\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] / (W + 2)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] / (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] + (W + 2)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] + (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] ** (W + 2)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] ** (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] / (W + 2))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] / (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] + (W + 2))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] + (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] ** (W + 2))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] ** (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(2, H + 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(2, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(0, H + 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(0, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(0, H + 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(0, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(-1, H + 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(-1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(1, H - 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H - 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(1, H * 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H * 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if M[i][j] != '.':",
      "mutated_line": "if M[i][j] != '':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 1\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return -1\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 1\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "checked = [[0] * W for _ in range(H)]",
      "mutated_line": "checked = [[0] / W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] / W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "checked = [[0] * W for _ in range(H)]",
      "mutated_line": "checked = [[0] + W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] + W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "checked = [[0] * W for _ in range(H)]",
      "mutated_line": "checked = [[0] ** W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] ** W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = [[0] * W for _ in range(H)]",
      "mutated_line": "z = [[0] / W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] / W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = [[0] * W for _ in range(H)]",
      "mutated_line": "z = [[0] + W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] + W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = [[0] * W for _ in range(H)]",
      "mutated_line": "z = [[0] ** W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] ** W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] * (W - 2)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W - 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] * (W * 2)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W * 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "padded_maze.append(['X'] + list(row) + ['X'])",
      "mutated_line": "padded_maze.append(['X'] + list(row) - ['X'])",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) - ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "padded_maze.append(['X'] + list(row) + ['X'])",
      "mutated_line": "padded_maze.append((['X'] + list(row)) * ['X'])",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append((['X'] + list(row)) * ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] * (W - 2))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W - 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] * (W * 2))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W * 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(1, H + 2):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 2):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(1, H + 0):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 0):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(1, H + 0):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 0):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, H + 1):",
      "mutated_line": "for i in range(1, H + -1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + -1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(2, W + 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(2, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(0, W + 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(0, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(0, W + 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(0, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(-1, W + 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(-1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(1, W - 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W - 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(1, W * 1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W * 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if padded_maze[i][j] == '.':",
      "mutated_line": "if padded_maze[i][j] != '.':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] != '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "to_visit = [{'row': i, 'col': j, 'step': 0}]",
      "mutated_line": "to_visit = [{'': i, 'col': j, 'step': 0}]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "to_visit = [{'row': i, 'col': j, 'step': 0}]",
      "mutated_line": "to_visit = [{'row': i, '': j, 'step': 0}]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, '': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "to_visit = [{'row': i, 'col': j, 'step': 0}]",
      "mutated_line": "to_visit = [{'row': i, 'col': j, '': 0}]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, '': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "to_visit = [{'row': i, 'col': j, 'step': 0}]",
      "mutated_line": "to_visit = [{'row': i, 'col': j, 'step': 1}]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 1}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "to_visit = [{'row': i, 'col': j, 'step': 0}]",
      "mutated_line": "to_visit = [{'row': i, 'col': j, 'step': -1}]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': -1}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "to_visit = [{'row': i, 'col': j, 'step': 0}]",
      "mutated_line": "to_visit = [{'row': i, 'col': j, 'step': 1}]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 1}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visiting = to_visit.pop(0)",
      "mutated_line": "visiting = to_visit.pop(1)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(1)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visiting = to_visit.pop(0)",
      "mutated_line": "visiting = to_visit.pop(-1)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(-1)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visiting = to_visit.pop(0)",
      "mutated_line": "visiting = to_visit.pop(1)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(1)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r0 = visiting['row']",
      "mutated_line": "r0 = visiting['']",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c0 = visiting['col']",
      "mutated_line": "c0 = visiting['']",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "s0 = visiting['step']",
      "mutated_line": "s0 = visiting['']",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r = r0 + d[0]",
      "mutated_line": "r = r0 - d[0]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 - d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "r = r0 + d[0]",
      "mutated_line": "r = r0 * d[0]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 * d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c = c0 + d[1]",
      "mutated_line": "c = c0 - d[1]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 - d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c = c0 + d[1]",
      "mutated_line": "c = c0 * d[1]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 * d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = s0 + 1",
      "mutated_line": "s = s0 - 1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 - 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = s0 + 1",
      "mutated_line": "s = s0 * 1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 * 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if checked[r][c] == 0 and M[r][c] == '.':",
      "mutated_line": "if checked[r][c] == 0 or M[r][c] == '.':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 or M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if a < z[i][j]:",
      "mutated_line": "if a <= z[i][j]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a <= z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if a < z[i][j]:",
      "mutated_line": "if a >= z[i][j]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a >= z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if a < z[i][j]:",
      "mutated_line": "if a != z[i][j]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a != z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [[''] * (W + 2)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [[''] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] * (W + 3)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 3)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] * (W + 1)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 1)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] * (W + 0)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 0)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] * (W + 1)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 1)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "padded_maze = [['X'] * (W + 2)]",
      "mutated_line": "padded_maze = [['X'] * (W + -2)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + -2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "padded_maze.append(['X'] + list(row) + ['X'])",
      "mutated_line": "padded_maze.append(['X'] - list(row) + ['X'])",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] - list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "padded_maze.append(['X'] + list(row) + ['X'])",
      "mutated_line": "padded_maze.append(['X'] * list(row) + ['X'])",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] * list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append([''] * (W + 2))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append([''] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] * (W + 3))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 3))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] * (W + 1))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 1))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] * (W + 0))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 0))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] * (W + 1))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 1))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "padded_maze.append(['X'] * (W + 2))",
      "mutated_line": "padded_maze.append(['X'] * (W + -2))",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + -2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(1, W + 2):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 2):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(1, W + 0):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 0):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(1, W + 0):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 0):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(1, W + 1):",
      "mutated_line": "for j in range(1, W + -1):",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + -1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if padded_maze[i][j] == '.':",
      "mutated_line": "if padded_maze[i][j] == '':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if moves > max_moves:",
      "mutated_line": "if moves >= max_moves:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves >= max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if moves > max_moves:",
      "mutated_line": "if moves <= max_moves:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves <= max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if moves > max_moves:",
      "mutated_line": "if moves != max_moves:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves != max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "checked = [[0] * W for _ in range(H)]",
      "mutated_line": "checked = [[1] * W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[1] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "checked = [[0] * W for _ in range(H)]",
      "mutated_line": "checked = [[-1] * W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[-1] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "checked = [[0] * W for _ in range(H)]",
      "mutated_line": "checked = [[1] * W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[1] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = [[0] * W for _ in range(H)]",
      "mutated_line": "z = [[1] * W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[1] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = [[0] * W for _ in range(H)]",
      "mutated_line": "z = [[-1] * W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[-1] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = [[0] * W for _ in range(H)]",
      "mutated_line": "z = [[1] * W for _ in range(H)]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[1] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[2, 0], [-1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[2, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[0, 0], [-1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[0, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[0, 0], [-1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[0, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[-1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[-1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 1], [-1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 1], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, -1], [-1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, -1], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 1], [-1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 1], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [+1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [+1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 1], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 1], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, -1], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, -1], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 1], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 1], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [1, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [1, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [-1, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [-1, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [1, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [1, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 2], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 2], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 0], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 0], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 0], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 0], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, -1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, -1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 1], [1, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [1, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 1], [-1, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [-1, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 1], [1, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [1, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, +1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, +1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = s0 + 1",
      "mutated_line": "s = s0 + 2",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 2\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = s0 + 1",
      "mutated_line": "s = s0 + 0",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 0\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = s0 + 1",
      "mutated_line": "s = s0 + 0",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 0\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = s0 + 1",
      "mutated_line": "s = s0 + -1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + -1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if checked[r][c] == 0 and M[r][c] == '.':",
      "mutated_line": "if checked[r][c] != 0 and M[r][c] == '.':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] != 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if checked[r][c] == 0 and M[r][c] == '.':",
      "mutated_line": "if checked[r][c] == 0 and M[r][c] != '.':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] != '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "checked[r][c] = 1",
      "mutated_line": "checked[r][c] = 2",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 2\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "checked[r][c] = 1",
      "mutated_line": "checked[r][c] = 0",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 0\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "checked[r][c] = 1",
      "mutated_line": "checked[r][c] = 0",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 0\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "checked[r][c] = 1",
      "mutated_line": "checked[r][c] = -1",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = -1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "padded_maze.append(['X'] + list(row) + ['X'])",
      "mutated_line": "padded_maze.append(['X'] + list(row) + [''])",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + [''])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H - 2, W + 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H - 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H * 2, W + 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H * 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 2, W - 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W - 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 2, W * 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W * 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-2, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-2, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-0, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-0, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-0, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-0, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [--1, 0], [0, 1], [0, -1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [--1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -2]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -2]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -0]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -0]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -0]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -0]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:",
      "mutated_line": "for d in [[1, 0], [-1, 0], [0, 1], [0, --1]]:",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, --1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = r0 + d[0]",
      "mutated_line": "r = r0 + d[1]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[1]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = r0 + d[0]",
      "mutated_line": "r = r0 + d[-1]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[-1]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = r0 + d[0]",
      "mutated_line": "r = r0 + d[1]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[1]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c = c0 + d[1]",
      "mutated_line": "c = c0 + d[2]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[2]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c = c0 + d[1]",
      "mutated_line": "c = c0 + d[0]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[0]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c = c0 + d[1]",
      "mutated_line": "c = c0 + d[0]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[0]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c = c0 + d[1]",
      "mutated_line": "c = c0 + d[-1]",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[-1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if checked[r][c] == 0 and M[r][c] == '.':",
      "mutated_line": "if checked[r][c] == 1 and M[r][c] == '.':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 1 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if checked[r][c] == 0 and M[r][c] == '.':",
      "mutated_line": "if checked[r][c] == -1 and M[r][c] == '.':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == -1 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if checked[r][c] == 0 and M[r][c] == '.':",
      "mutated_line": "if checked[r][c] == 1 and M[r][c] == '.':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 1 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if checked[r][c] == 0 and M[r][c] == '.':",
      "mutated_line": "if checked[r][c] == 0 and M[r][c] == '':",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "padded_maze.append(['X'] + list(row) + ['X'])",
      "mutated_line": "padded_maze.append([''] + list(row) + ['X'])",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append([''] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 3, W + 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 3, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 1, W + 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 1, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 0, W + 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 0, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 1, W + 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 1, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + -2, W + 2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + -2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 2, W + 3)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 3)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 2, W + 1)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 1)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 2, W + 0)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 0)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 2, W + 1)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 1)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "moves = BFS(padded_maze, i, j, H + 2, W + 2)",
      "mutated_line": "moves = BFS(padded_maze, i, j, H + 2, W + -2)",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + -2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_visit.append({'row': r, 'col': c, 'step': s})",
      "mutated_line": "to_visit.append({'': r, 'col': c, 'step': s})",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'': r, 'col': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_visit.append({'row': r, 'col': c, 'step': s})",
      "mutated_line": "to_visit.append({'row': r, '': c, 'step': s})",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, '': c, 'step': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_visit.append({'row': r, 'col': c, 'step': s})",
      "mutated_line": "to_visit.append({'row': r, 'col': c, '': s})",
      "code": "def find_max_moves_in_maze(H, W, S):\n\n    def BFS(M, i, j, H, W):\n        if M[i][j] != '.':\n            return 0\n        to_visit = [{'row': i, 'col': j, 'step': 0}]\n        checked = [[0] * W for _ in range(H)]\n        checked[i][j] = 1\n        z = [[0] * W for _ in range(H)]\n        while to_visit:\n            visiting = to_visit.pop(0)\n            r0 = visiting['row']\n            c0 = visiting['col']\n            s0 = visiting['step']\n            z[r0][c0] = s0\n            for d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                r = r0 + d[0]\n                c = c0 + d[1]\n                s = s0 + 1\n                if checked[r][c] == 0 and M[r][c] == '.':\n                    to_visit.append({'row': r, 'col': c, '': s})\n                    checked[r][c] = 1\n        a = 0\n        for i in range(len(z)):\n            for j in range(len(z[i])):\n                if a < z[i][j]:\n                    a = z[i][j]\n        return a\n    padded_maze = [['X'] * (W + 2)]\n    for row in S:\n        padded_maze.append(['X'] + list(row) + ['X'])\n    padded_maze.append(['X'] * (W + 2))\n    max_moves = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if padded_maze[i][j] == '.':\n                moves = BFS(padded_maze, i, j, H + 2, W + 2)\n                if moves > max_moves:\n                    max_moves = moves\n    return max_moves"
    }
  ]
}