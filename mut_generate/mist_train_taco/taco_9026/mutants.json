{
  "task_id": "taco_9026",
  "entry_point": "count_nodes_within_distance",
  "mutant_count": 214,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000008\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000006\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 0\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = -1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 101",
      "mutated_line": "N = 102",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 102\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 101",
      "mutated_line": "N = 100",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 100\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 101",
      "mutated_line": "N = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 0\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 101",
      "mutated_line": "N = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 1\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "N = 101",
      "mutated_line": "N = -101",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = -101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[0][0] = 2",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 2\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[0][0] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 0\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[0][0] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 0\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[0][0] = -1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = -1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 1][0] = 2",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 2\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 1][0] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 0\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 1][0] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 0\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 1][0] = -1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = -1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 1][N - di] -= 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] -= 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [0] / N",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] / N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [0] + N",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] + N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [0] ** N",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] ** N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "b[0] = 1",
      "mutated_line": "b[0] = 2",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 2\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "b[0] = 1",
      "mutated_line": "b[0] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 0\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "b[0] = 1",
      "mutated_line": "b[0] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 0\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "b[0] = 1",
      "mutated_line": "b[0] = -1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = -1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N - 1] = 2",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 2\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N - 1] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 0\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N - 1] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 0\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N - 1] = -1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = -1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) * MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) + MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [0] / n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] / n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [0] + n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] + n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [0] ** n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] ** n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [0] / n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] / n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [0] + n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] + n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [0] ** n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] ** n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while x > 0:",
      "mutated_line": "while x >= 0:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x >= 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while x > 0:",
      "mutated_line": "while x <= 0:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x <= 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while x > 0:",
      "mutated_line": "while x != 0:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x != 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "a = [[0] * N for i in range(N)]",
      "mutated_line": "a = [[0] / N for i in range(N)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] / N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "a = [[0] * N for i in range(N)]",
      "mutated_line": "a = [[0] + N for i in range(N)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] + N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "a = [[0] * N for i in range(N)]",
      "mutated_line": "a = [[0] ** N for i in range(N)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] ** N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[0][1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][1] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[0][-1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][-1] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[0][1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][1] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 1][1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][1] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 1][-1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][-1] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 1][1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][1] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(2, N - 1):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(2, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(0, N - 1):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(0, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(0, N - 1):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(0, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(-1, N - 1):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(-1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N + 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N * 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i + 1] = 2",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 2\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i + 1] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 0\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i + 1] = 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 0\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i + 1] = -1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = -1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 1][N - di] += 2",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 2\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 1][N - di] += 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 0\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 1][N - di] += 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 0\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 1][N - di] += -1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += -1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "b[0] = 1",
      "mutated_line": "b[1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[1] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "b[0] = 1",
      "mutated_line": "b[-1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[-1] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "b[0] = 1",
      "mutated_line": "b[1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[1] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N + 1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N + 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N * 1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N * 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD",
      "mutated_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) * MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) * MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD",
      "mutated_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) + MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) + MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD",
      "mutated_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) * MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) * MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD",
      "mutated_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) + MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) + MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while x > 0:",
      "mutated_line": "while x > 1:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 1:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while x > 0:",
      "mutated_line": "while x > -1:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > -1:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while x > 0:",
      "mutated_line": "while x > 1:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 1:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if x & 1:",
      "mutated_line": "if x | 1:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x | 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "x >>= 1",
      "mutated_line": "x >>= 2",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 2\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "x >>= 1",
      "mutated_line": "x >>= 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 0\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "x >>= 1",
      "mutated_line": "x >>= 0",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 0\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "x >>= 1",
      "mutated_line": "x >>= -1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= -1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(3, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(3, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(1, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(0, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(1, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(-2, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(-2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[1][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[1][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[-1][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[-1][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[0][0] = 1",
      "mutated_line": "a[1][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[1][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N + 1][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N + 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N * 1][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N * 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(1, N - 2):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 2):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(1, N - 0):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 0):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(1, N - 0):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 0):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(1, N - 1):",
      "mutated_line": "for i in range(1, N - -1):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - -1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i - 1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i - 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i * 1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i * 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 1][N + di] += 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N + di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 1][N * di] += 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N * di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [1] * N",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [1] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [-1] * N",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [-1] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [1] * N",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [1] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N - 2] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 2] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N - 0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 0] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N - 0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 0] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "b[N - 1] = 1",
      "mutated_line": "b[N - -1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - -1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = len(a[0])",
      "mutated_line": "n = len(a[1])",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[1])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = len(a[0])",
      "mutated_line": "n = len(a[-1])",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[-1])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = len(a[0])",
      "mutated_line": "n = len(a[1])",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[1])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [1] * n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [1] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [-1] * n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [-1] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [1] * n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [1] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [1] * n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [1] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [-1] * n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [-1] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = [0] * n",
      "mutated_line": "c = [1] * n",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [1] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if a[i][j] != 0:",
      "mutated_line": "if a[i][j] == 0:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] == 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x & 1:",
      "mutated_line": "if x & 2:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 2:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x & 1:",
      "mutated_line": "if x & 0:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 0:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x & 1:",
      "mutated_line": "if x & 0:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 0:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x & 1:",
      "mutated_line": "if x & -1:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & -1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "aa = [[0] * n for i in range(n)]",
      "mutated_line": "aa = [[0] / n for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] / n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "aa = [[0] * n for i in range(n)]",
      "mutated_line": "aa = [[0] + n for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] + n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "aa = [[0] * n for i in range(n)]",
      "mutated_line": "aa = [[0] ** n for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] ** n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "aa[0] = a[0]",
      "mutated_line": "aa[1] = a[0]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[1] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "aa[0] = a[0]",
      "mutated_line": "aa[-1] = a[0]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[-1] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "aa[0] = a[0]",
      "mutated_line": "aa[1] = a[0]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[1] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "aa[0] = a[0]",
      "mutated_line": "aa[0] = a[1]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[1]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "aa[0] = a[0]",
      "mutated_line": "aa[0] = a[-1]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[-1]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "aa[0] = a[0]",
      "mutated_line": "aa[0] = a[1]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[1]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "aa[1] = mul_vec_mat(a[1], a)",
      "mutated_line": "aa[2] = mul_vec_mat(a[1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[2] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "aa[1] = mul_vec_mat(a[1], a)",
      "mutated_line": "aa[0] = mul_vec_mat(a[1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[0] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "aa[1] = mul_vec_mat(a[1], a)",
      "mutated_line": "aa[0] = mul_vec_mat(a[1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[0] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "aa[1] = mul_vec_mat(a[1], a)",
      "mutated_line": "aa[-1] = mul_vec_mat(a[1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[-1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(3, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(3, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(1, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(0, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(1, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(-2, n):",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(-2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "a = [[0] * N for i in range(N)]",
      "mutated_line": "a = [[1] * N for i in range(N)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[1] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "a = [[0] * N for i in range(N)]",
      "mutated_line": "a = [[-1] * N for i in range(N)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[-1] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "a = [[0] * N for i in range(N)]",
      "mutated_line": "a = [[1] * N for i in range(N)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[1] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 2][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 2][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 0][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 0][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - 0][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 0][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "a[N - 1][0] = 1",
      "mutated_line": "a[N - -1][0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - -1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i + 2] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 2] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i + 0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 0] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i + 0] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 0] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "a[i][i + 1] = 1",
      "mutated_line": "a[i][i + -1] = 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + -1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N + 1][N - di] += 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N + 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N * 1][N - di] += 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N * 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 1][i] * b[i] * MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] * MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 1][i] * b[i] + MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] + MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a[i][j] != 0:",
      "mutated_line": "if a[i][j] != 1:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 1:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a[i][j] != 0:",
      "mutated_line": "if a[i][j] != -1:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != -1:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a[i][j] != 0:",
      "mutated_line": "if a[i][j] != 1:",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 1:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "mutated_line": "r = [[1 if i != j else 0 for j in range(n)] for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i != j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "mutated_line": "r = [[2 if i == j else 0 for j in range(n)] for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[2 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "mutated_line": "r = [[0 if i == j else 0 for j in range(n)] for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[0 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "mutated_line": "r = [[0 if i == j else 0 for j in range(n)] for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[0 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "mutated_line": "r = [[-1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[-1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "mutated_line": "r = [[1 if i == j else 1 for j in range(n)] for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 1 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "mutated_line": "r = [[1 if i == j else -1 for j in range(n)] for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else -1 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
      "mutated_line": "r = [[1 if i == j else 1 for j in range(n)] for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 1 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r[1] = mul_vec_mat(r[1], a)",
      "mutated_line": "r[2] = mul_vec_mat(r[1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[2] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r[1] = mul_vec_mat(r[1], a)",
      "mutated_line": "r[0] = mul_vec_mat(r[1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[0] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r[1] = mul_vec_mat(r[1], a)",
      "mutated_line": "r[0] = mul_vec_mat(r[1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[0] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r[1] = mul_vec_mat(r[1], a)",
      "mutated_line": "r[-1] = mul_vec_mat(r[1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[-1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "aa[1] = mul_vec_mat(a[1], a)",
      "mutated_line": "aa[1] = mul_vec_mat(a[2], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[2], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "aa[1] = mul_vec_mat(a[1], a)",
      "mutated_line": "aa[1] = mul_vec_mat(a[0], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[0], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "aa[1] = mul_vec_mat(a[1], a)",
      "mutated_line": "aa[1] = mul_vec_mat(a[0], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[0], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "aa[1] = mul_vec_mat(a[1], a)",
      "mutated_line": "aa[1] = mul_vec_mat(a[-1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[-1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "r[i] = mul_vec_sparse_mat(r[i - 1], ta)",
      "mutated_line": "r[i] = mul_vec_sparse_mat(r[i + 1], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i + 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "r[i] = mul_vec_sparse_mat(r[i - 1], ta)",
      "mutated_line": "r[i] = mul_vec_sparse_mat(r[i * 1], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i * 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 2][N - di] += 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 2][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 0][N - di] += 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 0][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - 0][N - di] += 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 0][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "a[N - 1][N - di] += 1",
      "mutated_line": "a[N - -1][N - di] += 1",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - -1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 1][i] / b[i] % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] / b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum(((a[N - 1][i] + b[i]) % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum(((a[N - 1][i] + b[i]) % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 1][i] ** b[i] % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] ** b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD",
      "mutated_line": "c[i] = sum((a[j][i] * v[j] * MOD for j in range(m))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] * MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD",
      "mutated_line": "c[i] = sum((a[j][i] * v[j] + MOD for j in range(m))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] + MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD",
      "mutated_line": "c[i] = sum((x * v[j] * MOD for (j, x) in ta[i])) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] * MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD",
      "mutated_line": "c[i] = sum((x * v[j] + MOD for (j, x) in ta[i])) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] + MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r[1] = mul_vec_mat(r[1], a)",
      "mutated_line": "r[1] = mul_vec_mat(r[2], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[2], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r[1] = mul_vec_mat(r[1], a)",
      "mutated_line": "r[1] = mul_vec_mat(r[0], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[0], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r[1] = mul_vec_mat(r[1], a)",
      "mutated_line": "r[1] = mul_vec_mat(r[0], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[0], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r[1] = mul_vec_mat(r[1], a)",
      "mutated_line": "r[1] = mul_vec_mat(r[-1], a)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[-1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "aa = [[0] * n for i in range(n)]",
      "mutated_line": "aa = [[1] * n for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[1] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "aa = [[0] * n for i in range(n)]",
      "mutated_line": "aa = [[-1] * n for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[-1] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "aa = [[0] * n for i in range(n)]",
      "mutated_line": "aa = [[1] * n for i in range(n)]",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[1] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)",
      "mutated_line": "aa[i] = mul_vec_sparse_mat(aa[i + 1], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i + 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)",
      "mutated_line": "aa[i] = mul_vec_sparse_mat(aa[i * 1], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i * 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r[i] = mul_vec_sparse_mat(r[i - 1], ta)",
      "mutated_line": "r[i] = mul_vec_sparse_mat(r[i - 2], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 2], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r[i] = mul_vec_sparse_mat(r[i - 1], ta)",
      "mutated_line": "r[i] = mul_vec_sparse_mat(r[i - 0], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 0], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r[i] = mul_vec_sparse_mat(r[i - 1], ta)",
      "mutated_line": "r[i] = mul_vec_sparse_mat(r[i - 0], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 0], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r[i] = mul_vec_sparse_mat(r[i - 1], ta)",
      "mutated_line": "r[i] = mul_vec_sparse_mat(r[i - -1], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - -1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD",
      "mutated_line": "c[i] = sum((a[j][i] / v[j] % MOD for j in range(m))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] / v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD",
      "mutated_line": "c[i] = sum(((a[j][i] + v[j]) % MOD for j in range(m))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum(((a[j][i] + v[j]) % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD",
      "mutated_line": "c[i] = sum((a[j][i] ** v[j] % MOD for j in range(m))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] ** v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD",
      "mutated_line": "c[i] = sum((x / v[j] % MOD for (j, x) in ta[i])) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x / v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD",
      "mutated_line": "c[i] = sum(((x + v[j]) % MOD for (j, x) in ta[i])) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum(((x + v[j]) % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD",
      "mutated_line": "c[i] = sum((x ** v[j] % MOD for (j, x) in ta[i])) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x ** v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)",
      "mutated_line": "aa[i] = mul_vec_sparse_mat(aa[i - 2], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 2], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)",
      "mutated_line": "aa[i] = mul_vec_sparse_mat(aa[i - 0], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 0], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)",
      "mutated_line": "aa[i] = mul_vec_sparse_mat(aa[i - 0], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 0], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)",
      "mutated_line": "aa[i] = mul_vec_sparse_mat(aa[i - -1], ta)",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - -1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N + 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N + 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N * 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N * 1][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 2][i] * b[i] % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 2][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 0][i] * b[i] % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 0][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - 0][i] * b[i] % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - 0][i] * b[i] % MOD for i in range(N))) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return sum((a[N - 1][i] * b[i] % MOD for i in range(N))) % MOD",
      "mutated_line": "return sum((a[N - -1][i] * b[i] % MOD for i in range(N))) % MOD",
      "code": "def count_nodes_within_distance(n, x, d):\n    MOD = 1000000007\n    N = 101\n\n    def mul_vec_mat(v, a):\n        n = len(a[0])\n        m = len(v)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((a[j][i] * v[j] % MOD for j in range(m))) % MOD\n        return c\n\n    def mul_vec_sparse_mat(v, ta):\n        n = len(ta)\n        c = [0] * n\n        for i in range(n):\n            c[i] = sum((x * v[j] % MOD for (j, x) in ta[i])) % MOD\n        return c\n\n    def mod_pow_kitamasa(a, x):\n        n = len(a)\n        ta = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    ta[j].append((i, a[i][j]))\n        r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n        while x > 0:\n            if x & 1:\n                r[1] = mul_vec_mat(r[1], a)\n            aa = [[0] * n for i in range(n)]\n            aa[0] = a[0]\n            aa[1] = mul_vec_mat(a[1], a)\n            for i in range(2, n):\n                aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n            a = aa\n            x >>= 1\n        for i in range(2, n):\n            r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n        return r\n    a = [[0] * N for i in range(N)]\n    a[0][0] = 1\n    a[N - 1][0] = 1\n    for i in range(1, N - 1):\n        a[i][i + 1] = 1\n    for di in d:\n        a[N - 1][N - di] += 1\n    a = mod_pow_kitamasa(a, x)\n    b = [0] * N\n    b[0] = 1\n    b[N - 1] = 1\n    return sum((a[N - -1][i] * b[i] % MOD for i in range(N))) % MOD"
    }
  ]
}