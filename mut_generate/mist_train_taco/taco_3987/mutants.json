{
  "task_id": "taco_3987",
  "entry_point": "maximize_fixed_points",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "self.size[v] += self.size[u]",
      "mutated_line": "self.size[v] -= self.size[u]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] -= self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 1\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = -1\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 1\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.size = [1] * n",
      "mutated_line": "self.size = [1] / n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] / n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.size = [1] * n",
      "mutated_line": "self.size = [1] + n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] + n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.size = [1] * n",
      "mutated_line": "self.size = [1] ** n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] ** n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if self._par[v] == v:",
      "mutated_line": "if self._par[v] != v:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] != v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if u == v:",
      "mutated_line": "if u != v:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u != v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if self.size[u] > self.size[v]:",
      "mutated_line": "if self.size[u] >= self.size[v]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] >= self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if self.size[u] > self.size[v]:",
      "mutated_line": "if self.size[u] <= self.size[v]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] <= self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if self.size[u] > self.size[v]:",
      "mutated_line": "if self.size[u] != self.size[v]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] != self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return self.root(u) == self.root(v)",
      "mutated_line": "return self.root(u) != self.root(v)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) != self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return True\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x + 1, y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x + 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x * 1, y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x * 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 1, y + 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y + 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 1, y * 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y * 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if uf.is_connected(i, p[i] - 1):",
      "mutated_line": "if uf.is_connected(i, p[i] + 1):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] + 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if uf.is_connected(i, p[i] - 1):",
      "mutated_line": "if uf.is_connected(i, p[i] * 1):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] * 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.size = [1] * n",
      "mutated_line": "self.size = [2] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [2] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.size = [1] * n",
      "mutated_line": "self.size = [0] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [0] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.size = [1] * n",
      "mutated_line": "self.size = [0] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [0] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.size = [1] * n",
      "mutated_line": "self.size = [-1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [-1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 2, y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 2, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 0, y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 0, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 0, y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 0, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - -1, y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - -1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 1, y - 2)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 2)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 1, y - 0)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 0)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 1, y - 0)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 0)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "uf.unite(x - 1, y - 1)",
      "mutated_line": "uf.unite(x - 1, y - -1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - -1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 1):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if uf.is_connected(i, p[i] - 1):",
      "mutated_line": "if uf.is_connected(i, p[i] - 2):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 2):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if uf.is_connected(i, p[i] - 1):",
      "mutated_line": "if uf.is_connected(i, p[i] - 0):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 0):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if uf.is_connected(i, p[i] - 1):",
      "mutated_line": "if uf.is_connected(i, p[i] - 0):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - 0):\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if uf.is_connected(i, p[i] - 1):",
      "mutated_line": "if uf.is_connected(i, p[i] - -1):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n\n    def unite(self, u, v):\n        (u, v) = (self.root(u), self.root(v))\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            (u, v) = (v, u)\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\ndef maximize_fixed_points(n, m, p, pairs):\n    uf = UnionFind(n)\n    for (x, y) in pairs:\n        uf.unite(x - 1, y - 1)\n    ans = 0\n    for i in range(n):\n        if uf.is_connected(i, p[i] - -1):\n            ans += 1\n    return ans"
    }
  ]
}