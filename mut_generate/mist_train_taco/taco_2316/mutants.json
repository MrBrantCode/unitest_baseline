{
  "task_id": "taco_2316",
  "entry_point": "will_bfs_stop_within_finite_steps",
  "mutant_count": 92,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][0] = 1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 1\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][0] = -1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = -1\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][0] = 1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 1\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnts = [1, 0]",
      "mutated_line": "cnts = [2, 0]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [2, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnts = [1, 0]",
      "mutated_line": "cnts = [0, 0]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [0, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnts = [1, 0]",
      "mutated_line": "cnts = [0, 0]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [0, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnts = [1, 0]",
      "mutated_line": "cnts = [-1, 0]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [-1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnts = [1, 0]",
      "mutated_line": "cnts = [1, 1]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 1]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnts = [1, 0]",
      "mutated_line": "cnts = [1, -1]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, -1]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cnts = [1, 0]",
      "mutated_line": "cnts = [1, 1]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 1]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-1] / N for _ in range(2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] / N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-1] + N for _ in range(2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] + N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-1] ** N for _ in range(2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] ** N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][1] = 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][1] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][-1] = 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][-1] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][1] = 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][1] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "t1 = t ^ 1",
      "mutated_line": "t1 = t | 1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t | 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d1 = dist[t][v] + 1",
      "mutated_line": "d1 = dist[t][v] - 1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] - 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d1 = dist[t][v] + 1",
      "mutated_line": "d1 = dist[t][v] * 1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] * 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "cnts[t1] += 1",
      "mutated_line": "cnts[t1] -= 1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] -= 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v + 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v + 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v * 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v * 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u + 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u + 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u * 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u * 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[1][0] = 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[1][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[-1][0] = 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[-1][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[1][0] = 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[1][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t1 = t ^ 1",
      "mutated_line": "t1 = t ^ 2",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 2\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t1 = t ^ 1",
      "mutated_line": "t1 = t ^ 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 0\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t1 = t ^ 1",
      "mutated_line": "t1 = t ^ 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 0\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t1 = t ^ 1",
      "mutated_line": "t1 = t ^ -1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ -1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist1 = dist[t ^ 1]",
      "mutated_line": "dist1 = dist[t | 1]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t | 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d1 = dist[t][v] + 1",
      "mutated_line": "d1 = dist[t][v] + 2",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 2\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d1 = dist[t][v] + 1",
      "mutated_line": "d1 = dist[t][v] + 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 0\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d1 = dist[t][v] + 1",
      "mutated_line": "d1 = dist[t][v] + 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 0\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d1 = dist[t][v] + 1",
      "mutated_line": "d1 = dist[t][v] + -1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + -1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dist1[w] != -1:",
      "mutated_line": "if dist1[w] == -1:",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] == -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnts[t1] += 1",
      "mutated_line": "cnts[t1] += 2",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 2\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnts[t1] += 1",
      "mutated_line": "cnts[t1] += 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 0\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnts[t1] += 1",
      "mutated_line": "cnts[t1] += 0",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 0\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnts[t1] += 1",
      "mutated_line": "cnts[t1] += -1",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += -1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cnts[t1] == N:",
      "mutated_line": "if cnts[t1] != N:",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] != N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 2)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 2)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - -1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - -1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 2)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 2)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - -1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - -1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[+1] * N for _ in range(2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[+1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-1] * N for _ in range(3)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(3)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-1] * N for _ in range(1)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(1)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-1] * N for _ in range(0)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(0)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-1] * N for _ in range(1)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(1)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-1] * N for _ in range(-2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(-2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([(0, 0)])",
      "mutated_line": "que = deque([(1, 0)])",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(1, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([(0, 0)])",
      "mutated_line": "que = deque([(-1, 0)])",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(-1, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([(0, 0)])",
      "mutated_line": "que = deque([(1, 0)])",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(1, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([(0, 0)])",
      "mutated_line": "que = deque([(0, 1)])",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 1)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([(0, 0)])",
      "mutated_line": "que = deque([(0, -1)])",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, -1)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([(0, 0)])",
      "mutated_line": "que = deque([(0, 1)])",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 1)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist1 = dist[t ^ 1]",
      "mutated_line": "dist1 = dist[t ^ 2]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 2]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist1 = dist[t ^ 1]",
      "mutated_line": "dist1 = dist[t ^ 0]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 0]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist1 = dist[t ^ 1]",
      "mutated_line": "dist1 = dist[t ^ 0]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 0]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist1 = dist[t ^ 1]",
      "mutated_line": "dist1 = dist[t ^ -1]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ -1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "if dist1[w] != -1:",
      "mutated_line": "if dist1[w] != +1:",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != +1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u + 1].append(v - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u + 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u * 1].append(v - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u * 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v + 1].append(u - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v + 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v * 1].append(u - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v * 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-2] * N for _ in range(2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-2] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-0] * N for _ in range(2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-0] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[-0] * N for _ in range(2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-0] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1] * N for _ in range(2)]",
      "mutated_line": "dist = [[--1] * N for _ in range(2)]",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[--1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dist1[w] != -1:",
      "mutated_line": "if dist1[w] != -2:",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -2:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dist1[w] != -1:",
      "mutated_line": "if dist1[w] != -0:",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -0:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dist1[w] != -1:",
      "mutated_line": "if dist1[w] != -0:",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -0:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dist1[w] != -1:",
      "mutated_line": "if dist1[w] != --1:",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != --1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 2].append(v - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 2].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - -1].append(v - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - -1].append(v - 1)\n        G[v - 1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 2].append(u - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 2].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - -1].append(u - 1)",
      "code": "from collections import deque\n\ndef will_bfs_stop_within_finite_steps(N, M, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - -1].append(u - 1)\n    cnts = [1, 0]\n    dist = [[-1] * N for _ in range(2)]\n    dist[0][0] = 0\n    que = deque([(0, 0)])\n    while que:\n        (v, t) = que.popleft()\n        t1 = t ^ 1\n        dist1 = dist[t ^ 1]\n        d1 = dist[t][v] + 1\n        for w in G[v]:\n            if dist1[w] != -1:\n                continue\n            dist1[w] = d1\n            que.append((w, t1))\n            cnts[t1] += 1\n            if cnts[t1] == N:\n                return d1\n    return -1"
    }
  ]
}