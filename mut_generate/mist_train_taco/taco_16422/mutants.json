{
  "task_id": "taco_16422",
  "entry_point": "bfs_shortest_distances",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = 1",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 1\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = -1",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = -1\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = 1",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 1\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: +1 for i in range(1, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: +1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(2, n + 1):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(2, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(0, n + 1):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(0, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(0, n + 1):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(0, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(-1, n + 1):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(-1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n - 1):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n - 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n * 1):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n * 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if node != start_node:",
      "mutated_line": "if node == start_node:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node == start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -2 for i in range(1, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -2 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -0 for i in range(1, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -0 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -0 for i in range(1, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -0 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: --1 for i in range(1, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: --1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if distances[neighbor] == -1:  # Not visited",
      "mutated_line": "if distances[neighbor] != -1:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] != -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n + 2):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 2):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n + 0):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 0):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n + 0):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 0):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n + -1):",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + -1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if distances[node] == -1:",
      "mutated_line": "if distances[node] != -1:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] != -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(2, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(0, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(0, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(-1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n - 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n * 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(2, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(2, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(0, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(0, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(0, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(0, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(-1, n + 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(-1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(1, n - 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n - 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(1, n * 1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n * 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if distances[neighbor] == -1:  # Not visited",
      "mutated_line": "if distances[neighbor] == +1:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == +1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "distances[neighbor] = current_distance + 1",
      "mutated_line": "distances[neighbor] = current_distance - 1",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance - 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "distances[neighbor] = current_distance + 1",
      "mutated_line": "distances[neighbor] = current_distance * 1",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance * 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "if distances[node] == -1:",
      "mutated_line": "if distances[node] == +1:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == +1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 2)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 0)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 0)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + -1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(1, n + 2)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 2)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(1, n + 0)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 0)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(1, n + 0)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 0)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "distances = {i: -1 for i in range(1, n + 1)}",
      "mutated_line": "distances = {i: -1 for i in range(1, n + -1)}",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + -1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if distances[neighbor] == -1:  # Not visited",
      "mutated_line": "if distances[neighbor] == -2:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -2:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if distances[neighbor] == -1:  # Not visited",
      "mutated_line": "if distances[neighbor] == -0:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -0:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if distances[neighbor] == -1:  # Not visited",
      "mutated_line": "if distances[neighbor] == -0:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -0:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if distances[neighbor] == -1:  # Not visited",
      "mutated_line": "if distances[neighbor] == --1:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == --1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "distances[neighbor] = current_distance + 1",
      "mutated_line": "distances[neighbor] = current_distance + 2",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 2\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "distances[neighbor] = current_distance + 1",
      "mutated_line": "distances[neighbor] = current_distance + 0",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 0\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "distances[neighbor] = current_distance + 1",
      "mutated_line": "distances[neighbor] = current_distance + 0",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 0\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "distances[neighbor] = current_distance + 1",
      "mutated_line": "distances[neighbor] = current_distance + -1",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + -1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if distances[node] == -1:",
      "mutated_line": "if distances[node] == -2:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -2:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if distances[node] == -1:",
      "mutated_line": "if distances[node] == -0:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -0:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if distances[node] == -1:",
      "mutated_line": "if distances[node] == -0:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -0:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if distances[node] == -1:",
      "mutated_line": "if distances[node] == --1:",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == --1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "result.append(-1)",
      "mutated_line": "result.append(+1)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(+1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "result.append(distances[node] * 6)",
      "mutated_line": "result.append(distances[node] / 6)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] / 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "result.append(distances[node] * 6)",
      "mutated_line": "result.append(distances[node] + 6)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] + 6)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "result.append(distances[node] * 6)",
      "mutated_line": "result.append(distances[node] ** 6)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] ** 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result.append(-1)",
      "mutated_line": "result.append(-2)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-2)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result.append(-1)",
      "mutated_line": "result.append(-0)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-0)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result.append(-1)",
      "mutated_line": "result.append(-0)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-0)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result.append(-1)",
      "mutated_line": "result.append(--1)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(--1)\n            else:\n                result.append(distances[node] * 6)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result.append(distances[node] * 6)",
      "mutated_line": "result.append(distances[node] * 7)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 7)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result.append(distances[node] * 6)",
      "mutated_line": "result.append(distances[node] * 5)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 5)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result.append(distances[node] * 6)",
      "mutated_line": "result.append(distances[node] * 0)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result.append(distances[node] * 6)",
      "mutated_line": "result.append(distances[node] * 1)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result.append(distances[node] * 6)",
      "mutated_line": "result.append(distances[node] * -6)",
      "code": "def bfs_shortest_distances(n, m, edges, start_node):\n    from collections import deque\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    distances = {i: -1 for i in range(1, n + 1)}\n    queue = deque([start_node])\n    distances[start_node] = 0\n    while queue:\n        current_node = queue.popleft()\n        current_distance = distances[current_node]\n        for neighbor in adjacency_list[current_node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    result = []\n    for node in range(1, n + 1):\n        if node != start_node:\n            if distances[node] == -1:\n                result.append(-1)\n            else:\n                result.append(distances[node] * -6)\n    return result"
    }
  ]
}