{
  "task_id": "taco_10342",
  "entry_point": "calculate_distribution_ways",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return previous[n] % 1000000007",
      "mutated_line": "return previous[n] * 1000000007",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] * 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return previous[n] % 1000000007",
      "mutated_line": "return previous[n] + 1000000007",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] + 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cur_sum = 0",
      "mutated_line": "cur_sum = 1",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 1\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cur_sum = 0",
      "mutated_line": "cur_sum = -1",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = -1\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cur_sum = 0",
      "mutated_line": "cur_sum = 1",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 1\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sums = [0] * len(array)",
      "mutated_line": "sums = [0] / len(array)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] / len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sums = [0] * len(array)",
      "mutated_line": "sums = [0] + len(array)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] + len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sums = [0] * len(array)",
      "mutated_line": "sums = [0] ** len(array)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] ** len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "cur_sum += array[i]",
      "mutated_line": "cur_sum -= array[i]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum -= array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] / (n + 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] / (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] + (n + 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] + (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] ** (n + 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] ** (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return previous[n] % 1000000007",
      "mutated_line": "return previous[n] % 1000000008",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000008"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return previous[n] % 1000000007",
      "mutated_line": "return previous[n] % 1000000006",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000006"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return previous[n] % 1000000007",
      "mutated_line": "return previous[n] % 0",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return previous[n] % 1000000007",
      "mutated_line": "return previous[n] % 1",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return previous[n] % 1000000007",
      "mutated_line": "return previous[n] % -1000000007",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % -1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] < food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] < food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] > food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] > food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] == food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] == food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [2 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [2 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [0 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [0 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [0 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [0 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [-1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [-1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 1 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 1 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else -1 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else -1 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 1 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 1 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] * (n - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n - 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] * (n * 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n * 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(1, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(-1, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(1, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n - 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n * 1):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n * 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "interval_end = i - cook[0]",
      "mutated_line": "interval_end = i + cook[0]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i + cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "interval_end = i - cook[0]",
      "mutated_line": "interval_end = i * cook[0]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i * cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if interval_end < 0:",
      "mutated_line": "if interval_end <= 0:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end <= 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if interval_end < 0:",
      "mutated_line": "if interval_end >= 0:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end >= 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if interval_end < 0:",
      "mutated_line": "if interval_end != 0:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end != 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sums = [0] * len(array)",
      "mutated_line": "sums = [1] * len(array)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [1] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sums = [0] * len(array)",
      "mutated_line": "sums = [-1] * len(array)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [-1] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sums = [0] * len(array)",
      "mutated_line": "sums = [1] * len(array)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [1] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n - 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n - 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n * 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n * 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [1] * (n + 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [1] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [-1] * (n + 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [-1] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [1] * (n + 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [1] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] * (n + 2)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 2)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] * (n + 0)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 0)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] * (n + 0)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 0)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current = [0] * (n + 1)",
      "mutated_line": "current = [0] * (n + -1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + -1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 2):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 2):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 0):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 0):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 0):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 0):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + -1):",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + -1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(+1, i - cook[1] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(+1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[1] + 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] + 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, (i - cook[1]) * 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, (i - cook[1]) * 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if interval_end < 0:",
      "mutated_line": "if interval_end < 1:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 1:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if interval_end < 0:",
      "mutated_line": "if interval_end < -1:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < -1:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if interval_end < 0:",
      "mutated_line": "if interval_end < 1:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 1:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "current[i] = 0",
      "mutated_line": "current[i] = 1",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 1\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "current[i] = 0",
      "mutated_line": "current[i] = -1",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = -1\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "current[i] = 0",
      "mutated_line": "current[i] = 1",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 1\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif interval_start < 0:",
      "mutated_line": "elif interval_start <= 0:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start <= 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif interval_start < 0:",
      "mutated_line": "elif interval_start >= 0:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start >= 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif interval_start < 0:",
      "mutated_line": "elif interval_start != 0:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start != 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[1] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[1] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[-1] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[-1] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[1] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[1] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[2] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[2] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[0] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[0] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[0] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[0] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[-1] else 0 for food_count in range(n + 1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[-1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 2)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 2)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 0)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 0)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 0)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 0)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]",
      "mutated_line": "previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + -1)]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + -1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-2, i - cook[1] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-2, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-0, i - cook[1] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-0, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-0, i - cook[1] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-0, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(--1, i - cook[1] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(--1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i + cook[1] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i + cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i * cook[1] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i * cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[1] - 2)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 2)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[1] - 0)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 0)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[1] - 0)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 0)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[1] - -1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - -1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "interval_end = i - cook[0]",
      "mutated_line": "interval_end = i - cook[1]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[1]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "interval_end = i - cook[0]",
      "mutated_line": "interval_end = i - cook[-1]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[-1]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "interval_end = i - cook[0]",
      "mutated_line": "interval_end = i - cook[1]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[1]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif interval_start < 0:",
      "mutated_line": "elif interval_start < 1:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 1:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif interval_start < 0:",
      "mutated_line": "elif interval_start < -1:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < -1:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif interval_start < 0:",
      "mutated_line": "elif interval_start < 1:",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 1:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "current[i] = previous_sums[interval_end] - previous_sums[interval_start]",
      "mutated_line": "current[i] = previous_sums[interval_end] + previous_sums[interval_start]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] + previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "current[i] = previous_sums[interval_end] - previous_sums[interval_start]",
      "mutated_line": "current[i] = previous_sums[interval_end] * previous_sums[interval_start]",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] * previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[2] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[2] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[0] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[0] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[0] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[0] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "interval_start = max(-1, i - cook[1] - 1)",
      "mutated_line": "interval_start = max(-1, i - cook[-1] - 1)",
      "code": "def calculate_distribution_ways(n, m, cooks):\n\n    def generate_sums(array):\n        cur_sum = 0\n        sums = [0] * len(array)\n        for i in range(len(array)):\n            cur_sum += array[i]\n            sums[i] = cur_sum\n        return sums\n    cook = cooks.pop()\n    previous = [1 if cook[0] <= food_count <= cook[1] else 0 for food_count in range(n + 1)]\n    previous_sums = generate_sums(previous)\n    while cooks:\n        cook = cooks.pop()\n        current = [0] * (n + 1)\n        for i in range(0, n + 1):\n            interval_start = max(-1, i - cook[-1] - 1)\n            interval_end = i - cook[0]\n            if interval_end < 0:\n                current[i] = 0\n            elif interval_start < 0:\n                current[i] = previous_sums[interval_end]\n            else:\n                current[i] = previous_sums[interval_end] - previous_sums[interval_start]\n        previous = current\n        previous_sums = generate_sums(previous)\n    return previous[n] % 1000000007"
    }
  ]
}