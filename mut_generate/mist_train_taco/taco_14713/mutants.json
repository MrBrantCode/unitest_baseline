{
  "task_id": "taco_14713",
  "entry_point": "has_negative_weight_cycle",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n == 0 and len(edges) == 0:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 and len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance = [float('inf')] * n",
      "mutated_line": "distance = [float('inf')] / n",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] / n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance = [float('inf')] * n",
      "mutated_line": "distance = [float('inf')] + n",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] + n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distance = [float('inf')] * n",
      "mutated_line": "distance = [float('inf')] ** n",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] ** n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[0][0]] = 1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 1\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[0][0]] = -1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = -1\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[0][0]] = 1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 1\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n != 0 or len(edges) == 0:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n != 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n == 0 or len(edges) != 0:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) != 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 1\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return -1\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 1\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n + 1):",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n + 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n * 1):",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n * 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "return 0 if distance == next_distance else 1",
      "mutated_line": "return 0 if distance != next_distance else 1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance != next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0 if distance == next_distance else 1",
      "mutated_line": "return 1 if distance == next_distance else 1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 1 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0 if distance == next_distance else 1",
      "mutated_line": "return -1 if distance == next_distance else 1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return -1 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0 if distance == next_distance else 1",
      "mutated_line": "return 1 if distance == next_distance else 1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 1 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0 if distance == next_distance else 1",
      "mutated_line": "return 0 if distance == next_distance else 2",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0 if distance == next_distance else 1",
      "mutated_line": "return 0 if distance == next_distance else 0",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0 if distance == next_distance else 1",
      "mutated_line": "return 0 if distance == next_distance else 0",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 0 if distance == next_distance else 1",
      "mutated_line": "return 0 if distance == next_distance else -1",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n == 1 or len(edges) == 0:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 1 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n == -1 or len(edges) == 0:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == -1 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n == 1 or len(edges) == 0:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 1 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n == 0 or len(edges) == 1:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 1:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n == 0 or len(edges) == -1:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == -1:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 or len(edges) == 0:",
      "mutated_line": "if n == 0 or len(edges) == 1:",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 1:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[0][1]] = 0",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][1]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[0][-1]] = 0",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][-1]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[0][1]] = 0",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][1]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n - 2):",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 2):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n - 0):",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 0):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n - 0):",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 0):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n - -1):",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - -1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distance = [float('inf')] * n",
      "mutated_line": "distance = [float('')] * n",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[1][0]] = 0",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[1][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[-1][0]] = 0",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[-1][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distance[edges[0][0]] = 0",
      "mutated_line": "distance[edges[1][0]] = 0",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[1][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] + weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distance[end] = min(distance[end], distance[start] + weight)",
      "mutated_line": "distance[end] = min(distance[end], distance[start] - weight)",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] - weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distance[end] = min(distance[end], distance[start] + weight)",
      "mutated_line": "distance[end] = min(distance[end], distance[start] * weight)",
      "code": "def has_negative_weight_cycle(n, edges):\n    if n == 0 or len(edges) == 0:\n        return 0\n    distance = [float('inf')] * n\n    distance[edges[0][0]] = 0\n\n    def one_traversal():\n        for edge in edges:\n            (start, end, weight) = edge\n            distance[end] = min(distance[end], distance[start] * weight)\n    for _ in range(n - 1):\n        one_traversal()\n    next_distance = distance[:]\n    one_traversal()\n    return 0 if distance == next_distance else 1"
    }
  ]
}