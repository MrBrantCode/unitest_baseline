{
  "task_id": "taco_2870",
  "entry_point": "check",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "MOD = 1000000008\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "MOD = 1000000006\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "MOD = -1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if pos == kk and val != ss:",
      "mutated_line": "if pos == kk or val != ss:",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk or val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if pos == tt and val != pp:",
      "mutated_line": "if pos == tt or val != pp:",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt or val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return False\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if pos == kk and val != ss:",
      "mutated_line": "if pos != kk and val != ss:",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos != kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if pos == kk and val != ss:",
      "mutated_line": "if pos == kk and val == ss:",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val == ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return True\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if pos == tt and val != pp:",
      "mutated_line": "if pos != tt and val != pp:",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos != tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if pos == tt and val != pp:",
      "mutated_line": "if pos == tt and val == pp:",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val == pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return True\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(3, n, 1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(3, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(1, n, 1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(1, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(0, n, 1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(0, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(1, n, 1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(1, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(-2, n, 1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(-2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(2, n, 2):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 2):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(2, n, 0):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 0):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(2, n, 0):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 0):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for idx in range(2, n, 1):",
      "mutated_line": "for idx in range(2, n, -1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, -1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for idx in range(n, 0, -1):",
      "mutated_line": "for idx in range(n, 1, -1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 1, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for idx in range(n, 0, -1):",
      "mutated_line": "for idx in range(n, -1, -1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, -1, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for idx in range(n, 0, -1):",
      "mutated_line": "for idx in range(n, 1, -1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 1, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for idx in range(n, 0, -1):",
      "mutated_line": "for idx in range(n, 0, +1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, +1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[1 for _ in range(n + 2)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[1 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 2)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[-1 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[1 for _ in range(n + 2)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[1 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[idx][idx] = 1",
      "mutated_line": "dp[idx][idx] = 2",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 2\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[idx][idx] = 1",
      "mutated_line": "dp[idx][idx] = 0",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 0\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[idx][idx] = 1",
      "mutated_line": "dp[idx][idx] = 0",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 0\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[idx][idx] = 1",
      "mutated_line": "dp[idx][idx] = -1",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = -1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for idx in range(n, 0, -1):",
      "mutated_line": "for idx in range(n, 0, -2):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -2):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for idx in range(n, 0, -1):",
      "mutated_line": "for idx in range(n, 0, -0):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -0):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for idx in range(n, 0, -1):",
      "mutated_line": "for idx in range(n, 0, -0):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -0):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for idx in range(n, 0, -1):",
      "mutated_line": "for idx in range(n, 0, --1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, --1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for jdx in range(idx, n + 1):",
      "mutated_line": "for jdx in range(idx, n - 1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n - 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for jdx in range(idx, n + 1):",
      "mutated_line": "for jdx in range(idx, n * 1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n * 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n + (jdx - idx + 1)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n + (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n * (jdx - idx + 1)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n * (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[1][n]",
      "mutated_line": "return dp[2][n]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[2][n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[1][n]",
      "mutated_line": "return dp[0][n]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[0][n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[1][n]",
      "mutated_line": "return dp[0][n]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[0][n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[1][n]",
      "mutated_line": "return dp[-1][n]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[-1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n - 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n - 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n * 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n * 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for jdx in range(idx, n + 1):",
      "mutated_line": "for jdx in range(idx, n + 2):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 2):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for jdx in range(idx, n + 1):",
      "mutated_line": "for jdx in range(idx, n + 0):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 0):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for jdx in range(idx, n + 1):",
      "mutated_line": "for jdx in range(idx, n + 0):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 0):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for jdx in range(idx, n + 1):",
      "mutated_line": "for jdx in range(idx, n + -1):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + -1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n - (jdx - idx - 1)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx - 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n - (jdx - idx) * 1",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx) * 1\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if check(idx - 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(idx + 1, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx + 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if check(idx - 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(idx * 1, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx * 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) * MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) * MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = dp[idx - 1][jdx] + dp[idx][jdx] + MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = dp[idx - 1][jdx] + dp[idx][jdx] + MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if check(jdx + 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(jdx - 1, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx - 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if check(jdx + 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(jdx * 1, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx * 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) * MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) * MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = dp[idx][jdx + 1] + dp[idx][jdx] + MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = dp[idx][jdx + 1] + dp[idx][jdx] + MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n - 2)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n - 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n * 2)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n * 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 3)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 3)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 1)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 1)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 0)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 0)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 1)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 1)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + -2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + -2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n - (jdx + idx + 1)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx + idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n - (jdx * idx + 1)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx * idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n - (jdx - idx + 2)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 2)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n - (jdx - idx + 0)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 0)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n - (jdx - idx + 0)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 0)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "val = n - (jdx - idx + 1)",
      "mutated_line": "val = n - (jdx - idx + -1)",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + -1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if check(idx - 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(idx - 2, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 2, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if check(idx - 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(idx - 0, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 0, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if check(idx - 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(idx - 0, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 0, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if check(idx - 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(idx - -1, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - -1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] - dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] - dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = dp[idx - 1][jdx] * dp[idx][jdx] % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = dp[idx - 1][jdx] * dp[idx][jdx] % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if check(jdx + 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(jdx + 2, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 2, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if check(jdx + 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(jdx + 0, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 0, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if check(jdx + 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(jdx + 0, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 0, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if check(jdx + 1, val, kk, tt, ss, pp):",
      "mutated_line": "if check(jdx + -1, val, kk, tt, ss, pp):",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + -1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx - 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx - 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx * 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx * 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] - dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] - dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = dp[idx][jdx + 1] * dp[idx][jdx] % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = dp[idx][jdx + 1] * dp[idx][jdx] % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 3)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 3)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 1)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 1)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 0)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 0)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + 1)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 1)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]",
      "mutated_line": "dp = [[0 for _ in range(n + -2)] for _ in range(n + 2)]",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + -2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx + 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx + 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx * 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx * 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 2] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 2] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 0] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 0] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 0] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 0] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + -1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + -1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 2][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 2][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 0][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 0][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 0][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 0][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - -1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - -1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = (dp[idx][jdx - 1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx - 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = (dp[idx][jdx * 1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx * 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = (dp[idx + 1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx + 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = (dp[idx * 1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx * 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 2] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 2] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 0] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 0] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 0] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 0] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx][jdx + 1] = (dp[idx][jdx + -1] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + -1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = (dp[idx - 2][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 2][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = (dp[idx - 0][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 0][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = (dp[idx - 0][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - 0][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[idx - 1][jdx] = (dp[idx - 1][jdx] + dp[idx][jdx]) % MOD",
      "mutated_line": "dp[idx - 1][jdx] = (dp[idx - -1][jdx] + dp[idx][jdx]) % MOD",
      "code": "MOD = 1000000007\n\ndef check(pos, val, kk, tt, ss, pp):\n    if pos == kk and val != ss:\n        return False\n    if pos == tt and val != pp:\n        return False\n    return True\n\ndef count_bitonic_permutations(n, i, j, x, y):\n    (kk, tt, ss, pp) = (i, j, x, y)\n    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n    for idx in range(2, n, 1):\n        if check(idx, n, kk, tt, ss, pp):\n            dp[idx][idx] = 1\n    for idx in range(n, 0, -1):\n        for jdx in range(idx, n + 1):\n            val = n - (jdx - idx + 1)\n            if check(idx - 1, val, kk, tt, ss, pp):\n                dp[idx - 1][jdx] = (dp[idx - -1][jdx] + dp[idx][jdx]) % MOD\n            if check(jdx + 1, val, kk, tt, ss, pp):\n                dp[idx][jdx + 1] = (dp[idx][jdx + 1] + dp[idx][jdx]) % MOD\n    return dp[1][n]"
    }
  ]
}