{
  "task_id": "taco_5865",
  "entry_point": "recover_original_array",
  "mutant_count": 91,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "def solve_helper(n, m, db, start=True):",
      "mutated_line": "",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=False):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "found_candidate = -1",
      "mutated_line": "found_candidate = +1",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = +1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_diffs = 0",
      "mutated_line": "max_diffs = 1",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 1\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_diffs = 0",
      "mutated_line": "max_diffs = -1",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = -1\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_diffs = 0",
      "mutated_line": "max_diffs = 1",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 1\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if found_candidate == -1:",
      "mutated_line": "if found_candidate != -1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate != -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "found_candidate = -1",
      "mutated_line": "found_candidate = -2",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -2\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "found_candidate = -1",
      "mutated_line": "found_candidate = -0",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -0\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "found_candidate = -1",
      "mutated_line": "found_candidate = -0",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -0\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "found_candidate = -1",
      "mutated_line": "found_candidate = --1",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = --1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(2, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(0, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(0, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(-1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if ldiff > 4:",
      "mutated_line": "if ldiff >= 4:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff >= 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if ldiff > 4:",
      "mutated_line": "if ldiff <= 4:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff <= 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if ldiff > 4:",
      "mutated_line": "if ldiff != 4:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff != 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if ldiff < 3:",
      "mutated_line": "if ldiff <= 3:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff <= 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if ldiff < 3:",
      "mutated_line": "if ldiff >= 3:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff >= 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if ldiff < 3:",
      "mutated_line": "if ldiff != 3:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff != 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ldiff > max_diffs:",
      "mutated_line": "if ldiff >= max_diffs:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff >= max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ldiff > max_diffs:",
      "mutated_line": "if ldiff <= max_diffs:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff <= max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ldiff > max_diffs:",
      "mutated_line": "if ldiff != max_diffs:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff != max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if found_candidate == -1:",
      "mutated_line": "if found_candidate == +1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == +1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(2, 1 + (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(2, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(0, 1 + (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(0, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(0, 1 + (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(0, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(-1, 1 + (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(-1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 1 - (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 - (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 1 * (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 * (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return 'No', []",
      "mutated_line": "return ('', [])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if ldiff > 4:",
      "mutated_line": "if ldiff > 5:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 5:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if ldiff > 4:",
      "mutated_line": "if ldiff > 3:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 3:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if ldiff > 4:",
      "mutated_line": "if ldiff > 0:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 0:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if ldiff > 4:",
      "mutated_line": "if ldiff > 1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 1:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if ldiff > 4:",
      "mutated_line": "if ldiff > -4:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > -4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if ldiff < 3:",
      "mutated_line": "if ldiff < 4:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 4:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if ldiff < 3:",
      "mutated_line": "if ldiff < 2:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 2:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if ldiff < 3:",
      "mutated_line": "if ldiff < 0:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 0:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if ldiff < 3:",
      "mutated_line": "if ldiff < 1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 1:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if ldiff < 3:",
      "mutated_line": "if ldiff < -3:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < -3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if found_candidate == -1:",
      "mutated_line": "if found_candidate == -2:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -2:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if found_candidate == -1:",
      "mutated_line": "if found_candidate == -0:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -0:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if found_candidate == -1:",
      "mutated_line": "if found_candidate == -0:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -0:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if found_candidate == -1:",
      "mutated_line": "if found_candidate == --1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == --1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'Yes', db[0]",
      "mutated_line": "return ('', db[0])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 2 + (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 2 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 0 + (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 0 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 0 + (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 0 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, -1 + (1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, -1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if attempt >> i & 1:",
      "mutated_line": "if attempt >> i | 1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i | 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(cdiffs) > 2:",
      "mutated_line": "if len(cdiffs) >= 2:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) >= 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(cdiffs) > 2:",
      "mutated_line": "if len(cdiffs) <= 2:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) <= 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(cdiffs) > 2:",
      "mutated_line": "if len(cdiffs) != 2:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) != 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return solve_helper(n, m, db, False)",
      "mutated_line": "return solve_helper(n, m, db, True)",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, True)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "diffs = [j for j in range(m) if db[i][j] != db[0][j]]",
      "mutated_line": "diffs = [j for j in range(m) if db[i][j] == db[0][j]]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] == db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 'No', []",
      "mutated_line": "return ('', [])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'Yes', db[0]",
      "mutated_line": "return ('Yes', db[1])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[1])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'Yes', db[0]",
      "mutated_line": "return ('Yes', db[-1])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[-1])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'Yes', db[0]",
      "mutated_line": "return ('Yes', db[1])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[1])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]",
      "mutated_line": "diffs = [j for j in range(m) if db[found_candidate][j] == db[0][j]][:]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] == db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 1 + (2 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (2 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 1 + (0 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (0 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 1 + (0 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (0 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for attempt in range(1, 1 + (1 << len(diffs))):",
      "mutated_line": "for attempt in range(1, 1 + (-1 << len(diffs))):",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (-1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current = db[0][:]",
      "mutated_line": "current = db[1][:]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[1][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current = db[0][:]",
      "mutated_line": "current = db[-1][:]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[-1][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current = db[0][:]",
      "mutated_line": "current = db[1][:]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[1][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if attempt >> i & 1:",
      "mutated_line": "if attempt >> i & 2:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 2:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if attempt >> i & 1:",
      "mutated_line": "if attempt >> i & 0:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 0:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if attempt >> i & 1:",
      "mutated_line": "if attempt >> i & 0:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 0:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if attempt >> i & 1:",
      "mutated_line": "if attempt >> i & -1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & -1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(cdiffs) > 2:",
      "mutated_line": "if len(cdiffs) > 3:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 3:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(cdiffs) > 2:",
      "mutated_line": "if len(cdiffs) > 1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 1:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(cdiffs) > 2:",
      "mutated_line": "if len(cdiffs) > 0:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 0:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(cdiffs) > 2:",
      "mutated_line": "if len(cdiffs) > 1:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 1:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(cdiffs) > 2:",
      "mutated_line": "if len(cdiffs) > -2:",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > -2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 'Yes', current",
      "mutated_line": "return ('', current)",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[0])",
      "mutated_line": "(db[1], db[found_candidate]) = (db[found_candidate], db[0])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[1], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[0])",
      "mutated_line": "(db[-1], db[found_candidate]) = (db[found_candidate], db[0])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[-1], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[0])",
      "mutated_line": "(db[1], db[found_candidate]) = (db[found_candidate], db[0])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[1], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[0])",
      "mutated_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[1])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[1])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[0])",
      "mutated_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[-1])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[-1])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[0])",
      "mutated_line": "(db[0], db[found_candidate]) = (db[found_candidate], db[1])",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[1])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "cdiffs = [j for j in range(m) if db[i][j] != current[j]]",
      "mutated_line": "cdiffs = [j for j in range(m) if db[i][j] == current[j]]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] == current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "diffs = [j for j in range(m) if db[i][j] != db[0][j]]",
      "mutated_line": "diffs = [j for j in range(m) if db[i][j] != db[1][j]]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[1][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "diffs = [j for j in range(m) if db[i][j] != db[0][j]]",
      "mutated_line": "diffs = [j for j in range(m) if db[i][j] != db[-1][j]]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[-1][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "diffs = [j for j in range(m) if db[i][j] != db[0][j]]",
      "mutated_line": "diffs = [j for j in range(m) if db[i][j] != db[1][j]]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[1][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]",
      "mutated_line": "diffs = [j for j in range(m) if db[found_candidate][j] != db[1][j]][:]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[1][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]",
      "mutated_line": "diffs = [j for j in range(m) if db[found_candidate][j] != db[-1][j]][:]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[-1][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "diffs = [j for j in range(m) if db[found_candidate][j] != db[0][j]][:]",
      "mutated_line": "diffs = [j for j in range(m) if db[found_candidate][j] != db[1][j]][:]",
      "code": "def recover_original_array(n, m, db):\n\n    def solve_helper(n, m, db, start=True):\n        found_candidate = -1\n        max_diffs = 0\n        for i in range(1, n):\n            diffs = [j for j in range(m) if db[i][j] != db[0][j]]\n            ldiff = len(diffs)\n            if ldiff > 4:\n                return ('No', [])\n            if ldiff < 3:\n                continue\n            if ldiff > max_diffs:\n                found_candidate = i\n                max_diffs = ldiff\n        if found_candidate == -1:\n            return ('Yes', db[0])\n        diffs = [j for j in range(m) if db[found_candidate][j] != db[1][j]][:]\n        for attempt in range(1, 1 + (1 << len(diffs))):\n            current = db[0][:]\n            for i in range(len(diffs)):\n                if attempt >> i & 1:\n                    current[diffs[i]] = db[found_candidate][diffs[i]]\n            for i in range(n):\n                cdiffs = [j for j in range(m) if db[i][j] != current[j]]\n                if len(cdiffs) > 2:\n                    break\n            else:\n                return ('Yes', current)\n        if start:\n            (db[0], db[found_candidate]) = (db[found_candidate], db[0])\n            return solve_helper(n, m, db, False)\n        return ('No', [])\n    return solve_helper(n, m, db)"
    }
  ]
}