{
  "task_id": "taco_7504",
  "entry_point": "dist",
  "mutant_count": 157,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 and b_dist[0][0] > 0 and (n == 1):",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 and b_dist[0][0] > 0 and (n == 1):\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "min_total_distance = k + S",
      "mutated_line": "min_total_distance = k - S",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k - S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "min_total_distance = k + S",
      "mutated_line": "min_total_distance = k * S",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k * S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] + v[0], u[1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] + v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] * v[0], u[1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] * v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[1] + v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] + v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[1] * v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] * v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] >= 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] >= 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] <= 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] <= 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] != 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] != 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] >= 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] >= 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] <= 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] <= 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] != 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] != 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n != 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n != 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][1] != b_dist[0][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] != b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "S = sum((2 * dist(t, bottle) for bottle in bottles))",
      "mutated_line": "S = sum((2 / dist(t, bottle) for bottle in bottles))",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 / dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "S = sum((2 * dist(t, bottle) for bottle in bottles))",
      "mutated_line": "S = sum((2 + dist(t, bottle) for bottle in bottles))",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 + dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "S = sum((2 * dist(t, bottle) for bottle in bottles))",
      "mutated_line": "S = sum((2 ** dist(t, bottle) for bottle in bottles))",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 ** dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]",
      "mutated_line": "a_dist = [(dist(a, bottle) + dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) + dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]",
      "mutated_line": "a_dist = [(dist(a, bottle) * dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) * dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]",
      "mutated_line": "b_dist = [(dist(b, bottle) + dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) + dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]",
      "mutated_line": "b_dist = [(dist(b, bottle) * dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) * dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 1 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 1 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > -1 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > -1 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 1 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 1 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 1 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 1 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] > -1 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > -1 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 1 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 1 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 2:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 2:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 0:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 0:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 0:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 0:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == -1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == -1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[1] - v[0], u[1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[1] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[-1] - v[0], u[1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[-1] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[1] - v[0], u[1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[1] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[1], u[1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[1], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[-1], u[1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[-1], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[1], u[1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[1], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[2] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[2] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[0] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[0] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[0] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[0] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[-1] - v[1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[-1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[1] - v[2])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[2])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[1] - v[0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[0])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[1] - v[0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[0])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.hypot(u[0] - v[0], u[1] - v[1])",
      "mutated_line": "return math.hypot(u[0] - v[0], u[1] - v[-1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[-1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S = sum((2 * dist(t, bottle) for bottle in bottles))",
      "mutated_line": "S = sum((3 * dist(t, bottle) for bottle in bottles))",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((3 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S = sum((2 * dist(t, bottle) for bottle in bottles))",
      "mutated_line": "S = sum((1 * dist(t, bottle) for bottle in bottles))",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((1 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S = sum((2 * dist(t, bottle) for bottle in bottles))",
      "mutated_line": "S = sum((0 * dist(t, bottle) for bottle in bottles))",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((0 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S = sum((2 * dist(t, bottle) for bottle in bottles))",
      "mutated_line": "S = sum((1 * dist(t, bottle) for bottle in bottles))",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((1 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "S = sum((2 * dist(t, bottle) for bottle in bottles))",
      "mutated_line": "S = sum((-2 * dist(t, bottle) for bottle in bottles))",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((-2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][1] > 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][1] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][-1] > 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][-1] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][1] > 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][1] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][1] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][1] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][-1] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][-1] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[0][1] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][1] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][1], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][-1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][-1], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][1], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0], b_dist[0][1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][1])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0], b_dist[0][-1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][-1])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0], b_dist[0][1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][1])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][2] == b_dist[0][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][2] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][0] == b_dist[0][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][0] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][0] == b_dist[0][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][0] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][-1] == b_dist[0][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][-1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][1] == b_dist[0][2]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][2]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][1] == b_dist[0][0]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][0]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][1] == b_dist[0][0]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][0]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][1] == b_dist[0][-1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][-1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] - b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] - b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] * b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] * b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] - b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] - b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] * b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] * b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] - b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] - b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] * b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] * b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[1][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[1][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[-1][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[-1][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[1][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[1][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[1][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[1][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[-1][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[-1][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:",
      "mutated_line": "if a_dist[0][0] > 0 or b_dist[1][0] > 0 or n == 1:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[1][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[1][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[-1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[-1][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[1][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0], b_dist[1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[1][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0], b_dist[-1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[-1][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = min(a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0], b_dist[1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[1][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[1][1] == b_dist[0][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[1][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[-1][1] == b_dist[0][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[-1][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[1][1] == b_dist[0][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[1][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][1] == b_dist[1][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[1][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][1] == b_dist[-1][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[-1][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif a_dist[0][1] == b_dist[0][1]:",
      "mutated_line": "elif a_dist[0][1] == b_dist[1][1]:",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[1][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][1], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][-1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][-1], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][1], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][1])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][-1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][-1])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][1])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][1], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][-1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][-1], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][1], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][1], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][1])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][-1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][-1])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][1])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][1])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][1] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][1] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][-1] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][-1] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][1] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][1] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][1], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][1], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][-1], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][-1], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][1], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][1], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][1] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][1] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][-1] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][-1] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][1] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][1] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][1], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][1], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][-1], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][-1], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][1], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][1], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[1][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[-1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[-1][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[1][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[1][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[-1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[-1][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[1][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][1] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][1] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][-1] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][-1] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][1] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][1] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][1], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][1], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][-1], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][-1], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][1], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][1], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[1][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[-1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[-1][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[1][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[1][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[1][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[-1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[-1][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[1][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[1][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[2][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[2][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[-1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[-1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[1][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[1][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[-1][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[-1][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[1][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[1][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[1][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[1][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[-1][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[-1][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[1][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[1][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[2][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[2][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[-1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[-1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[-1][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[-1][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[-1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[-1][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "k = min(a_dist[0][0] + b_dist[0][0], a_dist[0][0], b_dist[0][0])",
      "mutated_line": "k = min(a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])",
      "code": "import math\n\ndef dist(u, v):\n    return math.hypot(u[0] - v[0], u[1] - v[1])\n\ndef calculate_minimum_total_distance(a_pos, b_pos, t_pos, bottles):\n    a = a_pos\n    b = b_pos\n    t = t_pos\n    n = len(bottles)\n    S = sum((2 * dist(t, bottle) for bottle in bottles))\n    a_dist = [(dist(a, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    b_dist = [(dist(b, bottle) - dist(t, bottle), i) for (i, bottle) in enumerate(bottles)]\n    a_dist.sort()\n    b_dist.sort()\n    if a_dist[0][0] > 0 or b_dist[0][0] > 0 or n == 1:\n        k = min(a_dist[0][0], b_dist[0][0])\n    elif a_dist[0][1] == b_dist[0][1]:\n        k = min(a_dist[1][0] + b_dist[0][0], a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    else:\n        k = min(a_dist[0][0] + b_dist[1][0], a_dist[0][0], b_dist[0][0])\n    min_total_distance = k + S\n    return min_total_distance"
    }
  ]
}