{
  "task_id": "taco_8603",
  "entry_point": "is_perfect_cube",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 3))) ** 3 != x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 != x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "for i in range(n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 1\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "for i in range(n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = -1\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "for i in range(n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 1\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 3))) * 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) * 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 3))) + 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) + 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sum_val = 0",
      "mutated_line": "sum_val = 1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 1\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sum_val = 0",
      "mutated_line": "sum_val = -1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = -1\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sum_val = 0",
      "mutated_line": "sum_val = 1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 1\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "sum_val += x",
      "mutated_line": "sum_val -= x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val -= x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(n-k+1):",
      "mutated_line": "for i in range(n - k - 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k - 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(n-k+1):",
      "mutated_line": "for i in range((n - k) * 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range((n - k) * 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 1\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = -1\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 1\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "c += mat[z][i]",
      "mutated_line": "c -= mat[z][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c -= mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count -= 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 3))) ** 4 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 4 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 3))) ** 2 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 2 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 3))) ** 0 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 0 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 3))) ** 1 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 1 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 3))) ** -3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** -3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prev = l[0]",
      "mutated_line": "prev = l[1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[1]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prev = l[0]",
      "mutated_line": "prev = l[-1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[-1]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prev = l[0]",
      "mutated_line": "prev = l[1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[1]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l[0] = sum_val",
      "mutated_line": "l[1] = sum_val",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[1] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l[0] = sum_val",
      "mutated_line": "l[-1] = sum_val",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[-1] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l[0] = sum_val",
      "mutated_line": "l[1] = sum_val",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[1] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(2, n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(2, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(0, n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(0, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(0, n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(0, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(-1, n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(-1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k - 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k - 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, (n - k) * 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, (n - k) * 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev - l[j + k - 1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev - l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = (sum_val - prev) * l[j + k - 1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = (sum_val - prev) * l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(n-k+1):",
      "mutated_line": "for i in range(n + k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n + k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(n-k+1):",
      "mutated_line": "for i in range(n * k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n * k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(n-k+1):",
      "mutated_line": "for i in range(n - k + 2):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 2):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(n-k+1):",
      "mutated_line": "for i in range(n - k + 0):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 0):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(n-k+1):",
      "mutated_line": "for i in range(n - k + 0):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 0):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(n-k+1):",
      "mutated_line": "for i in range(n - k + -1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + -1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for z in range(0, k):",
      "mutated_line": "for z in range(1, k):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(1, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for z in range(0, k):",
      "mutated_line": "for z in range(-1, k):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(-1, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for z in range(0, k):",
      "mutated_line": "for z in range(1, k):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(1, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 2\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 0\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 0\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += -1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(2, n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(2, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(0, n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(0, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(0, n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(0, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(-1, n - k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(-1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k - 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k - 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, (n - k) * 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, (n - k) * 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] - mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] - mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = (c - mat[j - 1][i]) * mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = (c - mat[j - 1][i]) * mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count -= 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in l[0:k]:",
      "mutated_line": "for x in l[1:k]:",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[1:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in l[0:k]:",
      "mutated_line": "for x in l[-1:k]:",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[-1:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in l[0:k]:",
      "mutated_line": "for x in l[1:k]:",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[1:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n + k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n + k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n * k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n * k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k + 2):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 2):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k + 0):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 0):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k + 0):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 0):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k + -1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + -1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val + prev + l[j + k - 1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val + prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val * prev + l[j + k - 1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val * prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n + k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n + k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n * k + 1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n * k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k + 2):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 2):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k + 0):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 0):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k + 0):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 0):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(1, n-k+1):",
      "mutated_line": "for j in range(1, n - k + -1):",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + -1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c + mat[j - 1][i] + mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c + mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c * mat[j - 1][i] + mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c * mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 2\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += -1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x * (1.0 / 3))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x * (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x + 1.0 / 3)) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x + 1.0 / 3)) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev + l[j + k + 1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k + 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev + l[(j + k) * 1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[(j + k) * 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 * 3))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 * 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 // 3))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 // 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev + l[j - k - 1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j - k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev + l[j * k - 1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j * k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev + l[j + k - 2]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 2]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev + l[j + k - 0]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 0]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev + l[j + k - 0]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 0]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sum_val = sum_val - prev + l[j+k-1]",
      "mutated_line": "sum_val = sum_val - prev + l[j + k - -1]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - -1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] + mat[j + k + 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k + 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] + mat[(j + k) * 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[(j + k) * 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (2.0 / 3))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (2.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (0.0 / 3))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (0.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (0 / 3))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (-1.0 / 3))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (-1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 4))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 4))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 2))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 2))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 0))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 0))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / 1))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 1))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return int(round(x ** (1. / 3))) ** 3 == x",
      "mutated_line": "return int(round(x ** (1.0 / -3))) ** 3 == x",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / -3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j + 1][i] + mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j + 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j * 1][i] + mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j * 1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] + mat[j - k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j - k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] + mat[j * k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j * k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] + mat[j + k - 2][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 2][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] + mat[j + k - 0][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 0][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] + mat[j + k - 0][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - 0][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 1][i] + mat[j + k - -1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 1][i] + mat[j + k - -1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 2][i] + mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 2][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 0][i] + mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 0][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - 0][i] + mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - 0][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "c = c - mat[j-1][i] + mat[j+k-1][i]",
      "mutated_line": "c = c - mat[j - -1][i] + mat[j + k - 1][i]",
      "code": "def is_perfect_cube(x):\n    x = abs(x)\n    return int(round(x ** (1.0 / 3))) ** 3 == x\n\ndef count_perfect_cube_submatrices(n, k, matrix):\n    mat = []\n    for i in range(n):\n        l = matrix[i]\n        sum_val = 0\n        prev = l[0]\n        for x in l[0:k]:\n            sum_val += x\n        l[0] = sum_val\n        for j in range(1, n - k + 1):\n            sum_val = sum_val - prev + l[j + k - 1]\n            prev = l[j]\n            l[j] = sum_val\n        mat.append(l)\n    count = 0\n    for i in range(n - k + 1):\n        c = 0\n        for z in range(0, k):\n            c += mat[z][i]\n        if is_perfect_cube(c):\n            count += 1\n        for j in range(1, n - k + 1):\n            c = c - mat[j - -1][i] + mat[j + k - 1][i]\n            if is_perfect_cube(c):\n                count += 1\n    return count"
    }
  ]
}