{
  "task_id": "taco_3771",
  "entry_point": "seieve_prime_factorisation",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "c[x] += 1",
      "mutated_line": "c[x] -= 1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] -= 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while i * i <= n:",
      "mutated_line": "while i * i < n:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i < n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while i * i <= n:",
      "mutated_line": "while i * i > n:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i > n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while i * i <= n:",
      "mutated_line": "while i * i == n:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i == n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i -= 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while p[x] != 1:",
      "mutated_line": "while p[x] == 1:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] == 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "c[p[x]] += 1",
      "mutated_line": "c[p[x]] -= 1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] -= 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c[x] += 1",
      "mutated_line": "c[x] += 2",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 2\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c[x] += 1",
      "mutated_line": "c[x] += 0",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 0\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c[x] += 1",
      "mutated_line": "c[x] += 0",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 0\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c[x] += 1",
      "mutated_line": "c[x] += -1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += -1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [1] / n",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] / n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [1] + n",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] + n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [1] ** n",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] ** n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "dp[i] += ma",
      "mutated_line": "dp[i] -= ma",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] -= ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] / (n + 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] / (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] + (n + 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] + (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] ** (n + 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] ** (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + 1), 3)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 3)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + 1), 1)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 1)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + 1), 0)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 0)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + 1), 1)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 1)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + 1), -2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), -2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "while i * i <= n:",
      "mutated_line": "while i / i <= n:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i / i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "while i * i <= n:",
      "mutated_line": "while i + i <= n:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i + i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "while i * i <= n:",
      "mutated_line": "while i ** i <= n:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i ** i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if p[i] == 1:",
      "mutated_line": "if p[i] != 1:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] != 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 2\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 0\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 0\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += -1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while p[x] != 1:",
      "mutated_line": "while p[x] != 2:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 2:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while p[x] != 1:",
      "mutated_line": "while p[x] != 0:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 0:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while p[x] != 1:",
      "mutated_line": "while p[x] != 0:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 0:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while p[x] != 1:",
      "mutated_line": "while p[x] != -1:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != -1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c[p[x]] += 1",
      "mutated_line": "c[p[x]] += 2",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 2\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c[p[x]] += 1",
      "mutated_line": "c[p[x]] += 0",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 0\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c[p[x]] += 1",
      "mutated_line": "c[p[x]] += 0",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 0\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c[p[x]] += 1",
      "mutated_line": "c[p[x]] += -1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += -1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = x // p[x]",
      "mutated_line": "x = x / p[x]",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x / p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = x // p[x]",
      "mutated_line": "x = x * p[x]",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x * p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n + 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n * 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, +1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, +1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ma = 0",
      "mutated_line": "ma = 1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 1\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ma = 0",
      "mutated_line": "ma = -1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = -1\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ma = 0",
      "mutated_line": "ma = 1",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 1\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n - 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n - 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n * 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n * 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if p[i] == 1:",
      "mutated_line": "if p[i] == 2:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 2:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if p[i] == 1:",
      "mutated_line": "if p[i] == 0:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 0:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if p[i] == 1:",
      "mutated_line": "if p[i] == 0:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 0:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if p[i] == 1:",
      "mutated_line": "if p[i] == -1:",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == -1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [2] * n",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [2] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [0] * n",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [0] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [0] * n",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [0] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [-1] * n",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [-1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 2, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 0, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 0, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - -1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -2, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -0, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -0, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, --1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -2):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -0):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -0):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, --1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([2] * (n + 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([2] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([0] * (n + 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([0] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([0] * (n + 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([0] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([-1] * (n + 1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([-1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + 2), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 2), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + 0), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 0), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + 0), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 0), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(p, i) = ([1] * (n + 1), 2)",
      "mutated_line": "(p, i) = ([1] * (n + -1), 2)",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + -1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i / i, n + 1, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i / i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i + i, n + 1, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i + i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i ** i, n + 1, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i ** i, n + 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i * i, n - 1, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n - 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i * i, n * 1, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n * 1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i * i, n + 2, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 2, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i * i, n + 0, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 0, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i * i, n + 0, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + 0, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i * i, n + 1, i):",
      "mutated_line": "for j in range(i * i, n + -1, i):",
      "code": "from collections import Counter\n\ndef seieve_prime_factorisation(n):\n    (p, i) = ([1] * (n + 1), 2)\n    while i * i <= n:\n        if p[i] == 1:\n            for j in range(i * i, n + -1, i):\n                p[j] = i\n        i += 1\n    return p\n\ndef prime_factorisation_by_seive(p, x):\n    c = Counter()\n    while p[x] != 1:\n        c[p[x]] += 1\n        x = x // p[x]\n    c[x] += 1\n    return c\n\ndef find_longest_good_sequence_length(good_integers):\n    n = len(good_integers)\n    p = seieve_prime_factorisation(max(good_integers))\n    dp = [1] * n\n    b = Counter()\n    for i in range(n - 1, -1, -1):\n        z = prime_factorisation_by_seive(p, good_integers[i])\n        ma = 0\n        for j in z:\n            ma = max(ma, b[j])\n        dp[i] += ma\n        for j in z:\n            b[j] = max(b[j], dp[i])\n    return max(dp)"
    }
  ]
}