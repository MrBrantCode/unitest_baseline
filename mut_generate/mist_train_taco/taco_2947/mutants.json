{
  "task_id": "taco_2947",
  "entry_point": "count_satisfactory_arrays",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 - 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 * 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if M < N:",
      "mutated_line": "if M <= N:",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M <= N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if M < N:",
      "mutated_line": "if M >= N:",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M >= N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if M < N:",
      "mutated_line": "if M != N:",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M != N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans = NChooseK(M, N) * Factorial[N] % mod",
      "mutated_line": "ans = NChooseK(M, N) * Factorial[N] * mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] * mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans = NChooseK(M, N) * Factorial[N] % mod",
      "mutated_line": "ans = NChooseK(M, N) * Factorial[N] + mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] + mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "sign = -1",
      "mutated_line": "sign = +1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = +1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "sign *= -1",
      "mutated_line": "sign /= -1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign /= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 * 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 + 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 8\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 6\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 0\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 1\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + -7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) * mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) * mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) + mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) + mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 1\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return -1\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 1\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "Factorial = [1]",
      "mutated_line": "Factorial = [2]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [2]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "Factorial = [1]",
      "mutated_line": "Factorial = [0]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [0]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "Factorial = [1]",
      "mutated_line": "Factorial = [0]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [0]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "Factorial = [1]",
      "mutated_line": "Factorial = [-1]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [-1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(2, M + 1):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(2, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(0, M + 1):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(0, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(0, M + 1):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(0, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(-1, M + 1):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(-1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(1, M - 1):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M - 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(1, M * 1):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M * 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans = NChooseK(M, N) * Factorial[N] % mod",
      "mutated_line": "ans = NChooseK(M, N) / Factorial[N] % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) / Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans = NChooseK(M, N) * Factorial[N] % mod",
      "mutated_line": "ans = (NChooseK(M, N) + Factorial[N]) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = (NChooseK(M, N) + Factorial[N]) % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans = NChooseK(M, N) * Factorial[N] % mod",
      "mutated_line": "ans = NChooseK(M, N) ** Factorial[N] % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) ** Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sign = -1",
      "mutated_line": "sign = -2",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -2\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sign = -1",
      "mutated_line": "sign = -0",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -0\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sign = -1",
      "mutated_line": "sign = -0",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -0\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sign = -1",
      "mutated_line": "sign = --1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = --1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(2, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(0, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(0, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(-1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds - 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds * 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) *",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) / Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) / Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) *",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) + Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) + Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) *",
      "mutated_line": "delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps)) ** Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps)) ** Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + sign * delta) % mod",
      "mutated_line": "ans = (ans + sign * delta) * mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) * mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + sign * delta) % mod",
      "mutated_line": "ans = ans + sign * delta + mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = ans + sign * delta + mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "sign *= -1",
      "mutated_line": "sign *= +1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= +1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 11 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 9 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 0 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 1 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = -10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 10 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 8 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 0 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 1 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** -9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod + 2, mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod + 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod * 2, mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod * 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] / ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] / ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return (Factorial[n] + ModInverse(Factorial[n - k] * Factorial[k])) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return (Factorial[n] + ModInverse(Factorial[n - k] * Factorial[k])) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] ** ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] ** ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(1, M + 2):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 2):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(1, M + 0):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 0):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(1, M + 0):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 0):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for n in range(1, M + 1):",
      "mutated_line": "for n in range(1, M + -1):",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + -1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[-1] * n * mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n * mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[-1] * n + mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n + mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "num_elements_in_bounds = sum(1 for x in B if x <= M)",
      "mutated_line": "num_elements_in_bounds = sum((2 for x in B if x <= M))",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((2 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "num_elements_in_bounds = sum(1 for x in B if x <= M)",
      "mutated_line": "num_elements_in_bounds = sum((0 for x in B if x <= M))",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((0 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "num_elements_in_bounds = sum(1 for x in B if x <= M)",
      "mutated_line": "num_elements_in_bounds = sum((0 for x in B if x <= M))",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((0 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "num_elements_in_bounds = sum(1 for x in B if x <= M)",
      "mutated_line": "num_elements_in_bounds = sum((-1 for x in B if x <= M))",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((-1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 2):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 0):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 0):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for min_num_overlaps in range(1, num_elements_in_bounds + 1):",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + -1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) *",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) / NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) / NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) *",
      "mutated_line": "delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) + NChooseK(M - min_num_overlaps, N - min_num_overlaps)) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) + NChooseK(M - min_num_overlaps, N - min_num_overlaps)) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "delta = (NChooseK(num_elements_in_bounds, min_num_overlaps) *",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) ** NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) ** NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + sign * delta) % mod",
      "mutated_line": "ans = (ans - sign * delta) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans - sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + sign * delta) % mod",
      "mutated_line": "ans = ans * (sign * delta) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = ans * (sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sign *= -1",
      "mutated_line": "sign *= -2",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sign *= -1",
      "mutated_line": "sign *= -0",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sign *= -1",
      "mutated_line": "sign *= -0",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sign *= -1",
      "mutated_line": "sign *= --1",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= --1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - 3, mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 3, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - 1, mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 1, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - 0, mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 0, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - 1, mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 1, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - -2, mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - -2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[-1] / n % mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] / n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append((Factorial[-1] + n) % mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append((Factorial[-1] + n) % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[-1] ** n % mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] ** n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "num_elements_in_bounds = sum(1 for x in B if x <= M)",
      "mutated_line": "num_elements_in_bounds = sum((1 for x in B if x < M))",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x < M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "num_elements_in_bounds = sum(1 for x in B if x <= M)",
      "mutated_line": "num_elements_in_bounds = sum((1 for x in B if x > M))",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x > M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "num_elements_in_bounds = sum(1 for x in B if x <= M)",
      "mutated_line": "num_elements_in_bounds = sum((1 for x in B if x == M))",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x == M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Factorial[N - min_num_overlaps])",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N + min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N + min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "Factorial[N - min_num_overlaps])",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N * min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N * min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + sign * delta) % mod",
      "mutated_line": "ans = (ans + sign / delta) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign / delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + sign * delta) % mod",
      "mutated_line": "ans = (ans + (sign + delta)) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + (sign + delta)) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + sign * delta) % mod",
      "mutated_line": "ans = (ans + sign ** delta) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign ** delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] * ModInverse(Factorial[n - k] / Factorial[k]) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] / Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] * ModInverse(Factorial[n - k] + Factorial[k]) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] + Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] * ModInverse(Factorial[n - k] ** Factorial[k]) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] ** Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "NChooseK(M - min_num_overlaps, N - min_num_overlaps) *",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M + min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M + min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "NChooseK(M - min_num_overlaps, N - min_num_overlaps) *",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M * min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M * min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "NChooseK(M - min_num_overlaps, N - min_num_overlaps) *",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N + min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N + min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "NChooseK(M - min_num_overlaps, N - min_num_overlaps) *",
      "mutated_line": "delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N * min_num_overlaps) * Factorial[N - min_num_overlaps]",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N * min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[+1] * n % mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[+1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] * ModInverse(Factorial[n + k] * Factorial[k]) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n + k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod",
      "mutated_line": "return Factorial[n] * ModInverse(Factorial[n * k] * Factorial[k]) % mod",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n * k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[-2] * n % mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-2] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[-0] * n % mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-0] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[-0] * n % mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[-0] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "Factorial.append(Factorial[-1] * n % mod)",
      "mutated_line": "Factorial.append(Factorial[--1] * n % mod)",
      "code": "def count_satisfactory_arrays(N, M, B):\n    mod = 10 ** 9 + 7\n\n    def ModInverse(n):\n        return pow(n, mod - 2, mod)\n\n    def NChooseK(n, k):\n        return Factorial[n] * ModInverse(Factorial[n - k] * Factorial[k]) % mod\n    if M < N:\n        return 0\n    Factorial = [1]\n    for n in range(1, M + 1):\n        Factorial.append(Factorial[--1] * n % mod)\n    num_elements_in_bounds = sum((1 for x in B if x <= M))\n    ans = NChooseK(M, N) * Factorial[N] % mod\n    sign = -1\n    for min_num_overlaps in range(1, num_elements_in_bounds + 1):\n        delta = NChooseK(num_elements_in_bounds, min_num_overlaps) * NChooseK(M - min_num_overlaps, N - min_num_overlaps) * Factorial[N - min_num_overlaps]\n        delta %= mod\n        ans = (ans + sign * delta) % mod\n        sign *= -1\n    return ans"
    }
  ]
}