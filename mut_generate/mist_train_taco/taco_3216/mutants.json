{
  "task_id": "taco_3216",
  "entry_point": "postfix_to_infix",
  "mutant_count": 10,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return i in ['*', '^', '/', '+', '-']",
      "mutated_line": "return i not in ['*', '^', '/', '+', '-']",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i not in ['*', '^', '/', '+', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value} {i} {right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return i in ['*', '^', '/', '+', '-']",
      "mutated_line": "return i in ['', '^', '/', '+', '-']",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['', '^', '/', '+', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value} {i} {right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return i in ['*', '^', '/', '+', '-']",
      "mutated_line": "return i in ['*', '', '/', '+', '-']",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['*', '', '/', '+', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value} {i} {right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return i in ['*', '^', '/', '+', '-']",
      "mutated_line": "return i in ['*', '^', '', '+', '-']",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['*', '^', '', '+', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value} {i} {right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return i in ['*', '^', '/', '+', '-']",
      "mutated_line": "return i in ['*', '^', '/', '', '-']",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['*', '^', '/', '', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value} {i} {right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return i in ['*', '^', '/', '+', '-']",
      "mutated_line": "return i in ['*', '^', '/', '+', '']",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['*', '^', '/', '+', '']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value} {i} {right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "q = et(f\"({left_child.value} {i} {right_child.value})\")",
      "mutated_line": "q = et(f'{left_child.value} {i} {right_child.value})')",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['*', '^', '/', '+', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'{left_child.value} {i} {right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "q = et(f\"({left_child.value} {i} {right_child.value})\")",
      "mutated_line": "q = et(f'({left_child.value}{i} {right_child.value})')",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['*', '^', '/', '+', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value}{i} {right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "q = et(f\"({left_child.value} {i} {right_child.value})\")",
      "mutated_line": "q = et(f'({left_child.value} {i}{right_child.value})')",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['*', '^', '/', '+', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value} {i}{right_child.value})')\n            stack.append(q)\n    return stack.pop().value"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "q = et(f\"({left_child.value} {i} {right_child.value})\")",
      "mutated_line": "q = et(f'({left_child.value} {i} {right_child.value}')",
      "code": "def postfix_to_infix(postfix: str) -> str:\n\n    def is_operator(i: str) -> bool:\n        return i in ['*', '^', '/', '+', '-']\n\n    class et:\n\n        def __init__(self, value):\n            self.left = None\n            self.right = None\n            self.value = value\n    stack = []\n    for i in postfix:\n        if not is_operator(i):\n            q = et(i)\n            stack.append(q)\n        else:\n            right_child = stack.pop()\n            left_child = stack.pop()\n            q = et(f'({left_child.value} {i} {right_child.value}')\n            stack.append(q)\n    return stack.pop().value"
    }
  ]
}