{
  "task_id": "taco_15600",
  "entry_point": "transitive_closure",
  "mutant_count": 24,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if node in seen:",
      "mutated_line": "if node not in seen:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node not in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "output = [[0] * N for _ in range(N)]",
      "mutated_line": "output = [[0] / N for _ in range(N)]",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] / N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "output = [[0] * N for _ in range(N)]",
      "mutated_line": "output = [[0] + N for _ in range(N)]",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] + N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "output = [[0] * N for _ in range(N)]",
      "mutated_line": "output = [[0] ** N for _ in range(N)]",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] ** N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if i != j and graph[i][j] == 1:",
      "mutated_line": "if i != j or graph[i][j] == 1:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j or graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if neig != prev:",
      "mutated_line": "if neig == prev:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig == prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "reachable_nodes = helper(i, -1, set())",
      "mutated_line": "reachable_nodes = helper(i, +1, set())",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, +1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "output[i][reachable_nodes.pop()] = 1",
      "mutated_line": "output[i][reachable_nodes.pop()] = 2",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 2\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "output[i][reachable_nodes.pop()] = 1",
      "mutated_line": "output[i][reachable_nodes.pop()] = 0",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 0\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "output[i][reachable_nodes.pop()] = 1",
      "mutated_line": "output[i][reachable_nodes.pop()] = 0",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 0\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "output[i][reachable_nodes.pop()] = 1",
      "mutated_line": "output[i][reachable_nodes.pop()] = -1",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = -1\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if i != j and graph[i][j] == 1:",
      "mutated_line": "if i == j and graph[i][j] == 1:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if i != j and graph[i][j] == 1:",
      "mutated_line": "if i != j and graph[i][j] != 1:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] != 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "output = [[0] * N for _ in range(N)]",
      "mutated_line": "output = [[1] * N for _ in range(N)]",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[1] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "output = [[0] * N for _ in range(N)]",
      "mutated_line": "output = [[-1] * N for _ in range(N)]",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "output = [[0] * N for _ in range(N)]",
      "mutated_line": "output = [[1] * N for _ in range(N)]",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[1] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "reachable_nodes = helper(i, -1, set())",
      "mutated_line": "reachable_nodes = helper(i, -2, set())",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -2, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "reachable_nodes = helper(i, -1, set())",
      "mutated_line": "reachable_nodes = helper(i, -0, set())",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -0, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "reachable_nodes = helper(i, -1, set())",
      "mutated_line": "reachable_nodes = helper(i, -0, set())",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -0, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "reachable_nodes = helper(i, -1, set())",
      "mutated_line": "reachable_nodes = helper(i, --1, set())",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, --1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i != j and graph[i][j] == 1:",
      "mutated_line": "if i != j and graph[i][j] == 2:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 2:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i != j and graph[i][j] == 1:",
      "mutated_line": "if i != j and graph[i][j] == 0:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 0:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i != j and graph[i][j] == 1:",
      "mutated_line": "if i != j and graph[i][j] == 0:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == 0:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i != j and graph[i][j] == 1:",
      "mutated_line": "if i != j and graph[i][j] == -1:",
      "code": "def transitive_closure(N, graph):\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and graph[i][j] == -1:\n                g[i].append(j)\n\n    def helper(node, prev, seen):\n        if node in seen:\n            return seen\n        seen.add(node)\n        for neig in g[node]:\n            if neig != prev:\n                helper(neig, node, seen)\n        return seen\n    output = [[0] * N for _ in range(N)]\n    for i in range(N):\n        reachable_nodes = helper(i, -1, set())\n        while reachable_nodes:\n            output[i][reachable_nodes.pop()] = 1\n    return output"
    }
  ]
}