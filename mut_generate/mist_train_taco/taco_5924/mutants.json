{
  "task_id": "taco_5924",
  "entry_point": "calculate_hash_and_count",
  "mutant_count": 123,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 1\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = -1\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 1\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(expression) == 1:",
      "mutated_line": "if len(expression) != 1:",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) != 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return +1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(10000):",
      "mutated_line": "for k in range(10001):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10001):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(10000):",
      "mutated_line": "for k in range(9999):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(9999):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(10000):",
      "mutated_line": "for k in range(0):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(0):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(10000):",
      "mutated_line": "for k in range(1):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(1):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(10000):",
      "mutated_line": "for k in range(-10000):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(-10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if current_hash_value == hash_value:",
      "mutated_line": "if current_hash_value != hash_value:",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value != hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count -= 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(expression) == 1:",
      "mutated_line": "if len(expression) == 2:",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 2:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(expression) == 1:",
      "mutated_line": "if len(expression) == 0:",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 0:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(expression) == 1:",
      "mutated_line": "if len(expression) == 0:",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 0:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(expression) == 1:",
      "mutated_line": "if len(expression) == -1:",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == -1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(length - 4):",
      "mutated_line": "for i in range(length + 4):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length + 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(length - 4):",
      "mutated_line": "for i in range(length * 4):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length * 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' or expression[i + 4] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' or expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -2\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -0\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -0\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return --1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "expression = [password_digits[ord(char) - ord('a')] if char not in 'abcd' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char not in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i * 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i * 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i + 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i + 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 2\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 0\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 0\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += -1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return expression[0]",
      "mutated_line": "return expression[1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[1]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return expression[0]",
      "mutated_line": "return expression[-1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[-1]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return expression[0]",
      "mutated_line": "return expression[1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[1]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(length - 4):",
      "mutated_line": "for i in range(length - 5):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 5):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(length - 4):",
      "mutated_line": "for i in range(length - 3):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 3):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(length - 4):",
      "mutated_line": "for i in range(length - 0):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 0):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(length - 4):",
      "mutated_line": "for i in range(length - 1):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 1):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(length - 4):",
      "mutated_line": "for i in range(length - -4):",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - -4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] != '[' and expression[i + 4] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] != '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i + 4] != ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] != ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "result = -1",
      "mutated_line": "result = +1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = +1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if operator == '+':",
      "mutated_line": "if operator != '+':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator != '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "expression = [password_digits[ord(char) - ord('a')] if char in '' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in '' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "expression = [password_digits[ord(char) + ord('a')] if char in 'abcd' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) + ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "expression = [password_digits[ord(char) * ord('a')] if char in 'abcd' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) * ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k / 10 ** i % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k / 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k * 10 ** i % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k * 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 11 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 11 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 9 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 9 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 0 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 0 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 1 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 1 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % -10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % -10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "current_expression = [current_password[ord(char) - ord('a')] if char not in 'abcd' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char not in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '' and expression[i + 4] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i + 4] == '':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == '':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "operator = expression[i + 1]",
      "mutated_line": "operator = expression[i - 1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i - 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "operator = expression[i + 1]",
      "mutated_line": "operator = expression[i * 1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i * 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "operand1 = expression[i + 2]",
      "mutated_line": "operand1 = expression[i - 2]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i - 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "operand1 = expression[i + 2]",
      "mutated_line": "operand1 = expression[i * 2]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i * 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "operand2 = expression[i + 3]",
      "mutated_line": "operand2 = expression[i - 3]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i - 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "operand2 = expression[i + 3]",
      "mutated_line": "operand2 = expression[i * 3]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i * 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result = -1",
      "mutated_line": "result = -2",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -2\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result = -1",
      "mutated_line": "result = -0",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -0\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result = -1",
      "mutated_line": "result = -0",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -0\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result = -1",
      "mutated_line": "result = --1",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = --1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if operator == '+':",
      "mutated_line": "if operator == '':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "result = operand1 | operand2",
      "mutated_line": "result = operand1 & operand2",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 & operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "result = operand1 | operand2",
      "mutated_line": "result = operand1 ^ operand2",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 ^ operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif operator == '*':",
      "mutated_line": "elif operator != '*':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator != '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] + [result] - expression[i + 5:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] - expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash((expression[:i] + [result]) * expression[i + 5:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash((expression[:i] + [result]) * expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // (10 * i) % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // (10 * i) % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // (10 + i) % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // (10 + i) % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 10 for i in range(5)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(5)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 10 for i in range(3)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(3)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 10 for i in range(0)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(0)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 10 for i in range(1)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(1)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 10 ** i % 10 for i in range(-4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(-4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "current_expression = [current_password[ord(char) - ord('a')] if char in '' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in '' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "current_expression = [current_password[ord(char) + ord('a')] if char in 'abcd' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) + ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "current_expression = [current_password[ord(char) * ord('a')] if char in 'abcd' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) * ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i - 4] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i - 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i * 4] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i * 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "operator = expression[i + 1]",
      "mutated_line": "operator = expression[i + 2]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 2]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "operator = expression[i + 1]",
      "mutated_line": "operator = expression[i + 0]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 0]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "operator = expression[i + 1]",
      "mutated_line": "operator = expression[i + 0]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 0]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "operator = expression[i + 1]",
      "mutated_line": "operator = expression[i + -1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + -1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "operand1 = expression[i + 2]",
      "mutated_line": "operand1 = expression[i + 3]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 3]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "operand1 = expression[i + 2]",
      "mutated_line": "operand1 = expression[i + 1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 1]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "operand1 = expression[i + 2]",
      "mutated_line": "operand1 = expression[i + 0]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 0]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "operand1 = expression[i + 2]",
      "mutated_line": "operand1 = expression[i + 1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 1]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "operand1 = expression[i + 2]",
      "mutated_line": "operand1 = expression[i + -2]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + -2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "operand2 = expression[i + 3]",
      "mutated_line": "operand2 = expression[i + 4]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 4]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "operand2 = expression[i + 3]",
      "mutated_line": "operand2 = expression[i + 2]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 2]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "operand2 = expression[i + 3]",
      "mutated_line": "operand2 = expression[i + 0]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 0]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "operand2 = expression[i + 3]",
      "mutated_line": "operand2 = expression[i + 1]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 1]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "operand2 = expression[i + 3]",
      "mutated_line": "operand2 = expression[i + -3]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + -3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif operator == '*':",
      "mutated_line": "elif operator == '':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result = operand1 & operand2",
      "mutated_line": "result = operand1 | operand2",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 | operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif operator == '^':",
      "mutated_line": "elif operator != '^':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator != '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] - [result] + expression[i + 5:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] - [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] * [result] + expression[i + 5:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] * [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "expression = [password_digits[ord(char) - ord('')] if char in 'abcd' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 11 ** i % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 11 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 9 ** i % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 9 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 0 ** i % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 0 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // 1 ** i % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 1 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current_password = [k // 10 ** i % 10 for i in range(4)]",
      "mutated_line": "current_password = [k // -10 ** i % 10 for i in range(4)]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // -10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i + 5] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 5] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i + 3] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 3] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i + 0] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 0] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i + 1] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 1] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if expression[i] == '[' and expression[i + 4] == ']':",
      "mutated_line": "if expression[i] == '[' and expression[i + -4] == ']':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + -4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif operator == '^':",
      "mutated_line": "elif operator == '':",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "result = operand1 ^ operand2",
      "mutated_line": "result = operand1 | operand2",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 | operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]",
      "mutated_line": "current_expression = [current_password[ord(char) - ord('')] if char in 'abcd' else char for char in hash_function]",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] + [result] + expression[i - 5:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i - 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] + [result] + expression[i * 5:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i * 5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 6:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 6:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 4:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 4:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 0:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 0:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 1:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + 1:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return evaluate_hash(expression[:i] + [result] + expression[i + 5:])",
      "mutated_line": "return evaluate_hash(expression[:i] + [result] + expression[i + -5:])",
      "code": "def calculate_hash_and_count(hash_function: str, password: str) -> tuple:\n\n    def evaluate_hash(expression):\n        if len(expression) == 1:\n            return expression[0]\n        length = len(expression)\n        for i in range(length - 4):\n            if expression[i] == '[' and expression[i + 4] == ']':\n                operator = expression[i + 1]\n                operand1 = expression[i + 2]\n                operand2 = expression[i + 3]\n                result = -1\n                if operator == '+':\n                    result = operand1 | operand2\n                elif operator == '*':\n                    result = operand1 & operand2\n                elif operator == '^':\n                    result = operand1 ^ operand2\n                return evaluate_hash(expression[:i] + [result] + expression[i + -5:])\n        return -1\n    password_digits = [int(digit) for digit in password]\n    expression = [password_digits[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n    hash_value = evaluate_hash(expression)\n    count = 0\n    for k in range(10000):\n        current_password = [k // 10 ** i % 10 for i in range(4)]\n        current_expression = [current_password[ord(char) - ord('a')] if char in 'abcd' else char for char in hash_function]\n        current_hash_value = evaluate_hash(current_expression)\n        if current_hash_value == hash_value:\n            count += 1\n    return (hash_value, count)"
    }
  ]
}