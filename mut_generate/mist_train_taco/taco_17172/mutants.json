{
  "task_id": "taco_17172",
  "entry_point": "check_prime_sums",
  "mutant_count": 230,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 - [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 - [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 * ([True] * (limit - 1))",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 * ([True] * (limit - 1))\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if limit < 3: return",
      "mutated_line": "if limit <= 3:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit <= 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if limit < 3: return",
      "mutated_line": "if limit >= 3:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit >= 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if limit < 3: return",
      "mutated_line": "if limit != 3:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit != 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) / 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) * 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] / (lmtbf + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] / (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] + (lmtbf + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] + (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] ** (lmtbf + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] ** (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n == 2:",
      "mutated_line": "if n != 2:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n != 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 0 and n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 and n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) - 1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) - 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) * 1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) * 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return \"YES\"",
      "mutated_line": "return ''",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return ''\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 1\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = -1\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 1\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "while idx < length and l[idx] <= n:",
      "mutated_line": "while idx < length or l[idx] <= n:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length or l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "s += l[idx]",
      "mutated_line": "s -= l[idx]",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s -= l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "idx += 1",
      "mutated_line": "idx -= 1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx -= 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] / 2 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] / 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] + 2 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] + 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] ** 2 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] ** 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [True] / (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] / (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + ([True] + (limit - 1))",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + ([True] + (limit - 1))\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [True] ** (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] ** (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "yield 2",
      "mutated_line": "yield 3",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 3\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "yield 2",
      "mutated_line": "yield 1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 1\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "yield 2",
      "mutated_line": "yield 0",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 0\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "yield 2",
      "mutated_line": "yield 1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 1\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "yield 2",
      "mutated_line": "yield -2",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield -2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if limit < 3: return",
      "mutated_line": "if limit < 4:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 4:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if limit < 3: return",
      "mutated_line": "if limit < 2:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 2:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if limit < 3: return",
      "mutated_line": "if limit < 0:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 0:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if limit < 3: return",
      "mutated_line": "if limit < 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 1:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if limit < 3: return",
      "mutated_line": "if limit < -3:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < -3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit + 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = limit * 3 // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 3\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 1\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 0\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 1\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // -2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] * (lmtbf - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf - 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] * (lmtbf * 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf * 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 2 - 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 - 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 2 * 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 * 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(lmtbf + 1):",
      "mutated_line": "for i in range(lmtbf - 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf - 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(lmtbf + 1):",
      "mutated_line": "for i in range(lmtbf * 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf * 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 3:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 3:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 1:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 0:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 0:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 1:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n == 2:",
      "mutated_line": "if n == -2:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == -2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return \"YES\"",
      "mutated_line": "return ''",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return ''\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 != 0 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 != 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 0 or n < 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n < 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 0 or n > 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n > 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 0 or n == 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n == 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return ''\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) + 2",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 2\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) + 0",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 0\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) + 0",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 0\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) + -1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + -1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(4, sqr, 2):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(4, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(2, sqr, 2):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(2, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(0, sqr, 2):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(0, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(1, sqr, 2):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(1, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(-3, sqr, 2):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(-3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 3):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 3):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 1):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 0):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 0):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 1):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, -2):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, -2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n % divisor != 0:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor != 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = list(iprimes2(1000001))",
      "mutated_line": "l = list(iprimes2(1000002))",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000002))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = list(iprimes2(1000001))",
      "mutated_line": "l = list(iprimes2(1000000))",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000000))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = list(iprimes2(1000001))",
      "mutated_line": "l = list(iprimes2(0))",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(0))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = list(iprimes2(1000001))",
      "mutated_line": "l = list(iprimes2(1))",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "l = list(iprimes2(1000001))",
      "mutated_line": "l = list(iprimes2(-1000001))",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(-1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while idx < length and l[idx] <= n:",
      "mutated_line": "while idx <= length and l[idx] <= n:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx <= length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while idx < length and l[idx] <= n:",
      "mutated_line": "while idx >= length and l[idx] <= n:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx >= length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while idx < length and l[idx] <= n:",
      "mutated_line": "while idx != length and l[idx] <= n:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx != length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while idx < length and l[idx] <= n:",
      "mutated_line": "while idx < length and l[idx] < n:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] < n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while idx < length and l[idx] <= n:",
      "mutated_line": "while idx < length and l[idx] > n:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] > n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while idx < length and l[idx] <= n:",
      "mutated_line": "while idx < length and l[idx] == n:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] == n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "idx += 1",
      "mutated_line": "idx += 2",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 2\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 0\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 0\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "idx += 1",
      "mutated_line": "idx += -1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += -1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 3 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 3 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 1 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 1 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 0 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 0 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 1 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 1 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * -2 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * -2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [True] * (limit + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit + 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [True] * (limit * 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit * 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 0.5 - 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 - 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 0.5 * 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 * 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 4) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 2) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 0) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 1) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lmtbf = (limit - 3) // 2",
      "mutated_line": "return",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - -3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [False] * (lmtbf + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [False] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] * (lmtbf + 2)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 2)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] * (lmtbf + 0)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 0)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] * (lmtbf + 0)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 0)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "buf = [True] * (lmtbf + 1)",
      "mutated_line": "buf = [True] * (lmtbf + -1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + -1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) / 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) / 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) * 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) * 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 2):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 2):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 0):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 0):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 0):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 0):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 2 + -1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + -1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = i + i - 3",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i - 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = (i + i) * 3",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = (i + i) * 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p * (i + 1) - i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) - i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p * (i + 1) * i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) * i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] / ((lmtbf - s) // p + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] / ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] + ((lmtbf - s) // p + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] + ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] ** ((lmtbf - s) // p + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] ** ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(lmtbf + 1):",
      "mutated_line": "for i in range(lmtbf + 2):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 2):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(lmtbf + 1):",
      "mutated_line": "for i in range(lmtbf + 0):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 0):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(lmtbf + 1):",
      "mutated_line": "for i in range(lmtbf + 0):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 0):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(lmtbf + 1):",
      "mutated_line": "for i in range(lmtbf + -1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + -1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n * 2 == 0 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n * 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n + 2 == 0 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n + 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 1 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 1 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == -1 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == -1 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 1 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 1 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 0 or n <= 2:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 2:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 0 or n <= 0:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 0:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 0 or n <= 0:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 0:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 2 == 0 or n <= -1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= -1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n * divisor == 0:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n * divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n + divisor == 0:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n + divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n % divisor == 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 1:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n % divisor == -1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == -1:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n % divisor == 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 1:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return ''\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [True] * 2 + [True] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [True] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [False] * (limit - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [False] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [True] * (limit - 2)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 2)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [True] * (limit - 0)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 0)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [True] * (limit - 0)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 0)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [False] * 2 + [True] * (limit - 1)",
      "mutated_line": "is_prime = [False] * 2 + [True] * (limit - -1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - -1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit * 0.5 + 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit * 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit + 0.5 + 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit + 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 0.5 + 2.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 2.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 0.5 + 0.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 0.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 0.5 + 0)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 0)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 0.5 + 1)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 0.5 + -1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + -1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n / n, limit + 1, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n / n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n + n, limit + 1, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n + n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n ** n, limit + 1, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n ** n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n * n, limit - 1, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit - 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n * n, limit * 1, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit * 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "is_prime[i] = False",
      "mutated_line": "is_prime[i] = True",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = True\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) + 3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) + 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range(int(limit ** 0.5) * 3 // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range(int(limit ** 0.5) * 3 // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 3 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 3 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 1 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 1 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 0 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 0 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // 1 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 1 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 3) // -2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // -2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = i - i + 3",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i - i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = i * i + 3",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i * i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = i + i + 4",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 4\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = i + i + 2",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 2\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = i + i + 0",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 0\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = i + i + 1",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 1\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p = i + i + 3",
      "mutated_line": "p = i + i + -3",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + -3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p / (i + 1) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p / (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p + (i + 1) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p + (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p ** (i + 1) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p ** (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf - s) // p - 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p - 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf - s) // p * 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p * 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i - 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield ((i + i) * 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 3 == 0 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 3 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 1 == 0 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 1 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 0 == 0 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 0 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % 1 == 0 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 1 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n % 2 == 0 or n <= 1:",
      "mutated_line": "if n % -2 == 0 or n <= 1:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % -2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 1.5 + 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 1.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** -0.5 + 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** -0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 0 + 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** 1 + 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 1 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(int(limit**0.5 + 1.5)):",
      "mutated_line": "for n in range(int(limit ** -0.5 + 1.5)):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** -0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n * n, limit + 2, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 2, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n * n, limit + 0, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 0, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n * n, limit + 0, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 0, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(n*n, limit+1, n):",
      "mutated_line": "for i in range(n * n, limit + -1, n):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + -1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 4) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 4) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 2) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 2) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 0) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 0) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - 1) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 1) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0.5) - -3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - -3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p * (i - 1) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i - 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p * (i * 1) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i * 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [True] * ((lmtbf - s) // p + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [True] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf - s) / p + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) / p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf - s) * p + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) * p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 2)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 2)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 0)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 0)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 0)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 0)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf - s) // p + -1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + -1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i - i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i * i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 4)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 2)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 0)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 1)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if buf[i]: yield (i + i + 3)",
      "mutated_line": "if buf[i]:",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + -3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit * 0.5) - 3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit * 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit + 0.5) - 3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit + 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p * (i + 2) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 2) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p * (i + 0) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 0) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p * (i + 0) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 0) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s = p * (i + 1) + i",
      "mutated_line": "s = p * (i + -1) + i",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + -1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * ((lmtbf + s) // p + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf + s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "buf[s::p] = [False] * ((lmtbf - s) // p + 1)",
      "mutated_line": "buf[s::p] = [False] * (lmtbf * s // p + 1)",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * (lmtbf * s // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 1.5) - 3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 1.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** -0.5) - 3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** -0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 0) - 3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 0) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** 1) - 3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** 1) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range((int(limit ** 0.5) - 3) // 2 + 1):",
      "mutated_line": "for i in range((int(limit ** -0.5) - 3) // 2 + 1):",
      "code": "def check_prime_sums(T, test_cases):\n    import bisect, math\n\n    def primes_upto(limit):\n        is_prime = [False] * 2 + [True] * (limit - 1)\n        for n in range(int(limit ** 0.5 + 1.5)):\n            if is_prime[n]:\n                for i in range(n * n, limit + 1, n):\n                    is_prime[i] = False\n        return [i for (i, prime) in enumerate(is_prime) if prime]\n\n    def iprimes2(limit):\n        yield 2\n        if limit < 3:\n            return\n        lmtbf = (limit - 3) // 2\n        buf = [True] * (lmtbf + 1)\n        for i in range((int(limit ** -0.5) - 3) // 2 + 1):\n            if buf[i]:\n                p = i + i + 3\n                s = p * (i + 1) + i\n                buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n        for i in range(lmtbf + 1):\n            if buf[i]:\n                yield (i + i + 3)\n\n    def is_prime(n):\n        if n == 2:\n            return 'YES'\n        if n % 2 == 0 or n <= 1:\n            return 'NO'\n        sqr = int(math.sqrt(n)) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return 'NO'\n        return 'YES'\n    l = list(iprimes2(1000001))\n    length = len(l)\n    results = []\n    for (m, n) in test_cases:\n        idx = bisect.bisect_left(l, m)\n        s = 0\n        while idx < length and l[idx] <= n:\n            s += l[idx]\n            idx += 1\n        results.append(is_prime(s))\n    return results"
    }
  ]
}