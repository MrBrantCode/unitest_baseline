{
  "task_id": "taco_13172",
  "entry_point": "restore_edge_lengths",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 18 - 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 - 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 18 * 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 * 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "S = [INF] + distances",
      "mutated_line": "S = [INF] - distances",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] - distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "S = [INF] + distances",
      "mutated_line": "S = [INF] * distances",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] * distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] / (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] / (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] + (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] + (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] ** (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] ** (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] / (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] / (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] + (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] + (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] ** (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] ** (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "subtree_size[parent[v]] += subtree_size[v]",
      "mutated_line": "subtree_size[parent[v]] -= subtree_size[v]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] -= subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] / (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] / (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] + (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] + (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] ** (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] ** (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] / (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] / (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] + (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] + (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] ** (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] ** (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) * 2 / N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 / N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) * 2 * N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 * N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 * 18 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 * 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 + 18 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 + 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 18 + 101",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 101\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 18 + 99",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 99\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 18 + 0",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 0\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 18 + 1",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 1\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 18 + -100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + -100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] * (N - 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N - 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] * (N * 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N * 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] * (N - 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N - 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] * (N * 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N * 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] * (N - 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N - 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] * (N * 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N * 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if parent[p] == v:",
      "mutated_line": "if parent[p] != v:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] != v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d = N - s - s",
      "mutated_line": "d = N - s + s",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s + s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d = N - s - s",
      "mutated_line": "d = (N - s) * s",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = (N - s) * s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] * (N - 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N - 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] * (N * 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N * 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[v] = dist[p] + length[v]",
      "mutated_line": "dist[v] = dist[p] - length[v]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] - length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dist[v] = dist[p] + length[v]",
      "mutated_line": "dist[v] = dist[p] * length[v]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] * length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) / 2 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) / 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root + 2) // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root + 2) // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) ** 2 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) ** 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if parent[p] == v:",
      "mutated_line": "if parent[p] != v:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] != v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if length[v] == 0:",
      "mutated_line": "if length[v] != 0:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] != 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 11 ** 18 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 11 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 9 ** 18 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 9 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 0 ** 18 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 0 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 1 ** 18 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 1 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = -10 ** 18 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = -10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 19 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 19 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 17 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 17 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 0 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 0 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** 1 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 1 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 18 + 100",
      "mutated_line": "INF = 10 ** -18 + 100",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** -18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [1] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [-1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [-1] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [1] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] * (N + 2)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 2)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] * (N + 0)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 0)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] * (N + 0)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 0)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "parent = [0] * (N + 1)",
      "mutated_line": "parent = [0] * (N + -1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + -1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if y == parent[x]:",
      "mutated_line": "if y != parent[x]:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y != parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [2] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [2] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [0] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [0] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [0] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [0] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [-1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [-1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] * (N + 2)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 2)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] * (N + 0)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 0)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] * (N + 0)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 0)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "subtree_size = [1] * (N + 1)",
      "mutated_line": "subtree_size = [1] * (N + -1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + -1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [1] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [-1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [-1] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [1] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] * (N + 2)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 2)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] * (N + 0)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 0)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] * (N + 0)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 0)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length = [0] * (N + 1)",
      "mutated_line": "length = [0] * (N + -1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + -1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d = N - s - s",
      "mutated_line": "d = N + s - s",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N + s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d = N - s - s",
      "mutated_line": "d = N * s - s",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N * s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 0 if d != 0 else (S[v] - S[p]) // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d != 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 1 if d == 0 else (S[v] - S[p]) // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 1 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = -1 if d == 0 else (S[v] - S[p]) // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = -1 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 1 if d == 0 else (S[v] - S[p]) // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 1 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) / d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) / d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) * d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) * d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [1] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [-1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [-1] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [1] * (N + 1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [1] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] * (N + 2)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 2)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] * (N + 0)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 0)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] * (N + 0)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 0)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist = [0] * (N + 1)",
      "mutated_line": "dist = [0] * (N + -1)",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + -1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in order[1:]:",
      "mutated_line": "for v in order[2:]:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[2:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in order[1:]:",
      "mutated_line": "for v in order[0:]:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[0:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in order[1:]:",
      "mutated_line": "for v in order[0:]:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[0:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in order[1:]:",
      "mutated_line": "for v in order[-1:]:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[-1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] + d_root) * 2 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] + d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = S[root] * d_root * 2 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = S[root] * d_root * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) * 3 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 3 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) * 1 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 1 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) * 0 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 0 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) * 1 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 1 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = (S[root] - d_root) * 2 // N",
      "mutated_line": "x = (S[root] - d_root) * -2 // N",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * -2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if length[v] == 0:",
      "mutated_line": "if length[v] == 1:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 1:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if length[v] == 0:",
      "mutated_line": "if length[v] == -1:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == -1:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if length[v] == 0:",
      "mutated_line": "if length[v] == 1:",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 1:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N - 1)]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N - 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N * 1)]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N * 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 0 if d == 1 else (S[v] - S[p]) // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 1 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 0 if d == -1 else (S[v] - S[p]) // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == -1 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 0 if d == 1 else (S[v] - S[p]) // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 1 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 0 if d == 0 else (S[v] + S[p]) // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] + S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "length[v] = 0 if d == 0 else (S[v] - S[p]) // d",
      "mutated_line": "length[v] = 0 if d == 0 else S[v] * S[p] // d",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else S[v] * S[p] // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 2)]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 2)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 0)]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 0)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 0)]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + 0)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + -1)]",
      "code": "def restore_edge_lengths(N, edges, distances):\n    INF = 10 ** 18 + 100\n    S = [INF] + distances\n    graph = [[] for _ in range(N + -1)]\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    root = S.index(min(S))\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n    subtree_size = [1] * (N + 1)\n    for v in reversed(order):\n        subtree_size[parent[v]] += subtree_size[v]\n    length = [0] * (N + 1)\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        s = subtree_size[v]\n        d = N - s - s\n        length[v] = 0 if d == 0 else (S[v] - S[p]) // d\n    dist = [0] * (N + 1)\n    for v in order[1:]:\n        p = parent[v]\n        dist[v] = dist[p] + length[v]\n    d_root = sum(dist)\n    x = (S[root] - d_root) * 2 // N\n    answer = []\n    for (v, p) in edges:\n        if parent[p] == v:\n            (v, p) = (p, v)\n        if length[v] == 0:\n            length[v] = x\n        answer.append(length[v])\n    return answer"
    }
  ]
}