{
  "task_id": "taco_8247",
  "entry_point": "find_minimal_rectangle_sticks",
  "mutant_count": 135,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(set(sticks)) == 1:",
      "mutated_line": "if len(set(sticks)) != 1:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) != 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "min_index = 0",
      "mutated_line": "min_index = 1",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 1\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "min_index = 0",
      "mutated_line": "min_index = -1",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = -1\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "min_index = 0",
      "mutated_line": "min_index = 1",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 1\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(set(sticks)) == 1:",
      "mutated_line": "if len(set(sticks)) == 2:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 2:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(set(sticks)) == 1:",
      "mutated_line": "if len(set(sticks)) == 0:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 0:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(set(sticks)) == 1:",
      "mutated_line": "if len(set(sticks)) == 0:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 0:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(set(sticks)) == 1:",
      "mutated_line": "if len(set(sticks)) == -1:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == -1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if stick in stick_count:",
      "mutated_line": "if stick not in stick_count:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick not in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "stick_count[stick] += 1",
      "mutated_line": "stick_count[stick] -= 1",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] -= 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if stick_count[length] >= 4:",
      "mutated_line": "if stick_count[length] > 4:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] > 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if stick_count[length] >= 4:",
      "mutated_line": "if stick_count[length] < 4:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] < 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if stick_count[length] >= 4:",
      "mutated_line": "if stick_count[length] == 4:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] == 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(len(possible_lengths) - 1):",
      "mutated_line": "for i in range(len(possible_lengths) + 1):",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) + 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(len(possible_lengths) - 1):",
      "mutated_line": "for i in range(len(possible_lengths) * 1):",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) * 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 * (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 * (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 // (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 // (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 * (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 * (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 // (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 // (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if current_value < min_value:",
      "mutated_line": "if current_value <= min_value:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value <= min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if current_value < min_value:",
      "mutated_line": "if current_value >= min_value:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value >= min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if current_value < min_value:",
      "mutated_line": "if current_value != min_value:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value != min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stick_count[stick] += 1",
      "mutated_line": "stick_count[stick] += 2",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 2\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stick_count[stick] += 1",
      "mutated_line": "stick_count[stick] += 0",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 0\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stick_count[stick] += 1",
      "mutated_line": "stick_count[stick] += 0",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 0\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stick_count[stick] += 1",
      "mutated_line": "stick_count[stick] += -1",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += -1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stick_count[stick] = 1",
      "mutated_line": "stick_count[stick] = 2",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 2\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stick_count[stick] = 1",
      "mutated_line": "stick_count[stick] = 0",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 0\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stick_count[stick] = 1",
      "mutated_line": "stick_count[stick] = 0",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 0\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stick_count[stick] = 1",
      "mutated_line": "stick_count[stick] = -1",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = -1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if stick_count[length] >= 4:",
      "mutated_line": "if stick_count[length] >= 5:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 5:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if stick_count[length] >= 4:",
      "mutated_line": "if stick_count[length] >= 3:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 3:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if stick_count[length] >= 4:",
      "mutated_line": "if stick_count[length] >= 0:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 0:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if stick_count[length] >= 4:",
      "mutated_line": "if stick_count[length] >= 1:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 1:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if stick_count[length] >= 4:",
      "mutated_line": "if stick_count[length] >= -4:",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= -4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 2]",
      "mutated_line": "possible_lengths = [length for length in stick_count if stick_count[length] > 2]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] > 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 2]",
      "mutated_line": "possible_lengths = [length for length in stick_count if stick_count[length] < 2]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] < 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 2]",
      "mutated_line": "possible_lengths = [length for length in stick_count if stick_count[length] == 2]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] == 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(possible_lengths) - 1):",
      "mutated_line": "for i in range(len(possible_lengths) - 2):",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 2):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(possible_lengths) - 1):",
      "mutated_line": "for i in range(len(possible_lengths) - 0):",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 0):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(possible_lengths) - 1):",
      "mutated_line": "for i in range(len(possible_lengths) - 0):",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 0):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(possible_lengths) - 1):",
      "mutated_line": "for i in range(len(possible_lengths) - -1):",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - -1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) * 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) * 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1] + 2) / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1] + 2) / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] / current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] / current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] + current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] + current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / current_pair[0] ** current_pair[1]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / current_pair[0] ** current_pair[1]\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) * 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) * 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1] + 2) / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1] + 2) / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] / min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] / min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] + min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] + min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / min_pair[0] ** min_pair[1]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / min_pair[0] ** min_pair[1]\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index - 1], possible_lengths[min_index + 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index - 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index * 1], possible_lengths[min_index + 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index * 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index - 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index * 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index * 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[1], sticks[0], sticks[0], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[1], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[-1], sticks[0], sticks[0], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[-1], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[1], sticks[0], sticks[0], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[1], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[1], sticks[0], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[1], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[-1], sticks[0], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[-1], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[1], sticks[0], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[1], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[0], sticks[1], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[1], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[0], sticks[-1], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[-1], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[0], sticks[1], sticks[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[1], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[0], sticks[0], sticks[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[1])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[0], sticks[0], sticks[-1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[-1])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (sticks[0], sticks[0], sticks[0], sticks[0])",
      "mutated_line": "return (sticks[0], sticks[0], sticks[0], sticks[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[1])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 2]",
      "mutated_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 3]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 3]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 2]",
      "mutated_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 1]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 1]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 2]",
      "mutated_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 0]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 0]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 2]",
      "mutated_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 1]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 1]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= 2]",
      "mutated_line": "possible_lengths = [length for length in stick_count if stick_count[length] >= -2]",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= -2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "current_pair = (possible_lengths[i], possible_lengths[i + 1])",
      "mutated_line": "current_pair = (possible_lengths[i], possible_lengths[i - 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i - 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "current_pair = (possible_lengths[i], possible_lengths[i + 1])",
      "mutated_line": "current_pair = (possible_lengths[i], possible_lengths[i * 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i * 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])",
      "mutated_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index - 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index - 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])",
      "mutated_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index * 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index * 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] - current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] - current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] * current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] * current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 3 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 3 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 1 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 1 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 0 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 0 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 1 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 1 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** -2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** -2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] - min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] - min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] * min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] * min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 3 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 3 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 1 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 1 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 0 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 0 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 1 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 1 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** -2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** -2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 2], possible_lengths[min_index + 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 2], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 0], possible_lengths[min_index + 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 0], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 0], possible_lengths[min_index + 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 0], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + -1], possible_lengths[min_index + 1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + -1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 2])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 2])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 0])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 0])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])",
      "mutated_line": "return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + -1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + -1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "current_pair = (possible_lengths[i], possible_lengths[i + 1])",
      "mutated_line": "current_pair = (possible_lengths[i], possible_lengths[i + 2])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 2])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "current_pair = (possible_lengths[i], possible_lengths[i + 1])",
      "mutated_line": "current_pair = (possible_lengths[i], possible_lengths[i + 0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 0])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "current_pair = (possible_lengths[i], possible_lengths[i + 1])",
      "mutated_line": "current_pair = (possible_lengths[i], possible_lengths[i + 0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 0])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "current_pair = (possible_lengths[i], possible_lengths[i + 1])",
      "mutated_line": "current_pair = (possible_lengths[i], possible_lengths[i + -1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + -1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])",
      "mutated_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 2])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 2])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])",
      "mutated_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 0])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])",
      "mutated_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 0])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])",
      "mutated_line": "min_pair = (possible_lengths[min_index], possible_lengths[min_index + -1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + -1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[1] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[1] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[-1] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[-1] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[1] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[1] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[2])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[2])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[0])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[0])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[-1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[-1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[1] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[1] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[-1] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[-1] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[1] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[1] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[2])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[2])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[0])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[0])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[0])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[-1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[-1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[1] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[1] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[-1] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[-1] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[1] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[1] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[2]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[2]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[0]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[0]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[0]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[0]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])",
      "mutated_line": "current_value = (current_pair[0] + current_pair[-1]) ** 2 / (current_pair[0] * current_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[-1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[1] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[1] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[-1] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[-1] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[1] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[1] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[2]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[2]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[0]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[0]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[0]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[0]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "min_value = (min_pair[0] + min_pair[1]) ** 2 / (min_pair[0] * min_pair[1])",
      "mutated_line": "min_value = (min_pair[0] + min_pair[-1]) ** 2 / (min_pair[0] * min_pair[1])",
      "code": "def find_minimal_rectangle_sticks(sticks):\n    if len(set(sticks)) == 1:\n        return (sticks[0], sticks[0], sticks[0], sticks[0])\n    sticks.sort()\n    stick_count = {}\n    for stick in sticks:\n        if stick in stick_count:\n            stick_count[stick] += 1\n        else:\n            stick_count[stick] = 1\n    for length in stick_count:\n        if stick_count[length] >= 4:\n            return (length, length, length, length)\n    possible_lengths = [length for length in stick_count if stick_count[length] >= 2]\n    min_index = 0\n    for i in range(len(possible_lengths) - 1):\n        current_pair = (possible_lengths[i], possible_lengths[i + 1])\n        min_pair = (possible_lengths[min_index], possible_lengths[min_index + 1])\n        current_value = (current_pair[0] + current_pair[1]) ** 2 / (current_pair[0] * current_pair[1])\n        min_value = (min_pair[0] + min_pair[-1]) ** 2 / (min_pair[0] * min_pair[1])\n        if current_value < min_value:\n            min_index = i\n    return (possible_lengths[min_index], possible_lengths[min_index], possible_lengths[min_index + 1], possible_lengths[min_index + 1])"
    }
  ]
}