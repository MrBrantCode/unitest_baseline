{
  "task_id": "taco_14357",
  "entry_point": "maximize_surprise_value",
  "mutant_count": 89,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "b = -1",
      "mutated_line": "b = +1",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = +1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = -1",
      "mutated_line": "b = -2",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -2\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = -1",
      "mutated_line": "b = -0",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -0\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = -1",
      "mutated_line": "b = -0",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -0\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = -1",
      "mutated_line": "b = --1",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = --1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] / (n + 1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] / (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] + (n + 1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] + (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] ** (n + 1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] ** (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "v = [0] * m",
      "mutated_line": "v = [0] / m",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] / m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "v = [0] * m",
      "mutated_line": "v = [0] + m",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] + m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "v = [0] * m",
      "mutated_line": "v = [0] ** m",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] ** m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "c[v[j]] += 1",
      "mutated_line": "c[v[j]] -= 1",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] -= 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "d[v[j]] += 1",
      "mutated_line": "d[v[j]] -= 1",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] -= 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) - sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) - sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = (2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points)) * sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = (2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points)) * sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if T > b:",
      "mutated_line": "(b, p) = (T, P)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T >= b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if T > b:",
      "mutated_line": "(b, p) = (T, P)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T <= b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if T > b:",
      "mutated_line": "(b, p) = (T, P)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T != b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "o = [bin(i).count('1') for i in range(1 << n)]",
      "mutated_line": "o = [bin(i).count('') for i in range(1 << n)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1 << n):",
      "mutated_line": "for i in range(2 << n):",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(2 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1 << n):",
      "mutated_line": "for i in range(0 << n):",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(0 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1 << n):",
      "mutated_line": "for i in range(0 << n):",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(0 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1 << n):",
      "mutated_line": "for i in range(-1 << n):",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(-1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] * (n - 1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n - 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] * (n * 1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n * 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c[v[j]] += 1",
      "mutated_line": "c[v[j]] += 2",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 2\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c[v[j]] += 1",
      "mutated_line": "c[v[j]] += 0",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 0\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c[v[j]] += 1",
      "mutated_line": "c[v[j]] += 0",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 0\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c[v[j]] += 1",
      "mutated_line": "c[v[j]] += -1",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += -1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d[j + 1] = d[j] + c[j]",
      "mutated_line": "d[j + 1] = d[j] - c[j]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] - c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d[j + 1] = d[j] + c[j]",
      "mutated_line": "d[j + 1] = d[j] * c[j]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] * c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d[v[j]] += 1",
      "mutated_line": "d[v[j]] += 2",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 2\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d[v[j]] += 1",
      "mutated_line": "d[v[j]] += 0",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 0\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d[v[j]] += 1",
      "mutated_line": "d[v[j]] += 0",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 0\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d[v[j]] += 1",
      "mutated_line": "d[v[j]] += -1",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += -1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) + sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) + sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) * sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) * sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [1] * (n + 1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [1] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [-1] * (n + 1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [-1] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [1] * (n + 1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [1] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] * (n + 2)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 2)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] * (n + 0)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 0)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] * (n + 0)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 0)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c = [0] * (n + 1)",
      "mutated_line": "c = [0] * (n + -1)",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + -1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "v = [0] * m",
      "mutated_line": "v = [1] * m",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [1] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "v = [0] * m",
      "mutated_line": "v = [-1] * m",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [-1] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "v = [0] * m",
      "mutated_line": "v = [1] * m",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [1] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "v[j] = o[i ^ q[j]]",
      "mutated_line": "v[j] = o[i | q[j]]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i | q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d[j + 1] = d[j] + c[j]",
      "mutated_line": "d[j - 1] = d[j] + c[j]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j - 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d[j + 1] = d[j] + c[j]",
      "mutated_line": "d[j * 1] = d[j] + c[j]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j * 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 / sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 / sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 + sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 + sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 ** sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 ** sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "o = [bin(i).count('1') for i in range(1 << n)]",
      "mutated_line": "o = [bin(i).count('1') for i in range(2 << n)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(2 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "o = [bin(i).count('1') for i in range(1 << n)]",
      "mutated_line": "o = [bin(i).count('1') for i in range(0 << n)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(0 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "o = [bin(i).count('1') for i in range(1 << n)]",
      "mutated_line": "o = [bin(i).count('1') for i in range(0 << n)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(0 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "o = [bin(i).count('1') for i in range(1 << n)]",
      "mutated_line": "o = [bin(i).count('1') for i in range(-1 << n)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(-1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]",
      "mutated_line": "q = [sum((2 << i for i in range(n) if M[i][j])) for j in range(m)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((2 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]",
      "mutated_line": "q = [sum((0 << i for i in range(n) if M[i][j])) for j in range(m)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((0 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]",
      "mutated_line": "q = [sum((0 << i for i in range(n) if M[i][j])) for j in range(m)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((0 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]",
      "mutated_line": "q = [sum((-1 << i for i in range(n) if M[i][j])) for j in range(m)]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((-1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d[j + 1] = d[j] + c[j]",
      "mutated_line": "d[j + 2] = d[j] + c[j]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 2] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d[j + 1] = d[j] + c[j]",
      "mutated_line": "d[j + 0] = d[j] + c[j]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 0] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d[j + 1] = d[j] + c[j]",
      "mutated_line": "d[j + 0] = d[j] + c[j]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 0] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d[j + 1] = d[j] + c[j]",
      "mutated_line": "d[j + -1] = d[j] + c[j]",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + -1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 3 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 3 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 1 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 1 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 0 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 0 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 1 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 1 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = -2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = -2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) / P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) / P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum((o[q[j]] - 2 * o[i & q[j]] + P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum((o[q[j]] - 2 * o[i & q[j]] + P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) ** P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) ** P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] + 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] + 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum((o[q[j]] * (2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum((o[q[j]] * (2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 / o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 / o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - (2 + o[i & q[j]])) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - (2 + o[i & q[j]])) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 ** o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 ** o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j | 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j | 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 3 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 3 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 1 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 1 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 0 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 0 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 1 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 1 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - -2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - -2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 2)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 2)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 0)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 0)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 0)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 0)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & -1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & -1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i & q[j]]) * P[j] for j in range(m)))",
      "mutated_line": "T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i | q[j]]) * P[j] for j in range(m)))",
      "code": "def maximize_surprise_value(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, m, expected_points, correct_answers) = case\n        M = [list(map(int, list(answers))) for answers in correct_answers]\n        o = [bin(i).count('1') for i in range(1 << n)]\n        q = [sum((1 << i for i in range(n) if M[i][j])) for j in range(m)]\n        b = -1\n        for i in range(1 << n):\n            c = [0] * (n + 1)\n            v = [0] * m\n            d = c[:]\n            P = v[:]\n            for j in range(m):\n                v[j] = o[i ^ q[j]]\n                c[v[j]] += 1\n            for j in range(n):\n                d[j + 1] = d[j] + c[j]\n            for j in range(m):\n                d[v[j]] += 1\n                P[j] = d[v[j]]\n            T = 2 * sum((expected_points[j] for j in range(n) if i >> j & 1)) - sum(expected_points) + sum(((o[q[j]] - 2 * o[i | q[j]]) * P[j] for j in range(m)))\n            if T > b:\n                (b, p) = (T, P)\n        results.append(p)\n    return results"
    }
  ]
}