{
  "task_id": "taco_11946",
  "entry_point": "sieve_primes",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 - int(n ** 0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 - int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 * int(n ** 0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 * int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) - 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) - 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) * 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) * 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime_indexes[0] = 2",
      "mutated_line": "prime_indexes[0] = 3",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 3\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime_indexes[0] = 2",
      "mutated_line": "prime_indexes[0] = 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 1\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime_indexes[0] = 2",
      "mutated_line": "prime_indexes[0] = 0",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 0\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime_indexes[0] = 2",
      "mutated_line": "prime_indexes[0] = 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 1\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime_indexes[0] = 2",
      "mutated_line": "prime_indexes[0] = -2",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = -2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(10 * 6)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 * 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(10 + 6)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 + 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if int(s) < 10:",
      "mutated_line": "if int(s) <= 10:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) <= 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if int(s) < 10:",
      "mutated_line": "if int(s) >= 10:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) >= 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if int(s) < 10:",
      "mutated_line": "if int(s) != 10:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) != 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return True\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "sieve = np.ones(n // 2, dtype=np.bool)",
      "mutated_line": "sieve = np.ones(n / 2, dtype=np.bool)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n / 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "sieve = np.ones(n // 2, dtype=np.bool)",
      "mutated_line": "sieve = np.ones(n * 2, dtype=np.bool)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n * 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 2 + int(n ** 0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 2 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 0 + int(n ** 0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 0 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 0 + int(n ** 0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 0 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = -1 + int(n ** 0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = -1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(4, limit, 2):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(4, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(2, limit, 2):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(2, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(0, limit, 2):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(0, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(1, limit, 2):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(1, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(-3, limit, 2):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(-3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(3, limit, 3):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 3):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(3, limit, 1):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 1):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(3, limit, 0):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 0):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(3, limit, 1):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 1):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for a in range(3, limit, 2):",
      "mutated_line": "for a in range(3, limit, -2):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, -2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 / np.nonzero(sieve)[0].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 / np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 + np.nonzero(sieve)[0].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 + np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 ** np.nonzero(sieve)[0].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 ** np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 2",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 2\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 0",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 0\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 0",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 0\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + -1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + -1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime_indexes[0] = 2",
      "mutated_line": "prime_indexes[1] = 2",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[1] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime_indexes[0] = 2",
      "mutated_line": "prime_indexes[-1] = 2",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[-1] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime_indexes[0] = 2",
      "mutated_line": "prime_indexes[1] = 2",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[1] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(11 ** 6)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(11 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(9 ** 6)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(9 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(0 ** 6)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(0 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(1 ** 6)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(1 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(-10 ** 6)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(-10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(10 ** 7)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 7)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(10 ** 5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 5)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(10 ** 0)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 0)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(10 ** 1)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 1)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "PRIMES = sieve_primes(10 ** 6)",
      "mutated_line": "PRIMES = sieve_primes(10 ** -6)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** -6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if int(s) < 10:",
      "mutated_line": "if int(s) < 11:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 11:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if int(s) < 10:",
      "mutated_line": "if int(s) < 9:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 9:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if int(s) < 10:",
      "mutated_line": "if int(s) < 0:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 0:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if int(s) < 10:",
      "mutated_line": "if int(s) < 1:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 1:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if int(s) < 10:",
      "mutated_line": "if int(s) < -10:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < -10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "return s in PRIMES",
      "mutated_line": "return s not in PRIMES",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s not in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if n in PRIMES:",
      "mutated_line": "if n not in PRIMES:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n not in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sieve = np.ones(n // 2, dtype=np.bool)",
      "mutated_line": "sieve = np.ones(n // 3, dtype=np.bool)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 3, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sieve = np.ones(n // 2, dtype=np.bool)",
      "mutated_line": "sieve = np.ones(n // 1, dtype=np.bool)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 1, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sieve = np.ones(n // 2, dtype=np.bool)",
      "mutated_line": "sieve = np.ones(n // 0, dtype=np.bool)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 0, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sieve = np.ones(n // 2, dtype=np.bool)",
      "mutated_line": "sieve = np.ones(n // 1, dtype=np.bool)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 1, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sieve = np.ones(n // 2, dtype=np.bool)",
      "mutated_line": "sieve = np.ones(n // -2, dtype=np.bool)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // -2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 + int(n * 0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n * 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 + int(n + 0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n + 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if sieve[a // 2]:",
      "mutated_line": "if sieve[a / 2]:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a / 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if sieve[a // 2]:",
      "mutated_line": "if sieve[a * 2]:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a * 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a * a // 2::a] = True",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = True\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 3 * np.nonzero(sieve)[0].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 3 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 1 * np.nonzero(sieve)[0].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 1 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 0 * np.nonzero(sieve)[0].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 0 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 1 * np.nonzero(sieve)[0].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 1 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = -2 * np.nonzero(sieve)[0].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = -2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if m in PRIMES or all_primes(m):",
      "mutated_line": "if m in PRIMES and all_primes(m):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES and all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES or all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES or all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 + int(n ** 1.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 1.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 + int(n ** -0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** -0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 + int(n ** 0)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 + int(n ** 1)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 1)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "limit = 1 + int(n ** 0.5)",
      "mutated_line": "limit = 1 + int(n ** -0.5)",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** -0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sieve[a // 2]:",
      "mutated_line": "if sieve[a // 3]:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 3]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sieve[a // 2]:",
      "mutated_line": "if sieve[a // 1]:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 1]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sieve[a // 2]:",
      "mutated_line": "if sieve[a // 0]:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 0]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sieve[a // 2]:",
      "mutated_line": "if sieve[a // 1]:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 1]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sieve[a // 2]:",
      "mutated_line": "if sieve[a // -2]:",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // -2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for n in accumulate(s[:-1]):",
      "mutated_line": "for n in accumulate(s[:+1]):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:+1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if m in PRIMES or all_primes(m):",
      "mutated_line": "if m not in PRIMES or all_primes(m):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m not in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return False\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num not in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num not in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a * a / 2::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a / 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a * a * 2::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a * 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in accumulate(s[:-1]):",
      "mutated_line": "for n in accumulate(s[:-2]):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-2]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in accumulate(s[:-1]):",
      "mutated_line": "for n in accumulate(s[:-0]):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-0]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in accumulate(s[:-1]):",
      "mutated_line": "for n in accumulate(s[:-0]):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-0]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in accumulate(s[:-1]):",
      "mutated_line": "for n in accumulate(s[:--1]):",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:--1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(10, a), b - 1)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b - 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(10, a), b * 1)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b * 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a / a // 2::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a / a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[(a + a) // 2::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[(a + a) // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a ** a // 2::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a ** a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a * a // 3::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 3::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a * a // 1::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 1::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a * a // 0::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 0::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a * a // 1::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 1::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sieve[a * a // 2::a] = False",
      "mutated_line": "sieve[a * a // -2::a] = False",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // -2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[1].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[1].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[-1].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[-1].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1",
      "mutated_line": "prime_indexes = 2 * np.nonzero(sieve)[1].astype(int) + 1",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[1].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(11, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(11, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(9, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(9, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(0, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(0, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(1, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(1, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(-10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(-10, a), b + 1)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(10, a), b + 2)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 2)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(10, a), b + 0)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 0)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(10, a), b + 0)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + 0)) if num in PRIMES and all_primes(num)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [int(num) for num in map(str, range(max(10, a), b + 1)) if num in PRIMES and all_primes(num)]",
      "mutated_line": "return [int(num) for num in map(str, range(max(10, a), b + -1)) if num in PRIMES and all_primes(num)]",
      "code": "import numpy as np\nfrom itertools import accumulate\n\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype=np.bool)\n    limit = 1 + int(n ** 0.5)\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\nPRIMES = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in PRIMES\n    for n in accumulate(s[:-1]):\n        if n in PRIMES:\n            m = s[len(n):]\n            if m in PRIMES or all_primes(m):\n                return True\n    return False\n\ndef find_total_primes_in_range(a, b):\n    return [int(num) for num in map(str, range(max(10, a), b + -1)) if num in PRIMES and all_primes(num)]"
    }
  ]
}