{
  "task_id": "taco_13526",
  "entry_point": "find_earliest_collision_time",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if self.dir == 'U':",
      "mutated_line": "if self.dir != 'U':",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir != 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "self.y += time",
      "mutated_line": "self.y -= time",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y -= time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = dist_x + dist_y",
      "mutated_line": "dist = dist_x - dist_y",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x - dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = dist_x + dist_y",
      "mutated_line": "dist = dist_x * dist_y",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x * dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cur_dist = cur_dist_x + cur_dist_y",
      "mutated_line": "cur_dist = cur_dist_x - cur_dist_y",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x - cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cur_dist = cur_dist_x + cur_dist_y",
      "mutated_line": "cur_dist = cur_dist_x * cur_dist_y",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x * cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if cur_dist < dist and (self.x == other.x or self.y == other.y):",
      "mutated_line": "if cur_dist < dist or (self.x == other.x or self.y == other.y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist or (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if earliest_time == sys.float_info.max:",
      "mutated_line": "if earliest_time != sys.float_info.max:",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time != sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if self.dir == 'U':",
      "mutated_line": "if self.dir == '':",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == '':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif self.dir == 'D':",
      "mutated_line": "elif self.dir != 'D':",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir != 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "self.y -= time",
      "mutated_line": "self.y += time",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y += time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dist_x = abs(self.x - other.x)",
      "mutated_line": "dist_x = abs(self.x + other.x)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x + other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dist_x = abs(self.x - other.x)",
      "mutated_line": "dist_x = abs(self.x * other.x)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x * other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist_y = abs(self.y - other.y)",
      "mutated_line": "dist_y = abs(self.y + other.y)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y + other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist_y = abs(self.y - other.y)",
      "mutated_line": "dist_y = abs(self.y * other.y)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y * other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.simulate(0.5)",
      "mutated_line": "self.simulate(1.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(1.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.simulate(0.5)",
      "mutated_line": "self.simulate(-0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(-0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.simulate(0.5)",
      "mutated_line": "self.simulate(0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.simulate(0.5)",
      "mutated_line": "self.simulate(1)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(1)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.simulate(0.5)",
      "mutated_line": "self.simulate(-0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(-0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "other.simulate(0.5)",
      "mutated_line": "other.simulate(1.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(1.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "other.simulate(0.5)",
      "mutated_line": "other.simulate(-0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(-0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "other.simulate(0.5)",
      "mutated_line": "other.simulate(0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "other.simulate(0.5)",
      "mutated_line": "other.simulate(1)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(1)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "other.simulate(0.5)",
      "mutated_line": "other.simulate(-0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(-0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur_dist_x = abs(self.x - other.x)",
      "mutated_line": "cur_dist_x = abs(self.x + other.x)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x + other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur_dist_x = abs(self.x - other.x)",
      "mutated_line": "cur_dist_x = abs(self.x * other.x)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x * other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cur_dist_y = abs(self.y - other.y)",
      "mutated_line": "cur_dist_y = abs(self.y + other.y)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y + other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cur_dist_y = abs(self.y - other.y)",
      "mutated_line": "cur_dist_y = abs(self.y * other.y)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y * other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "self.simulate(-0.5)",
      "mutated_line": "self.simulate(+0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(+0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "other.simulate(-0.5)",
      "mutated_line": "other.simulate(+0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(+0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cur_dist < dist and (self.x == other.x or self.y == other.y):",
      "mutated_line": "if cur_dist <= dist and (self.x == other.x or self.y == other.y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist <= dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cur_dist < dist and (self.x == other.x or self.y == other.y):",
      "mutated_line": "if cur_dist >= dist and (self.x == other.x or self.y == other.y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist >= dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cur_dist < dist and (self.x == other.x or self.y == other.y):",
      "mutated_line": "if cur_dist != dist and (self.x == other.x or self.y == other.y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist != dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if cur_dist < dist and (self.x == other.x or self.y == other.y):",
      "mutated_line": "if cur_dist < dist and (self.x == other.x and self.y == other.y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x and self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x == dist_y or (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y or (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif self.dir == 'D':",
      "mutated_line": "elif self.dir == '':",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == '':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif self.dir == 'L':",
      "mutated_line": "elif self.dir != 'L':",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir != 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "self.x -= time",
      "mutated_line": "self.x += time",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x += time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "self.simulate(-0.5)",
      "mutated_line": "self.simulate(-1.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-1.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "self.simulate(-0.5)",
      "mutated_line": "self.simulate(--0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(--0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "self.simulate(-0.5)",
      "mutated_line": "self.simulate(-0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "self.simulate(-0.5)",
      "mutated_line": "self.simulate(-1)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-1)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "self.simulate(-0.5)",
      "mutated_line": "self.simulate(--0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(--0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "other.simulate(-0.5)",
      "mutated_line": "other.simulate(-1.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-1.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "other.simulate(-0.5)",
      "mutated_line": "other.simulate(--0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(--0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "other.simulate(-0.5)",
      "mutated_line": "other.simulate(-0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "other.simulate(-0.5)",
      "mutated_line": "other.simulate(-1)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-1)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "other.simulate(-0.5)",
      "mutated_line": "other.simulate(--0.5)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(--0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cur_dist < dist and (self.x == other.x or self.y == other.y):",
      "mutated_line": "if cur_dist < dist and (self.x != other.x or self.y == other.y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x != other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cur_dist < dist and (self.x == other.x or self.y == other.y):",
      "mutated_line": "if cur_dist < dist and (self.x == other.x or self.y != other.y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y != other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x * 2.0, dist_y / 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x * 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x // 2.0, dist_y / 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x // 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 2.0, dist_y * 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y * 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 2.0, dist_y // 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y // 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x != dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x != dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x == dist_y and (cur_dist_x < dist_x or cur_dist_y < dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x or cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "earth = Entity(earth_position[0], earth_position[1], earth_direction)",
      "mutated_line": "earth = Entity(earth_position[1], earth_position[1], earth_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[1], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "earth = Entity(earth_position[0], earth_position[1], earth_direction)",
      "mutated_line": "earth = Entity(earth_position[-1], earth_position[1], earth_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[-1], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "earth = Entity(earth_position[0], earth_position[1], earth_direction)",
      "mutated_line": "earth = Entity(earth_position[1], earth_position[1], earth_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[1], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "earth = Entity(earth_position[0], earth_position[1], earth_direction)",
      "mutated_line": "earth = Entity(earth_position[0], earth_position[2], earth_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[2], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "earth = Entity(earth_position[0], earth_position[1], earth_direction)",
      "mutated_line": "earth = Entity(earth_position[0], earth_position[0], earth_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[0], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "earth = Entity(earth_position[0], earth_position[1], earth_direction)",
      "mutated_line": "earth = Entity(earth_position[0], earth_position[0], earth_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[0], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "earth = Entity(earth_position[0], earth_position[1], earth_direction)",
      "mutated_line": "earth = Entity(earth_position[0], earth_position[-1], earth_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[-1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "results.append('SAFE')",
      "mutated_line": "results.append('')",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "results.append('%.1f' % earliest_time)",
      "mutated_line": "results.append('%.1f' * earliest_time)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' * earliest_time)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "results.append('%.1f' % earliest_time)",
      "mutated_line": "results.append('%.1f' + earliest_time)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' + earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif self.dir == 'L':",
      "mutated_line": "elif self.dir == '':",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == '':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif self.dir == 'R':",
      "mutated_line": "elif self.dir != 'R':",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir != 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "self.x += time",
      "mutated_line": "self.x -= time",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x -= time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 3.0, dist_y / 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 3.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 1.0, dist_y / 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 1.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 0, dist_y / 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 1, dist_y / 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 1, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / -2.0, dist_y / 2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / -2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 2.0, dist_y / 3.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 3.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 2.0, dist_y / 1.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 1.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 2.0, dist_y / 0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 2.0, dist_y / 1)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 1)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return max(dist_x / 2.0, dist_y / 2.0)",
      "mutated_line": "return max(dist_x / 2.0, dist_y / -2.0)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / -2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x == dist_y and (cur_dist_x <= dist_x and cur_dist_y < dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x <= dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x == dist_y and (cur_dist_x >= dist_x and cur_dist_y < dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x >= dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x == dist_y and (cur_dist_x != dist_x and cur_dist_y < dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x != dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y <= dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y <= dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y >= dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y >= dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):",
      "mutated_line": "elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y != dist_y):",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y != dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)",
      "mutated_line": "asteroid = Entity(asteroid_position[1], asteroid_position[1], asteroid_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[1], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)",
      "mutated_line": "asteroid = Entity(asteroid_position[-1], asteroid_position[1], asteroid_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[-1], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)",
      "mutated_line": "asteroid = Entity(asteroid_position[1], asteroid_position[1], asteroid_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[1], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)",
      "mutated_line": "asteroid = Entity(asteroid_position[0], asteroid_position[2], asteroid_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[2], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)",
      "mutated_line": "asteroid = Entity(asteroid_position[0], asteroid_position[0], asteroid_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[0], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)",
      "mutated_line": "asteroid = Entity(asteroid_position[0], asteroid_position[0], asteroid_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[0], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)",
      "mutated_line": "asteroid = Entity(asteroid_position[0], asteroid_position[-1], asteroid_direction)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[-1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append('%.1f' % earliest_time)",
      "mutated_line": "results.append('' % earliest_time)",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('' % earliest_time)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif self.dir == 'R':",
      "mutated_line": "elif self.dir == '':",
      "code": "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == '':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\n\ndef find_earliest_collision_time(T, test_cases):\n    results = []\n    for t in range(T):\n        (earth_position, earth_direction, asteroids) = test_cases[t]\n        earth = Entity(earth_position[0], earth_position[1], earth_direction)\n        earliest_time = sys.float_info.max\n        for (asteroid_position, asteroid_direction) in asteroids:\n            asteroid = Entity(asteroid_position[0], asteroid_position[1], asteroid_direction)\n            earliest_time = min(earliest_time, earth.collision_time(asteroid))\n        if earliest_time == sys.float_info.max:\n            results.append('SAFE')\n        else:\n            results.append('%.1f' % earliest_time)\n    return results"
    }
  ]
}