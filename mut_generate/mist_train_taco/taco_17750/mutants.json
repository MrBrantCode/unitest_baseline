{
  "task_id": "taco_17750",
  "entry_point": "count_exponential_palindromes",
  "mutant_count": 162,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 1\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = -1\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 1\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 or num & num - 1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 or num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if len(a) == 0:",
      "mutated_line": "if len(a) != 0:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) != 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s != s[::-1]:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s != s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count -= 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(2 ** n):",
      "mutated_line": "for i in range(2 * n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 * n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(2 ** n):",
      "mutated_line": "for i in range(2 + n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 + n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num == 0 and num & num - 1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num == 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num - 1 != 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 != 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(a) == 0:",
      "mutated_line": "if len(a) == 1:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 1:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(a) == 0:",
      "mutated_line": "if len(a) == -1:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == -1:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(a) == 0:",
      "mutated_line": "if len(a) == 1:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 1:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return False\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][1] * a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] * a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][1] // a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] // a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 1 and int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 and int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return False\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(2, len(S) + 1)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(2, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(0, len(S) + 1)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(0, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(0, len(S) + 1)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(0, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(-1, len(S) + 1)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(-1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(1, len(S) - 1)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) - 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(1, len(S) * 1)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) * 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 2\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += -1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "masks = [1 << j for j in range(n)]",
      "mutated_line": "masks = [2 << j for j in range(n)]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [2 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "masks = [1 << j for j in range(n)]",
      "mutated_line": "masks = [0 << j for j in range(n)]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [0 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "masks = [1 << j for j in range(n)]",
      "mutated_line": "masks = [0 << j for j in range(n)]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [0 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "masks = [1 << j for j in range(n)]",
      "mutated_line": "masks = [-1 << j for j in range(n)]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [-1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2 ** n):",
      "mutated_line": "for i in range(3 ** n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(3 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2 ** n):",
      "mutated_line": "for i in range(1 ** n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(1 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2 ** n):",
      "mutated_line": "for i in range(0 ** n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(0 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2 ** n):",
      "mutated_line": "for i in range(1 ** n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(1 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2 ** n):",
      "mutated_line": "for i in range(-2 ** n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(-2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 1 and num & num - 1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 1 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != -1 and num & num - 1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != -1 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 1 and num & num - 1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 1 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num | num - 1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num | num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num - 1 == 1",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 1\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num - 1 == -1",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == -1\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num - 1 == 1",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 1\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lis = [i + 1]",
      "mutated_line": "lis = [i - 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i - 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lis = [i + 1]",
      "mutated_line": "lis = [i * 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i * 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i - 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i * 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = l[j] / l[i]",
      "mutated_line": "p = l[j] * l[i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] * l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = l[j] / l[i]",
      "mutated_line": "p = l[j] // l[i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] // l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 1 and int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 and int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = (j + 1) / int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) / int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = j + 1 + int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = j + 1 + int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = (j + 1) ** int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) ** int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while sk <= n:",
      "mutated_line": "while sk < n:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk < n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while sk <= n:",
      "mutated_line": "while sk > n:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk > n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while sk <= n:",
      "mutated_line": "while sk == n:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk == n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "sk *= int(p)",
      "mutated_line": "sk /= int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk /= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p < 1 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p < 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p > 1 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p > 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p == 1 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p == 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 1 or int(p) == p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) == p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return True\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(2, len(a)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(2, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(0, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(0, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(-1, len(a)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(-1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][1] / a[i][0] == p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] == p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(1, len(S) + 2)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 2)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(1, len(S) + 0)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 0)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(1, len(S) + 0)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 0)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in special(range(1, len(S) + 1)):",
      "mutated_line": "for i in special(range(1, len(S) + -1)):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + -1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "s = [S[j - 1] for j in i]",
      "mutated_line": "s = [S[j + 1] for j in i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j + 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "s = [S[j - 1] for j in i]",
      "mutated_line": "s = [S[j * 1] for j in i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j * 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "yield [j + 1 for j in range(n) if masks[j] & i]",
      "mutated_line": "yield [j - 1 for j in range(n) if masks[j] & i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j - 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "yield [j + 1 for j in range(n) if masks[j] & i]",
      "mutated_line": "yield [j * 1 for j in range(n) if masks[j] & i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j * 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num + 1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num + 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num * 1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num * 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lis = [i + 1]",
      "mutated_line": "lis = [i + 2]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 2]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lis = [i + 1]",
      "mutated_line": "lis = [i + 0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 0]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lis = [i + 1]",
      "mutated_line": "lis = [i + 0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 0]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lis = [i + 1]",
      "mutated_line": "lis = [i + -1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + -1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 2, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 0, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 0, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + -1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p < 1 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p < 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p > 1 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p > 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p == 1 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p == 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 1 or int(p) == p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) == p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i - 1, j + 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i - 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i * 1, j + 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i * 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 1, j - 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j - 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 1, j * 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j * 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = (j - 1) * int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j - 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = j * 1 * int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = j * 1 * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][2] / a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][2] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][0] / a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][0] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][0] / a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][0] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][-1] / a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][-1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][1] / a[0][1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][1]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][1] / a[0][-1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][-1]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][1] / a[0][1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][1]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 2 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 2 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 0 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 0 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 0 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 0 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= -1 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= -1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][1] * a[i][0] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] * a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][1] // a[i][0] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] // a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return True\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "s = [S[j - 1] for j in i]",
      "mutated_line": "s = [S[j - 2] for j in i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 2] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "s = [S[j - 1] for j in i]",
      "mutated_line": "s = [S[j - 0] for j in i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 0] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "s = [S[j - 1] for j in i]",
      "mutated_line": "s = [S[j - 0] for j in i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 0] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "s = [S[j - 1] for j in i]",
      "mutated_line": "s = [S[j - -1] for j in i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - -1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::+1]:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::+1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "yield [j + 1 for j in range(n) if masks[j] & i]",
      "mutated_line": "yield [j + 2 for j in range(n) if masks[j] & i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 2 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "yield [j + 1 for j in range(n) if masks[j] & i]",
      "mutated_line": "yield [j + 0 for j in range(n) if masks[j] & i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 0 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "yield [j + 1 for j in range(n) if masks[j] & i]",
      "mutated_line": "yield [j + 0 for j in range(n) if masks[j] & i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 0 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "yield [j + 1 for j in range(n) if masks[j] & i]",
      "mutated_line": "yield [j + -1 for j in range(n) if masks[j] & i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + -1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "yield [j + 1 for j in range(n) if masks[j] & i]",
      "mutated_line": "yield [j + 1 for j in range(n) if masks[j] | i]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] | i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num - 2 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 2 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num - 0 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 0 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num - 0 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 0 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return num != 0 and num & num - 1 == 0",
      "mutated_line": "return num != 0 and num & num - -1 == 0",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - -1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 2 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 2 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 0 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 0 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= 0 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 0 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if p <= 1 or int(p) != p:",
      "mutated_line": "if p <= -1 or int(p) != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= -1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 2, j + 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 2, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 0, j + 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 0, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 0, j + 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 0, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + -1, j + 1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + -1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 1, j + 2]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 2]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 1, j + 0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 0]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 1, j + 0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 0]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "lis = [i + 1, j + 1]",
      "mutated_line": "lis = [i + 1, j + -1]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + -1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = (j + 2) * int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 2) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = (j + 0) * int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 0) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = (j + 0) * int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 0) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sk = (j + 1) * int(p)",
      "mutated_line": "sk = (j + -1) * int(p)",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + -1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = list(zip(l, l[1:]))",
      "mutated_line": "a = list(zip(l, l[2:]))",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[2:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = list(zip(l, l[1:]))",
      "mutated_line": "a = list(zip(l, l[0:]))",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[0:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = list(zip(l, l[1:]))",
      "mutated_line": "a = list(zip(l, l[0:]))",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[0:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = list(zip(l, l[1:]))",
      "mutated_line": "a = list(zip(l, l[-1:]))",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[-1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[1][1] / a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[1][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[-1][1] / a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[-1][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[1][1] / a[0][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[1][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][1] / a[1][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[1][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][1] / a[-1][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[-1][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p = a[0][1] / a[0][0]",
      "mutated_line": "p = a[0][1] / a[1][0]",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[1][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::-2]:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-2]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::-0]:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-0]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::-0]:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-0]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::--1]:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::--1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][2] / a[i][0] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][2] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][0] / a[i][0] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][0] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][0] / a[i][0] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][0] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][-1] / a[i][0] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][-1] / a[i][0] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][1] / a[i][1] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][1] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][1] / a[i][-1] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][-1] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a[i][1] / a[i][0] != p:",
      "mutated_line": "if a[i][1] / a[i][1] != p:",
      "code": "def count_exponential_palindromes(S: str) -> int:\n\n    def powerset(s):\n        n = len(s)\n        masks = [1 << j for j in range(n)]\n        for i in range(2 ** n):\n            yield [j + 1 for j in range(n) if masks[j] & i]\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n\n    def special(l):\n        n = len(l)\n        for i in range(n):\n            lis = [i + 1]\n            yield lis\n            for j in range(i + 1, n):\n                p = l[j] / l[i]\n                if p <= 1 or int(p) != p:\n                    continue\n                lis = [i + 1, j + 1]\n                yield lis\n                sk = (j + 1) * int(p)\n                while sk <= n:\n                    lis.append(sk)\n                    sk *= int(p)\n                    yield lis\n\n    def expIndices(l):\n        a = list(zip(l, l[1:]))\n        if len(a) == 0:\n            return True\n        else:\n            p = a[0][1] / a[0][0]\n            if p <= 1 or int(p) != p:\n                return False\n            for i in range(1, len(a)):\n                if a[i][1] / a[i][1] != p:\n                    return False\n            return True\n    count = 0\n    for i in special(range(1, len(S) + 1)):\n        s = [S[j - 1] for j in i]\n        if s == s[::-1]:\n            count += 1\n    return count"
    }
  ]
}