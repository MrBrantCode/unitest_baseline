{
  "task_id": "taco_9400",
  "entry_point": "determine_winner",
  "mutant_count": 267,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [8] / 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] / 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [8] + 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] + 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [8] ** 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] ** 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 or i < n or j > -1 or (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 or i < n or j > -1 or (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if (step + 1 < 8 and all_boards[step + 1][x][y] == 'S') and (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if (step + 1 < 8 and all_boards[step + 1][x][y] == 'S') and (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return False\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "step += 1",
      "mutated_line": "step -= 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step -= 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 'LOSE'",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return ''\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(2, 9):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(2, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(0, 9):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(0, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(0, 9):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(0, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(-1, 9):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(-1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(1, 10):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 10):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(1, 8):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 8):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(1, 0):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 0):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(1, 1):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 1):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for k in range(1, 9):",
      "mutated_line": "for k in range(1, -9):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, -9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return dfs(0, 0)",
      "mutated_line": "return dfs(1, 0)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return dfs(0, 0)",
      "mutated_line": "return dfs(-1, 0)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return dfs(0, 0)",
      "mutated_line": "return dfs(1, 0)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return dfs(0, 0)",
      "mutated_line": "return dfs(0, 1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return dfs(0, 0)",
      "mutated_line": "return dfs(0, -1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return dfs(0, 0)",
      "mutated_line": "return dfs(0, 1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [8] * 3",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 3\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [8] * 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 1\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [8] * 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 0\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [8] * 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 1\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [8] * -2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * -2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i >= -1 and i < n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i >= -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i <= -1 and i < n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i <= -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i != -1 and i < n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i != -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i <= n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i <= n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i >= n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i >= n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i != n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i != n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j >= -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j >= -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j <= -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j <= -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j != -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j != -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j > -1) and (j <= m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j <= m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j > -1) and (j >= m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j >= m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j > -1) and (j != m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j != m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if (step + 1 < 8 or all_boards[step + 1][x][y] == 'S') or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if (step + 1 < 8 or all_boards[step + 1][x][y] == 'S') or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 or all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 or all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return True\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, -1]], defaultdict(int), +1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), +1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "step += 1",
      "mutated_line": "step += 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 2\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "step += 1",
      "mutated_line": "step += 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 0\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "step += 1",
      "mutated_line": "step += 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 0\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "step += 1",
      "mutated_line": "step += -1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += -1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if board[x][y] == 'A':",
      "mutated_line": "if board[x][y] != 'A':",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] != 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "st = 0",
      "mutated_line": "st = 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 1\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "st = 0",
      "mutated_line": "st = -1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = -1\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "st = 0",
      "mutated_line": "st = 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 1\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if st == 9:",
      "mutated_line": "if st != 9:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st != 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "step -= 1",
      "mutated_line": "step += 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step += 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([1, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([1, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([-1, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([-1, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([1, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([1, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, +1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, +1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 1, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 1, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, -1, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, -1, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 1, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 1, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 2, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 2, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 0, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 0, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 0, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 0, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, -1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, -1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 1, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 1, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, -1, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, -1, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 1, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 1, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 2, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 2, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 0, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 0, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 0, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 0, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, -1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, -1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, +1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, +1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 2, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 2, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 0, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 0, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 0, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 0, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, -1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, -1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, +1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, +1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [1, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [1, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [-1, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [-1, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [1, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [1, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 1, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 1, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, -1, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, -1, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 1, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 1, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 2, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 2, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 0, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 0, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 0, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 0, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, -1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, -1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 1, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 1, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, -1, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, -1, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 1, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 1, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, +1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, +1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 2, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 2, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 0, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 0, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 0, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 0, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, -1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, -1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, +1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, +1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, +1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, +1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 2])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 2])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 0])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 0])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 0])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 0])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, -1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, -1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['' for _ in range(8)] for _ in range(8)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(9):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(9):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(7):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(7):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(0):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(0):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(1):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(1):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(-8):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(-8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [9] * 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [9] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [7] * 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [7] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [0] * 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [0] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [1] * 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [1] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(n, m) = [8] * 2",
      "mutated_line": "(n, m) = [-8] * 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [-8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > +1 and i < n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > +1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j > +1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > +1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 <= 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 <= 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 >= 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 >= 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 != 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 != 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] != 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] != 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step <= 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step <= 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step >= 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step >= 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step != 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step != 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] != 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] != 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, -1]], defaultdict(int), -2)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -2)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, -1]], defaultdict(int), -0)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -0)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, -1]], defaultdict(int), -0)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -0)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, -1]], defaultdict(int), --1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), --1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if board[x][y] == 'A':",
      "mutated_line": "if board[x][y] == '':",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == '':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return 'WIN'",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return ''\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(9):",
      "mutated_line": "for i in range(10):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(10):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(9):",
      "mutated_line": "for i in range(8):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(8):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(9):",
      "mutated_line": "for i in range(0):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(0):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(9):",
      "mutated_line": "for i in range(1):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(1):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(9):",
      "mutated_line": "for i in range(-9):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(-9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i != 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if valid(nx, ny) and check(nx, ny, step) and not visit[nx, ny]:",
      "mutated_line": "if valid(nx, ny) or check(nx, ny, step) or (not visit[nx, ny]):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) or check(nx, ny, step) or (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "st += 1",
      "mutated_line": "st -= 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st -= 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if st == 9:",
      "mutated_line": "if st == 10:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 10:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if st == 9:",
      "mutated_line": "if st == 8:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 8:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if st == 9:",
      "mutated_line": "if st == 0:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 0:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if st == 9:",
      "mutated_line": "if st == 1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 1:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if st == 9:",
      "mutated_line": "if st == -9:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == -9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "step -= 1",
      "mutated_line": "step -= 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 2\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "step -= 1",
      "mutated_line": "step -= 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 0\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "step -= 1",
      "mutated_line": "step -= 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 0\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "step -= 1",
      "mutated_line": "step -= -1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= -1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "visit[x, y] = 0",
      "mutated_line": "visit[x, y] = 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 1\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "visit[x, y] = 0",
      "mutated_line": "visit[x, y] = -1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = -1\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "visit[x, y] = 0",
      "mutated_line": "visit[x, y] = 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 1\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -2, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -2, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -0, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -0, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -0, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -0, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, --1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, --1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -2, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -2, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -0, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -0, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -0, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -0, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, --1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, --1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -2], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -2], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -0], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -0], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -0], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -0], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, --1], [0, 0, 1, 0, -1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, --1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -2, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -2, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -0, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -0, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -0, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -0, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, --1, 1, -1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, --1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -2, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -2, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -0, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -0, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -0, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -0, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, --1, -1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, --1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -2, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -2, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -0, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -0, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -0, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -0, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dx, dy = [0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, --1, 1])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, --1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(8)] for _ in range(9)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(9)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(8)] for _ in range(7)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(7)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(8)] for _ in range(0)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(0)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(8)] for _ in range(1)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(1)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(8)] for _ in range(-8)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(-8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(8):",
      "mutated_line": "for j in range(9):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(9):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(8):",
      "mutated_line": "for j in range(7):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(7):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(8):",
      "mutated_line": "for j in range(0):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(0):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(8):",
      "mutated_line": "for j in range(1):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(1):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for j in range(8):",
      "mutated_line": "for j in range(-8):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(-8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' or i - k > -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' or i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -2 and i < n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -2 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -0 and i < n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -0 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -0 and i < n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -0 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > --1 and i < n and (j > -1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > --1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j > -2) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -2) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j > -0) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -0) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j > -0) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -0) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return i > -1 and i < n and j > -1 and j < m",
      "mutated_line": "return i > -1 and i < n and (j > --1) and (j < m)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > --1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step - 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step - 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step * 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step * 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 9 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 9 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 7 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 7 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 0 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 0 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 1 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 1 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < -8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < -8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == '' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == '' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 9 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 9 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 7 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 7 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 0 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 0 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 1 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 1 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < -8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < -8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == ''):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == ''):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, +1]], defaultdict(int), -1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, +1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x - dx[i], y + dy[i])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x - dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x * dx[i], y + dy[i])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x * dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x + dx[i], y - dy[i])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y - dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x + dx[i], y * dy[i])",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y * dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 1:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == -1:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 1:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if step >= 8:",
      "mutated_line": "if step > 8:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step > 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if step >= 8:",
      "mutated_line": "if step < 8:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step < 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if step >= 8:",
      "mutated_line": "if step == 8:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step == 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "visit[nx, ny] = 1",
      "mutated_line": "visit[nx, ny] = 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 2\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "visit[nx, ny] = 1",
      "mutated_line": "visit[nx, ny] = 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 0\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "visit[nx, ny] = 1",
      "mutated_line": "visit[nx, ny] = 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 0\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "visit[nx, ny] = 1",
      "mutated_line": "visit[nx, ny] = -1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = -1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "st += 1",
      "mutated_line": "st += 2",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 2\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "st += 1",
      "mutated_line": "st += 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 0\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "st += 1",
      "mutated_line": "st += 0",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 0\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "st += 1",
      "mutated_line": "st += -1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += -1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(9)] for _ in range(8)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(9)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(7)] for _ in range(8)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(7)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(0)] for _ in range(8)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(0)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(1)] for _ in range(8)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(1)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ini = [['.' for _ in range(8)] for _ in range(8)]",
      "mutated_line": "ini = [['.' for _ in range(-8)] for _ in range(8)]",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(-8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] != 'S' and i - k > -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] != 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i - k >= -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k >= -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i - k <= -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k <= -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i - k != -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k != -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "tem[i - k][j] = 'S'",
      "mutated_line": "tem[i - k][j] = ''",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = ''\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 2 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 2 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 0 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 0 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 0 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 0 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + -1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + -1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, -2]], defaultdict(int), -1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -2]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, -0]], defaultdict(int), -1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -0]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, -0]], defaultdict(int), -1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -0]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack, visit, step = [[x, y, -1]], defaultdict(int), -1",
      "mutated_line": "(stack, visit, step) = ([[x, y, --1]], defaultdict(int), -1)",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, --1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if step >= 8:",
      "mutated_line": "if step >= 9:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 9:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if step >= 8:",
      "mutated_line": "if step >= 7:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 7:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if step >= 8:",
      "mutated_line": "if step >= 0:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 0:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if step >= 8:",
      "mutated_line": "if step >= 1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 1:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if step >= 8:",
      "mutated_line": "if step >= -8:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= -8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visit[nx, ny] = 0",
      "mutated_line": "visit[nx, ny] = 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 1\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visit[nx, ny] = 0",
      "mutated_line": "visit[nx, ny] = -1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = -1\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visit[nx, ny] = 0",
      "mutated_line": "visit[nx, ny] = 1",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 1\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == '' and i - k > -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == '' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i + k > -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i + k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i * k > -1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i * k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i - k > +1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > +1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i - k > -2:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -2:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i - k > -0:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -0:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i - k > -0:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -0:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if board[i][j] == 'S' and i - k > -1:",
      "mutated_line": "if board[i][j] == 'S' and i - k > --1:",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > --1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tem[i - k][j] = 'S'",
      "mutated_line": "tem[i + k][j] = 'S'",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i + k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "tem[i - k][j] = 'S'",
      "mutated_line": "tem[i * k][j] = 'S'",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i * k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step - 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step - 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step * 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step * 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 2][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 2][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 0][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 0][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + 0][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + 0][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if step + 1 < 8 and all_boards[step + 1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "mutated_line": "if step + 1 < 8 and all_boards[step + -1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):",
      "code": "from collections import defaultdict\nfrom copy import deepcopy\n\ndef determine_winner(board):\n\n    def valid(i, j):\n        (n, m) = [8] * 2\n        return i > -1 and i < n and (j > -1) and (j < m)\n\n    def check(x, y, step):\n        if step + 1 < 8 and all_boards[step + -1][x][y] == 'S' or (step < 8 and all_boards[step][x][y] == 'S'):\n            return False\n        return True\n\n    def dfs(x, y):\n        (stack, visit, step) = ([[x, y, -1]], defaultdict(int), -1)\n        while stack:\n            (x, y, step) = stack.pop()\n            step += 1\n            if board[x][y] == 'A':\n                return 'WIN'\n            st = 0\n            for i in range(9):\n                (nx, ny) = (x + dx[i], y + dy[i])\n                if i == 0:\n                    if step >= 8:\n                        continue\n                    else:\n                        visit[nx, ny] = 0\n                if valid(nx, ny) and check(nx, ny, step) and (not visit[nx, ny]):\n                    stack.append([nx, ny, step])\n                    visit[nx, ny] = 1\n                else:\n                    st += 1\n            if st == 9:\n                step -= 1\n                visit[x, y] = 0\n        return 'LOSE'\n    (dx, dy) = ([0, -1, 0, 1, 0, 1, -1, 1, -1], [0, 0, 1, 0, -1, 1, -1, -1, 1])\n    all_boards = [board]\n    ini = [['.' for _ in range(8)] for _ in range(8)]\n    for k in range(1, 9):\n        tem = deepcopy(ini)\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'S' and i - k > -1:\n                    tem[i - k][j] = 'S'\n        all_boards.append(tem)\n    return dfs(0, 0)"
    }
  ]
}