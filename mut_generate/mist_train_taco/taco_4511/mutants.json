{
  "task_id": "taco_4511",
  "entry_point": "maximum_weight_paths",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "edges += [('_', '_', x) for x in queries]",
      "mutated_line": "edges -= [('_', '_', x) for x in queries]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges -= [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "current_paths = 0",
      "mutated_line": "current_paths = 1",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 1\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "current_paths = 0",
      "mutated_line": "current_paths = -1",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = -1\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "current_paths = 0",
      "mutated_line": "current_paths = 1",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 1\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while parent[i] != i:",
      "mutated_line": "while parent[i] == i:",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] == i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i < j:",
      "mutated_line": "if i <= j:",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i <= j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i < j:",
      "mutated_line": "if i >= j:",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i >= j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i < j:",
      "mutated_line": "if i != j:",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i != j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "count[j] += count[i]",
      "mutated_line": "count[j] -= count[i]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] -= count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "count[i] += count[j]",
      "mutated_line": "count[i] -= count[j]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] -= count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count = [1 for _ in range(n)]",
      "mutated_line": "count = [2 for _ in range(n)]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [2 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count = [1 for _ in range(n)]",
      "mutated_line": "count = [0 for _ in range(n)]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [0 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count = [1 for _ in range(n)]",
      "mutated_line": "count = [0 for _ in range(n)]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [0 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count = [1 for _ in range(n)]",
      "mutated_line": "count = [-1 for _ in range(n)]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [-1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if start != '_':",
      "mutated_line": "if start == '_':",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start == '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "start -= 1",
      "mutated_line": "start += 1",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start += 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "end -= 1",
      "mutated_line": "end += 1",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end += 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "current_paths += count[find_parent(start)] * count[find_parent(end)]",
      "mutated_line": "current_paths -= count[find_parent(start)] * count[find_parent(end)]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths -= count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges += [('_', '_', x) for x in queries]",
      "mutated_line": "edges += [('', '_', x) for x in queries]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges += [('_', '_', x) for x in queries]",
      "mutated_line": "edges += [('_', '', x) for x in queries]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if start != '_':",
      "mutated_line": "if start != '':",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "start -= 1",
      "mutated_line": "start -= 2",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 2\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "start -= 1",
      "mutated_line": "start -= 0",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 0\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "start -= 1",
      "mutated_line": "start -= 0",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 0\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "start -= 1",
      "mutated_line": "start -= -1",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= -1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "end -= 1",
      "mutated_line": "end -= 2",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 2\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "end -= 1",
      "mutated_line": "end -= 0",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 0\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "end -= 1",
      "mutated_line": "end -= 0",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 0\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "end -= 1",
      "mutated_line": "end -= -1",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= -1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "current_paths += count[find_parent(start)] * count[find_parent(end)]",
      "mutated_line": "current_paths += count[find_parent(start)] / count[find_parent(end)]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] / count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "current_paths += count[find_parent(start)] * count[find_parent(end)]",
      "mutated_line": "current_paths += count[find_parent(start)] + count[find_parent(end)]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] + count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "current_paths += count[find_parent(start)] * count[find_parent(end)]",
      "mutated_line": "current_paths += count[find_parent(start)] ** count[find_parent(end)]",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] ** count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[3])",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[3])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[1])",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[1])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[0])",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[0])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[1])",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[1])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[-2])",
      "code": "from collections import defaultdict\n\ndef maximum_weight_paths(n, edges, q, queries):\n\n    def find_parent(i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    def union(i, j):\n        i = find_parent(i)\n        j = find_parent(j)\n        if i < j:\n            parent[i] = j\n            count[j] += count[i]\n        else:\n            parent[j] = i\n            count[i] += count[j]\n    edges += [('_', '_', x) for x in queries]\n    edges.sort(key=lambda x: x[-2])\n    parent = [i for i in range(n)]\n    count = [1 for _ in range(n)]\n    result = defaultdict(int)\n    current_paths = 0\n    for (start, end, weight) in edges:\n        if start != '_':\n            start -= 1\n            end -= 1\n            current_paths += count[find_parent(start)] * count[find_parent(end)]\n            union(start, end)\n        result[weight] = current_paths\n    return [result[x] for x in queries]"
    }
  ]
}