{
  "task_id": "taco_8912",
  "entry_point": "maximize_chef_profit",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] / (n + 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] / (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] + (n + 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] + (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] ** (n + 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] ** (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x != self.parent[x]:",
      "mutated_line": "if x == self.parent[x]:",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x == self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if u != v:",
      "mutated_line": "if u == v:",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u == v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 1\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = -1\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 1\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return cnt > 1",
      "mutated_line": "return cnt >= 1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt >= 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return cnt > 1",
      "mutated_line": "return cnt <= 1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt <= 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return cnt > 1",
      "mutated_line": "return cnt != 1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt != 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] * (n - 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n - 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] * (n * 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n * 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if self.parent[i] == i:",
      "mutated_line": "if self.parent[i] != i:",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] != i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt -= 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return cnt > 1",
      "mutated_line": "return cnt > 2",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 2\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return cnt > 1",
      "mutated_line": "return cnt > 0",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 0\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return cnt > 1",
      "mutated_line": "return cnt > 0",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 0\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return cnt > 1",
      "mutated_line": "return cnt > -1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > -1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "chef_cost, company_cost = 0, 0",
      "mutated_line": "(chef_cost, company_cost) = (1, 0)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (1, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "chef_cost, company_cost = 0, 0",
      "mutated_line": "(chef_cost, company_cost) = (-1, 0)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (-1, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "chef_cost, company_cost = 0, 0",
      "mutated_line": "(chef_cost, company_cost) = (1, 0)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (1, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "chef_cost, company_cost = 0, 0",
      "mutated_line": "(chef_cost, company_cost) = (0, 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 1)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "chef_cost, company_cost = 0, 0",
      "mutated_line": "(chef_cost, company_cost) = (0, -1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, -1)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "chef_cost, company_cost = 0, 0",
      "mutated_line": "(chef_cost, company_cost) = (0, 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 1)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if d.find(u) != d.find(v):",
      "mutated_line": "if d.find(u) == d.find(v):",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) == d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "chef_cost += w",
      "mutated_line": "chef_cost -= w",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost -= w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if d.find(u) != d.find(v):",
      "mutated_line": "if d.find(u) == d.find(v):",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) == d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "company_cost += w",
      "mutated_line": "company_cost -= w",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost -= w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [1] * (n + 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [-1] * (n + 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [-1] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [1] * (n + 1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] * (n + 2)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 2)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] * (n + 0)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 0)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] * (n + 0)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 0)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.size = [0] * (n + 1)",
      "mutated_line": "self.size = [0] * (n + -1)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + -1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 2\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 0\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 0\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += -1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "chef_roads.sort(reverse=True)",
      "mutated_line": "chef_roads.sort(reverse=False)",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=False)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append((\"Impossible\",))",
      "mutated_line": "results.append(('',))",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('',))\n        else:\n            results.append((chef_cost, company_cost + chef_cost))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append((chef_cost, company_cost + chef_cost))",
      "mutated_line": "results.append((chef_cost, company_cost - chef_cost))",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost - chef_cost))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append((chef_cost, company_cost + chef_cost))",
      "mutated_line": "results.append((chef_cost, company_cost * chef_cost))",
      "code": "from collections import defaultdict\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [0] * (n + 1)\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def check(self, n):\n        cnt = 0\n        for i in range(n):\n            if self.parent[i] == i:\n                cnt += 1\n        return cnt > 1\n\ndef maximize_chef_profit(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M1, M2, company_roads, chef_roads) = case\n        company_roads.sort()\n        chef_roads.sort(reverse=True)\n        d = dsu(N)\n        (chef_cost, company_cost) = (0, 0)\n        for (w, u, v) in chef_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                chef_cost += w\n        for (w, u, v) in company_roads:\n            if d.find(u) != d.find(v):\n                d.union(u, v)\n                company_cost += w\n        if d.check(N):\n            results.append(('Impossible',))\n        else:\n            results.append((chef_cost, company_cost * chef_cost))\n    return results"
    }
  ]
}