{
  "task_id": "taco_17070",
  "entry_point": "power",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 2\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 0\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 0\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "import math\n\ndef power(a, n, mod):\n    res = -1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while n > 0:",
      "mutated_line": "while n >= 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n >= 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while n > 0:",
      "mutated_line": "while n <= 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n <= 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while n > 0:",
      "mutated_line": "while n != 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n != 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def calculate_gcd_modulo(A, B, N, mod=1000000007):",
      "mutated_line": "def calculate_gcd_modulo(A, B, N, mod=1000000008):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000008):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def calculate_gcd_modulo(A, B, N, mod=1000000007):",
      "mutated_line": "def calculate_gcd_modulo(A, B, N, mod=1000000006):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000006):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def calculate_gcd_modulo(A, B, N, mod=1000000007):",
      "mutated_line": "def calculate_gcd_modulo(A, B, N, mod=0):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=0):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def calculate_gcd_modulo(A, B, N, mod=1000000007):",
      "mutated_line": "def calculate_gcd_modulo(A, B, N, mod=1):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def calculate_gcd_modulo(A, B, N, mod=1000000007):",
      "mutated_line": "def calculate_gcd_modulo(A, B, N, mod=-1000000007):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=-1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if A == B:",
      "mutated_line": "if A != B:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A != B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "possible = 1",
      "mutated_line": "possible = 2",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 2\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "possible = 1",
      "mutated_line": "possible = 0",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 0\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "possible = 1",
      "mutated_line": "possible = 0",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 0\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "possible = 1",
      "mutated_line": "possible = -1",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = -1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "total = A - B",
      "mutated_line": "total = A + B",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A + B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "total = A - B",
      "mutated_line": "total = A * B",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A * B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return possible % mod",
      "mutated_line": "return possible * mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible * mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return possible % mod",
      "mutated_line": "return possible + mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible + mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 1:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "while n > 0:",
      "mutated_line": "while n > -1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > -1:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 1:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & 1 != 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 != 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "n -= 1",
      "mutated_line": "n += 1",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n += 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = a % mod * a % mod * mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod * mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = a % mod * a % mod + mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod + mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "n = n // 2",
      "mutated_line": "n = n / 2",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n / 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "n = n // 2",
      "mutated_line": "n = n * 2",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n * 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return (power(A, N, mod) + power(B, N, mod)) % mod",
      "mutated_line": "return (power(A, N, mod) + power(B, N, mod)) * mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) * mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return (power(A, N, mod) + power(B, N, mod)) % mod",
      "mutated_line": "return power(A, N, mod) + power(B, N, mod) + mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return power(A, N, mod) + power(B, N, mod) + mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(total)) + 1):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(2, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(0, int(math.sqrt(total)) + 1):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(0, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(0, int(math.sqrt(total)) + 1):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(0, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(-1, int(math.sqrt(total)) + 1):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(-1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(total)) - 1):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) - 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(total)) * 1):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) * 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if total % i == 0:",
      "mutated_line": "if total % i != 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i != 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n | 1 == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n | 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & 1 == 2:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 2:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & 1 == 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 0:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & 1 == 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 0:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & 1 == -1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == -1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = res % mod * a % mod * mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod * mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = res % mod * a % mod + mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod + mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n -= 1",
      "mutated_line": "n -= 2",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 2\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n -= 1",
      "mutated_line": "n -= 0",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 0\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n -= 1",
      "mutated_line": "n -= 0",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 0\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "n -= 1",
      "mutated_line": "n -= -1",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= -1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = a % mod * a * mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a * mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = (a % mod * a + mod) % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = (a % mod * a + mod) % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = n // 2",
      "mutated_line": "n = n // 3",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 3\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = n // 2",
      "mutated_line": "n = n // 1",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 1\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = n // 2",
      "mutated_line": "n = n // 0",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 0\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = n // 2",
      "mutated_line": "n = n // 1",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 1\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = n // 2",
      "mutated_line": "n = n // -2",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // -2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return (power(A, N, mod) + power(B, N, mod)) % mod",
      "mutated_line": "return (power(A, N, mod) - power(B, N, mod)) % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) - power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return (power(A, N, mod) + power(B, N, mod)) % mod",
      "mutated_line": "return power(A, N, mod) * power(B, N, mod) % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return power(A, N, mod) * power(B, N, mod) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(total)) + 2):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 2):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(total)) + 0):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 0):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(total)) + 0):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 0):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, int(math.sqrt(total)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(total)) + -1):",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + -1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if total % i == 0:",
      "mutated_line": "if total * i == 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total * i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if total % i == 0:",
      "mutated_line": "if total + i == 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total + i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if total % i == 0:",
      "mutated_line": "if total % i == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 1:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if total % i == 0:",
      "mutated_line": "if total % i == -1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == -1:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if total % i == 0:",
      "mutated_line": "if total % i == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 1:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "temp = (power(A, N, i) + power(B, N, i)) % i",
      "mutated_line": "temp = (power(A, N, i) + power(B, N, i)) * i",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) * i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "temp = (power(A, N, i) + power(B, N, i)) % i",
      "mutated_line": "temp = power(A, N, i) + power(B, N, i) + i",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = power(A, N, i) + power(B, N, i) + i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if temp == 0:",
      "mutated_line": "if temp != 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp != 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) * (total // i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) * (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = power(A, N, total // i) + power(B, N, total // i) + total // i",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = power(A, N, total // i) + power(B, N, total // i) + total // i\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if temp == 0:",
      "mutated_line": "if temp != 0:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp != 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & 2 == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 2 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & 0 == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 0 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & 0 == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 0 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n & 1 == 1:",
      "mutated_line": "if n & -1 == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & -1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = res % mod * a * mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a * mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = (res % mod * a + mod) % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = (res % mod * a + mod) % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = a % mod / a % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod / a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = (a % mod + a) % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = (a % mod + a) % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = (a % mod) ** a % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = (a % mod) ** a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "temp = (power(A, N, i) + power(B, N, i)) % i",
      "mutated_line": "temp = (power(A, N, i) - power(B, N, i)) % i",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) - power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "temp = (power(A, N, i) + power(B, N, i)) % i",
      "mutated_line": "temp = power(A, N, i) * power(B, N, i) % i",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = power(A, N, i) * power(B, N, i) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if temp == 0:",
      "mutated_line": "if temp == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 1:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if temp == 0:",
      "mutated_line": "if temp == -1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == -1:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if temp == 0:",
      "mutated_line": "if temp == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 1:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = (power(A, N, total // i) - power(B, N, total // i)) % (total // i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) - power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = power(A, N, total // i) * power(B, N, total // i) % (total // i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = power(A, N, total // i) * power(B, N, total // i) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total / i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total / i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total * i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total * i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if temp == 0:",
      "mutated_line": "if temp == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 1:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if temp == 0:",
      "mutated_line": "if temp == -1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == -1:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if temp == 0:",
      "mutated_line": "if temp == 1:",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 1:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = res % mod / a % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod / a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = (res % mod + a) % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = (res % mod + a) % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = (res % mod) ** a % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = (res % mod) ** a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = a * mod * a % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a * mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a % mod * a % mod % mod",
      "mutated_line": "a = (a + mod) * a % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = (a + mod) * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "possible = max(possible, total // i)",
      "mutated_line": "possible = max(possible, total / i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total / i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "possible = max(possible, total // i)",
      "mutated_line": "possible = max(possible, total * i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total * i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = res * mod * a % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res * mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res % mod * a % mod % mod",
      "mutated_line": "res = (res + mod) * a % mod % mod",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = (res + mod) * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = (power(A, N, total / i) + power(B, N, total // i)) % (total // i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total / i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = (power(A, N, total * i) + power(B, N, total // i)) % (total // i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total * i) + power(B, N, total // i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = (power(A, N, total // i) + power(B, N, total / i)) % (total // i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total / i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = (power(A, N, total // i) + power(B, N, total // i)) % (total // i)",
      "mutated_line": "temp = (power(A, N, total // i) + power(B, N, total * i)) % (total // i)",
      "code": "import math\n\ndef power(a, n, mod):\n    res = 1\n    while n > 0:\n        if n & 1 == 1:\n            res = res % mod * a % mod % mod\n            n -= 1\n        a = a % mod * a % mod % mod\n        n = n // 2\n    return res\n\ndef calculate_gcd_modulo(A, B, N, mod=1000000007):\n    if A == B:\n        return (power(A, N, mod) + power(B, N, mod)) % mod\n    possible = 1\n    total = A - B\n    for i in range(1, int(math.sqrt(total)) + 1):\n        if total % i == 0:\n            temp = (power(A, N, i) + power(B, N, i)) % i\n            if temp == 0:\n                possible = max(possible, i)\n            temp = (power(A, N, total // i) + power(B, N, total * i)) % (total // i)\n            if temp == 0:\n                possible = max(possible, total // i)\n    return possible % mod"
    }
  ]
}