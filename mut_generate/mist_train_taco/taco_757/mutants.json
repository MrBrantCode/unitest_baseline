{
  "task_id": "taco_757",
  "entry_point": "partition_array_for_devu",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "ans[0] += even",
      "mutated_line": "ans[0] -= even",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] -= even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "ans[0] += odd",
      "mutated_line": "ans[0] -= odd",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] -= odd\n    return ('YES', ans)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 == 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) * 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if len(odd) - (k - p) + 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 1:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != -1:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 1:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(k - p):",
      "mutated_line": "for i in range(k + p):",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k + p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(k - p):",
      "mutated_line": "for i in range(k * p):",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k * p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(k - p, k):",
      "mutated_line": "for i in range(k + p, k):",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k + p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(k - p, k):",
      "mutated_line": "for i in range(k * p, k):",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k * p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans[0] += even",
      "mutated_line": "ans[1] += even",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[1] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans[0] += even",
      "mutated_line": "ans[-1] += even",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[-1] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans[0] += even",
      "mutated_line": "ans[1] += even",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[1] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[0] += odd",
      "mutated_line": "ans[1] += odd",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[1] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[0] += odd",
      "mutated_line": "ans[-1] += odd",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[-1] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[0] += odd",
      "mutated_line": "ans[1] += odd",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[1] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 'YES', ans",
      "mutated_line": "return ('', ans)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) + (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if len(odd) * (k - p) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 3 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 1 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 0 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 1 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % -2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 'NO', None",
      "mutated_line": "return ('', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif len(odd) >= 2:",
      "mutated_line": "elif len(odd) > 2:",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) > 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif len(odd) >= 2:",
      "mutated_line": "elif len(odd) < 2:",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) < 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif len(odd) >= 2:",
      "mutated_line": "elif len(odd) == 2:",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) == 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % 2 != 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 != 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 2 != 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 != 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k + p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if (len(odd) - (k - p)) % 2 != 0:",
      "mutated_line": "return ('NO', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - k * p) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 'NO', None",
      "mutated_line": "return ('', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(odd) >= 2:",
      "mutated_line": "elif len(odd) >= 3:",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 3:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(odd) >= 2:",
      "mutated_line": "elif len(odd) >= 1:",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 1:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(odd) >= 2:",
      "mutated_line": "elif len(odd) >= 0:",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 0:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(odd) >= 2:",
      "mutated_line": "elif len(odd) >= 1:",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 1:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif len(odd) >= 2:",
      "mutated_line": "elif len(odd) >= -2:",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= -2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x * 2 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x * 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x + 2 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x + 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % 2 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 1, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % 2 == -1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == -1, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % 2 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 1, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x * 2 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x * 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x + 2 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x + 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 2 == 2, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 2, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 2 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 0, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 2 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 0, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 2 == -1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == -1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 'NO', None",
      "mutated_line": "return ('', None)",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % 3 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 3 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % 1 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 1 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % 0 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 0 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % 1 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 1 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "even = list(filter(lambda x: x % 2 == 0, a))",
      "mutated_line": "even = list(filter(lambda x: x % -2 == 0, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % -2 == 0, a))\n    odd = list(filter(lambda x: x % 2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 3 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 3 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 1 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 1 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 0 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 0 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % 1 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % 1 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "odd = list(filter(lambda x: x % 2 == 1, a))",
      "mutated_line": "odd = list(filter(lambda x: x % -2 == 1, a))",
      "code": "def partition_array_for_devu(n, k, p, a):\n    even = list(filter(lambda x: x % 2 == 0, a))\n    odd = list(filter(lambda x: x % -2 == 1, a))\n    if (len(odd) - (k - p)) % 2 != 0:\n        return ('NO', None)\n    ans = [[] for _ in range(k)]\n    for i in range(k - p):\n        if odd:\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    for i in range(k - p, k):\n        if even:\n            ans[i].append(even.pop())\n        elif len(odd) >= 2:\n            ans[i].append(odd.pop())\n            ans[i].append(odd.pop())\n        else:\n            return ('NO', None)\n    ans[0] += even\n    ans[0] += odd\n    return ('YES', ans)"
    }
  ]
}