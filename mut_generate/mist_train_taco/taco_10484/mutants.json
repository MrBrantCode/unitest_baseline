{
  "task_id": "taco_10484",
  "entry_point": "calculate_max_happiness",
  "mutant_count": 153,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u += 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v += 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u += 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v += 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 10 * 17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 * 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 10 + 17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 + 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-10 ** 20] / K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] / K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-10 ** 20] + K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] + K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-10 ** 20] ** K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] ** K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 * 18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 * 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 + 18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 + 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dist = [inf] * N",
      "mutated_line": "dist = [inf] / N",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] / N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dist = [inf] * N",
      "mutated_line": "dist = [inf] + N",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] + N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dist = [inf] * N",
      "mutated_line": "dist = [inf] ** N",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] ** N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 2\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 0\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 0\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= -1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 2\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 0\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 0\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= -1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = dijkstra(N, 0, Edge1)",
      "mutated_line": "dist = dijkstra(N, 1, Edge1)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 1, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = dijkstra(N, 0, Edge1)",
      "mutated_line": "dist = dijkstra(N, -1, Edge1)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, -1, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = dijkstra(N, 0, Edge1)",
      "mutated_line": "dist = dijkstra(N, 1, Edge1)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 1, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 2\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 0\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 0\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= -1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 2\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 0\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 0\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= -1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 11 ** 17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 11 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 9 ** 17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 9 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 0 ** 17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 0 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 1 ** 17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 1 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = -10 ** 17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = -10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 10 ** 18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 18\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 10 ** 16",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 16\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 10 ** 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 0\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 10 ** 1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 1\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "inf = 10 ** 17",
      "mutated_line": "inf = 10 ** -17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** -17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(3 / N, 0, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 / N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(3 + N, 0, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 + N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(3 ** N, 0, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 ** N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(3 * N, 1, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 1, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(3 * N, -1, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, -1, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(3 * N, 1, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 1, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 11 ** 18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 11 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 9 ** 18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 9 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 0 ** 18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 0 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 1 ** 18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 1 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = -10 ** 18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = -10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** 19",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 19\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** 17",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 17\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** 0",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 0\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** 1",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 1\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inf = 10 ** 18",
      "mutated_line": "inf = 10 ** -18",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** -18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while False:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(4 * N, 0, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(4 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(2 * N, 0, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(2 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(0 * N, 0, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(0 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(1 * N, 0, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(1 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dist2 = dijkstra(3 * N, 0, Edge2)",
      "mutated_line": "dist2 = dijkstra(-3 * N, 0, Edge2)",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(-3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [+10 ** 20] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [+10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] + 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] + 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] * 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] * 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf + dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf + dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf * dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf * dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Q = [(0, s)]",
      "mutated_line": "Q = [(1, s)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(1, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Q = [(0, s)]",
      "mutated_line": "Q = [(-1, s)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(-1, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Q = [(0, s)]",
      "mutated_line": "Q = [(1, s)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(1, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if vn not in decided:",
      "mutated_line": "if vn in decided:",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if vf not in decided:",
      "mutated_line": "if vf in decided:",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "Edge2 = [[] for _ in range(3 * N)]",
      "mutated_line": "Edge2 = [[] for _ in range(3 / N)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 / N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "Edge2 = [[] for _ in range(3 * N)]",
      "mutated_line": "Edge2 = [[] for _ in range(3 + N)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 + N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "Edge2 = [[] for _ in range(3 * N)]",
      "mutated_line": "Edge2 = [[] for _ in range(3 ** N)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 ** N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "Edge2[N + u].append((N + v, t))",
      "mutated_line": "Edge2[N + u].append((N - v, t))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N - v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "Edge2[N + u].append((N + v, t))",
      "mutated_line": "Edge2[N + u].append((N * v, t))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N * v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "Edge2[N + v].append((N + u, t))",
      "mutated_line": "Edge2[N + v].append((N - u, t))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N - u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "Edge2[N + v].append((N + u, t))",
      "mutated_line": "Edge2[N + v].append((N * u, t))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N * u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "Edge2[i].append((N + i, inf - P[i]))",
      "mutated_line": "Edge2[i].append((N - i, inf - P[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N - i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "Edge2[i].append((N + i, inf - P[i]))",
      "mutated_line": "Edge2[i].append((N * i, inf - P[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N * i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "Edge2[i].append((N + i, inf - P[i]))",
      "mutated_line": "Edge2[i].append((N + i, inf + P[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf + P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "Edge2[i].append((N + i, inf - P[i]))",
      "mutated_line": "Edge2[i].append((N + i, inf * P[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf * P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 * N - i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N - i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 * N * i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N * i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 * N + i, inf - J[i] - dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] - dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 * N + i, (inf - J[i]) * dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, (inf - J[i]) * dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-(10 * 20)] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-(10 * 20)] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-(10 + 20)] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-(10 + 20)] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 2] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 2] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 0] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 0] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 0] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 0] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - -1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - -1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] + 1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] + 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] * 1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] * 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 / inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 / inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 + inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 + inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 ** inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 ** inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Edge2 = [[] for _ in range(3 * N)]",
      "mutated_line": "Edge2 = [[] for _ in range(4 * N)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(4 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Edge2 = [[] for _ in range(3 * N)]",
      "mutated_line": "Edge2 = [[] for _ in range(2 * N)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(2 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Edge2 = [[] for _ in range(3 * N)]",
      "mutated_line": "Edge2 = [[] for _ in range(0 * N)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(0 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Edge2 = [[] for _ in range(3 * N)]",
      "mutated_line": "Edge2 = [[] for _ in range(1 * N)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(1 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Edge2 = [[] for _ in range(3 * N)]",
      "mutated_line": "Edge2 = [[] for _ in range(-3 * N)]",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(-3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "Edge2[N + u].append((N + v, t))",
      "mutated_line": "Edge2[N - u].append((N + v, t))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N - u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "Edge2[N + u].append((N + v, t))",
      "mutated_line": "Edge2[N * u].append((N + v, t))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N * u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "Edge2[N + v].append((N + u, t))",
      "mutated_line": "Edge2[N - v].append((N + u, t))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N - v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "Edge2[N + v].append((N + u, t))",
      "mutated_line": "Edge2[N * v].append((N + u, t))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N * v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N - i].append((2 * N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N - i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N * i].append((2 * N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N * i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 / N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 / N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 + N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 + N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 ** N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 ** N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 * N + i, inf + J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf + J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((2 * N + i, inf * J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf * J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-11 ** 20] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-11 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-9 ** 20] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-9 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-0 ** 20] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-0 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-1 ** 20] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-1 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [--10 ** 20] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [--10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-10 ** 21] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 21] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-10 ** 19] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 19] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-10 ** 0] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 0] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-10 ** 1] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 1] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Ans = [-10 ** 20] * K",
      "mutated_line": "Ans = [-10 ** -20] * K",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** -20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 2], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 2], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 0], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 0], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 0], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 0], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - -1], 2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - -1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 3 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 3 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 1 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 1 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 0 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 0 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 1 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 1 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], -2 * inf - dist2[2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], -2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N - i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N - i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N * i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N * i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((3 * N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((3 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((1 * N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((1 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((0 * N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((0 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((1 * N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((1 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))",
      "mutated_line": "Edge2[N + i].append((-2 * N + i, inf - J[i] + dist[i]))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((-2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 / N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 / N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 + N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 + N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 ** N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 ** N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "hp(Q, (dn + df, vf))",
      "mutated_line": "hp(Q, (dn - df, vf))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn - df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "hp(Q, (dn + df, vf))",
      "mutated_line": "hp(Q, (dn * df, vf))",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn * df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[3 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[3 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[1 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[1 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[0 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[0 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[1 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[1 * N + i])\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[2 * N + i])",
      "mutated_line": "Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[-2 * N + i])",
      "code": "import sys\nfrom heapq import heappop as hpp, heappush as hp\n\ndef calculate_max_happiness(N, M, K, P, C, J, roads):\n\n    def dijkstra(N, s, Edge):\n        inf = 10 ** 18\n        dist = [inf] * N\n        Q = [(0, s)]\n        decided = set()\n        for _ in range(N):\n            while True:\n                (dn, vn) = hpp(Q)\n                if vn not in decided:\n                    decided.add(vn)\n                    dist[vn] = dn\n                    break\n            for (vf, df) in Edge[vn]:\n                if vf not in decided:\n                    hp(Q, (dn + df, vf))\n        return dist\n    Edge1 = [[] for _ in range(N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge1[u].append((v, t))\n        Edge1[v].append((u, t))\n    dist = dijkstra(N, 0, Edge1)\n    Edge2 = [[] for _ in range(3 * N)]\n    for (u, v, t) in roads:\n        u -= 1\n        v -= 1\n        Edge2[u].append((v, t))\n        Edge2[v].append((u, t))\n        Edge2[N + u].append((N + v, t))\n        Edge2[N + v].append((N + u, t))\n    inf = 10 ** 17\n    for i in range(N):\n        Edge2[i].append((N + i, inf - P[i]))\n        Edge2[N + i].append((2 * N + i, inf - J[i] + dist[i]))\n    dist2 = dijkstra(3 * N, 0, Edge2)\n    Ans = [-10 ** 20] * K\n    for i in range(N):\n        Ans[C[i] - 1] = max(Ans[C[i] - 1], 2 * inf - dist2[-2 * N + i])\n    return Ans"
    }
  ]
}