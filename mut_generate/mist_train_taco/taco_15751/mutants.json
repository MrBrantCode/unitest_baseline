{
  "task_id": "taco_15751",
  "entry_point": "calculate_probability",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s2 = s // 2",
      "mutated_line": "s2 = s / 2",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s / 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s2 = s // 2",
      "mutated_line": "s2 = s * 2",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s * 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total -= count(index + 1, delta + 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total -= count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total -= count(index + 1, delta - 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total -= count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) * comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) * comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) // comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) // comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s2 = s // 2",
      "mutated_line": "s2 = s // 3",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 3\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s2 = s // 2",
      "mutated_line": "s2 = s // 1",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 1\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s2 = s // 2",
      "mutated_line": "s2 = s // 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 0\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s2 = s // 2",
      "mutated_line": "s2 = s // 1",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 1\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s2 = s // 2",
      "mutated_line": "s2 = s // -2",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // -2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if index == n:",
      "mutated_line": "if index != n:",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index != n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index - 1, delta + 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index - 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index * 1, delta + 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index * 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 1, delta - 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta - 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 1, delta * 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta * 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index - 1, delta - 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index - 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index * 1, delta - 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index * 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 1, delta + 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta + 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 1, delta * 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta * 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 1, delta - 1, ca - balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca - balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 1, delta - 1, ca * balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca * balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(1, 0, 0) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(1, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(-1, 0, 0) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(-1, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(1, 0, 0) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(1, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 1, 0) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 1, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, -1, 0) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, -1, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 1, 0) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 1, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 1) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 1) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, -1) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, -1) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 1) / comb(s, s // 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 1) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) / comb(s, s / 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s / 2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) / comb(s, s * 2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s * 2)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta == 0 or ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 or ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 2 if delta == 0 and ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 2 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 0 if delta == 0 and ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 0 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 0 if delta == 0 and ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 0 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return -1 if delta == 0 and ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return -1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta == 0 and ca == s2 else 1",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 1\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta == 0 and ca == s2 else -1",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else -1\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta == 0 and ca == s2 else 1",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 1\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca + x) / comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) / comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca + x) + comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) + comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca + x) ** comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) ** comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 2, delta + 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 2, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 0, delta + 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 0, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 0, delta + 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 0, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + -1, delta + 1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + -1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 1, delta + 2, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 2, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 1, delta + 0, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 0, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 1, delta + 0, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 0, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total += count(index + 1, delta + 1, ca)",
      "mutated_line": "total += count(index + 1, delta + -1, ca)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + -1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 2, delta - 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 2, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 0, delta - 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 0, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 0, delta - 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 0, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + -1, delta - 1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + -1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 1, delta - 2, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 2, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 1, delta - 0, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 0, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 1, delta - 0, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 0, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total += count(index + 1, delta - 1, ca + balls[index])",
      "mutated_line": "total += count(index + 1, delta - -1, ca + balls[index])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - -1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) / comb(s, s // 3)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 3)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) / comb(s, s // 1)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) / comb(s, s // 0)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) / comb(s, s // 1)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return count(0, 0, 0) / comb(s, s // 2)",
      "mutated_line": "return count(0, 0, 0) / comb(s, s // -2)",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // -2)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta != 0 and ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta != 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta == 0 and ca != s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca != s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta == 1 and ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 1 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta == -1 and ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == -1 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 1 if delta == 0 and ca == s2 else 0",
      "mutated_line": "return 1 if delta == 1 and ca == s2 else 0",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 1 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index - 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index - 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index * 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index * 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca - x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca - x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca * x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca * x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(2, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(2, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(0, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(0, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(0, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(0, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(-1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(-1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 2, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 2, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 0, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 0, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + 0, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + 0, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "mutated_line": "total = sum([count(index + -1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])",
      "code": "from math import comb\nfrom functools import lru_cache\nfrom typing import List\n\ndef calculate_probability(balls: List[int]) -> float:\n    n = len(balls)\n    s = sum(balls)\n    s2 = s // 2\n\n    @lru_cache(None)\n    def count(index, delta, ca):\n        if index == n:\n            return 1 if delta == 0 and ca == s2 else 0\n        total = sum([count(index + -1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n        total += count(index + 1, delta + 1, ca)\n        total += count(index + 1, delta - 1, ca + balls[index])\n        return total\n    return count(0, 0, 0) / comb(s, s // 2)"
    }
  ]
}