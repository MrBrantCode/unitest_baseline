{
  "task_id": "taco_9212",
  "entry_point": "process_tree_queries",
  "mutant_count": 101,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] / (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] / (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] + (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] + (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] ** (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] ** (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] / (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] / (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] + (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] + (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] ** (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] ** (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] / (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] / (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] + (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] + (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] ** (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] ** (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "su = 0",
      "mutated_line": "su = 1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 1\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "su = 0",
      "mutated_line": "su = -1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = -1\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "su = 0",
      "mutated_line": "su = 1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 1\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n - 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n - 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n * 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n * 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] * (n - 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n - 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] * (n * 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n * 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] * (n - 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n - 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] * (n * 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n * 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if vis[u] == 0:",
      "mutated_line": "if vis[u] != 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] != 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "height[u] = height[parr[u]] + 1",
      "mutated_line": "height[u] = height[parr[u]] - 1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] - 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "height[u] = height[parr[u]] + 1",
      "mutated_line": "height[u] = height[parr[u]] * 1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] * 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % 2 != 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 != 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "su += ll[u - 1]",
      "mutated_line": "su -= ll[u - 1]",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su -= ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ll[uu - 1] = su",
      "mutated_line": "ll[uu + 1] = su",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu + 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ll[uu - 1] = su",
      "mutated_line": "ll[uu * 1] = su",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu * 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [1] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [-1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [-1] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [1] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 2)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 2)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 0)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 0)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 0)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 0)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + -1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + -1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [1] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [-1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [-1] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [1] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] * (n + 2)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 2)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] * (n + 0)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 0)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] * (n + 0)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 0)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "height = [0] * (n + 1)",
      "mutated_line": "height = [0] * (n + -1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + -1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [1] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [-1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [-1] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [1] * (n + 1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [1] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] * (n + 2)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 2)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] * (n + 0)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 0)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] * (n + 0)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 0)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "parr = [0] * (n + 1)",
      "mutated_line": "parr = [0] * (n + -1)",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + -1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if vis[u] == 0:",
      "mutated_line": "if vis[u] == 1:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 1:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if vis[u] == 0:",
      "mutated_line": "if vis[u] == -1:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == -1:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if vis[u] == 0:",
      "mutated_line": "if vis[u] == 1:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 1:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = deque([1])",
      "mutated_line": "queue = deque([2])",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([2])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = deque([1])",
      "mutated_line": "queue = deque([0])",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([0])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = deque([1])",
      "mutated_line": "queue = deque([0])",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([0])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "queue = deque([1])",
      "mutated_line": "queue = deque([-1])",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([-1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "height[u] = height[parr[u]] + 1",
      "mutated_line": "height[u] = height[parr[u]] + 2",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 2\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "height[u] = height[parr[u]] + 1",
      "mutated_line": "height[u] = height[parr[u]] + 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 0\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "height[u] = height[parr[u]] + 1",
      "mutated_line": "height[u] = height[parr[u]] + 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 0\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "height[u] = height[parr[u]] + 1",
      "mutated_line": "height[u] = height[parr[u]] + -1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + -1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i != parr[u]:",
      "mutated_line": "if i == parr[u]:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i == parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol * 2 == 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol * 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol + 2 == 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol + 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % 2 == 1:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 1:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % 2 == -1:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == -1:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % 2 == 1:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 1:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis[u] = 1",
      "mutated_line": "vis[u] = 2",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 2\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis[u] = 1",
      "mutated_line": "vis[u] = 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 0\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis[u] = 1",
      "mutated_line": "vis[u] = 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 0\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis[u] = 1",
      "mutated_line": "vis[u] = -1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = -1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u - 1] = 1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 1\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u - 1] = -1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = -1\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u - 1] = 1",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 1\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if j != par:",
      "mutated_line": "if j == par:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j == par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ll[uu - 1] = su",
      "mutated_line": "ll[uu - 2] = su",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 2] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ll[uu - 1] = su",
      "mutated_line": "ll[uu - 0] = su",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 0] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ll[uu - 1] = su",
      "mutated_line": "ll[uu - 0] = su",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 0] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ll[uu - 1] = su",
      "mutated_line": "ll[uu - -1] = su",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - -1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = deque([(u, 0)])",
      "mutated_line": "queue = deque([(u, 1)])",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 1)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = deque([(u, 0)])",
      "mutated_line": "queue = deque([(u, -1)])",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, -1)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = deque([(u, 0)])",
      "mutated_line": "queue = deque([(u, 1)])",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 1)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % 3 == 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 3 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % 1 == 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 1 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % 0 == 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 0 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % 1 == 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 1 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if lol % 2 == 0:",
      "mutated_line": "if lol % -2 == 0:",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % -2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "su += ll[u - 1]",
      "mutated_line": "su += ll[u + 1]",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u + 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "su += ll[u - 1]",
      "mutated_line": "su += ll[u * 1]",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u * 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u + 1] = 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u + 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u * 1] = 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u * 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "su += ll[u - 1]",
      "mutated_line": "su += ll[u - 2]",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 2]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "su += ll[u - 1]",
      "mutated_line": "su += ll[u - 0]",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 0]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "su += ll[u - 1]",
      "mutated_line": "su += ll[u - 0]",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 0]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "su += ll[u - 1]",
      "mutated_line": "su += ll[u - -1]",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - -1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u - 2] = 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 2] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u - 0] = 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 0] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u - 0] = 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 0] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ll[u - 1] = 0",
      "mutated_line": "ll[u - -1] = 0",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - -1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "queue.appendleft((j, lol + 1))",
      "mutated_line": "queue.appendleft((j, lol - 1))",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol - 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "queue.appendleft((j, lol + 1))",
      "mutated_line": "queue.appendleft((j, lol * 1))",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol * 1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "queue.appendleft((j, lol + 1))",
      "mutated_line": "queue.appendleft((j, lol + 2))",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 2))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "queue.appendleft((j, lol + 1))",
      "mutated_line": "queue.appendleft((j, lol + 0))",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 0))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "queue.appendleft((j, lol + 1))",
      "mutated_line": "queue.appendleft((j, lol + 0))",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + 0))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "queue.appendleft((j, lol + 1))",
      "mutated_line": "queue.appendleft((j, lol + -1))",
      "code": "from collections import defaultdict, deque\n\ndef process_tree_queries(n, q, values, edges, queries):\n\n    def bfs(height, d, parr):\n        queue = deque([1])\n        while queue:\n            u = queue.pop()\n            height[u] = height[parr[u]] + 1\n            for i in d[u]:\n                if i != parr[u]:\n                    queue.appendleft(i)\n                    parr[i] = u\n\n    def opbfs(u, vis, ll, parr):\n        queue = deque([(u, 0)])\n        uu = u\n        su = 0\n        while queue:\n            (u, lol) = queue.pop()\n            par = parr[u]\n            if lol % 2 == 0:\n                vis[u] = 1\n                su += ll[u - 1]\n                ll[u - 1] = 0\n            for j in d[u]:\n                if j != par:\n                    queue.appendleft((j, lol + -1))\n        ll[uu - 1] = su\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n    vis = [0] * (n + 1)\n    height = [0] * (n + 1)\n    parr = [0] * (n + 1)\n    bfs(height, d, parr)\n    query_list = [(height[u], u) for u in queries]\n    query_list.sort()\n    for (he, u) in query_list:\n        if vis[u] == 0:\n            opbfs(u, vis, values, parr)\n    return values"
    }
  ]
}