{
  "task_id": "taco_16560",
  "entry_point": "can_form_circle",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [0] / 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] / 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [0] + 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] + 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [0] ** 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] ** 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [0] / 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] / 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [0] + 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] + 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [0] ** 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] ** 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [0] / 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] / 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [0] + 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] + 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [0] ** 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] ** 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] -= 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] -= 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "out_degree[u] += 1",
      "mutated_line": "out_degree[u] -= 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] -= 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis[node] = 1",
      "mutated_line": "vis[node] = 2",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 2\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis[node] = 1",
      "mutated_line": "vis[node] = 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 0\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis[node] = 1",
      "mutated_line": "vis[node] = 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 0\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis[node] = 1",
      "mutated_line": "vis[node] = -1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = -1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [0] / 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] / 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [0] + 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] + 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [0] ** 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] ** 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 2\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 0\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 0\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return -1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [0] * 27",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 27\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [0] * 25",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 25\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [0] * 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 0\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [0] * 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 1\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [0] * -26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * -26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [0] * 27",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 27\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [0] * 25",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 25\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [0] * 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 0\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [0] * 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 1\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [0] * -26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * -26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [0] * 27",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 27\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [0] * 25",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 25\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [0] * 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 0\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [0] * 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 1\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [0] * -26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * -26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "u = ord(i[0]) - ord('a')",
      "mutated_line": "u = ord(i[0]) + ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) + ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "u = ord(i[0]) - ord('a')",
      "mutated_line": "u = ord(i[0]) * ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) * ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "v = ord(i[-1]) - ord('a')",
      "mutated_line": "v = ord(i[-1]) + ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) + ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "v = ord(i[-1]) - ord('a')",
      "mutated_line": "v = ord(i[-1]) * ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) * ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark[u] = mark[v] = 1",
      "mutated_line": "mark[u] = mark[v] = 2",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 2\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark[u] = mark[v] = 1",
      "mutated_line": "mark[u] = mark[v] = 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 0\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark[u] = mark[v] = 1",
      "mutated_line": "mark[u] = mark[v] = 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 0\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark[u] = mark[v] = 1",
      "mutated_line": "mark[u] = mark[v] = -1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = -1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] += 2",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 2\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] += 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 0\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] += 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 0\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] += -1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += -1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out_degree[u] += 1",
      "mutated_line": "out_degree[u] += 2",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 2\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out_degree[u] += 1",
      "mutated_line": "out_degree[u] += 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 0\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out_degree[u] += 1",
      "mutated_line": "out_degree[u] += 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 0\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "out_degree[u] += 1",
      "mutated_line": "out_degree[u] += -1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += -1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(27):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(27):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(25):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(25):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(0):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(0):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(1):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(1):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(-26):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(-26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if in_degree[i] != out_degree[i]:",
      "mutated_line": "if in_degree[i] == out_degree[i]:",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] == out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[0][0]) + ord('a'), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) + ord('a'), adj, mark)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[0][0]) * ord('a'), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) * ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [0] * 27",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 27\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [0] * 25",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 25\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [0] * 0",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 0\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [0] * 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 1\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [0] * -26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * -26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(27):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(27):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(25):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(25):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(0):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(0):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(1):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(1):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(-26):",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(-26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if not vis[i] and mark[i] == 1:",
      "mutated_line": "if not vis[i] or mark[i] == 1:",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] or mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [1] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [-1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [-1] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mark = [0] * 26",
      "mutated_line": "mark = [1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [1] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [1] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [-1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [-1] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "in_degree = [0] * 26",
      "mutated_line": "in_degree = [1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [1] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [1] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [-1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [-1] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "out_degree = [0] * 26",
      "mutated_line": "out_degree = [1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [1] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 1\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return -1\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 1\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [1] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [-1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [-1] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vis = [0] * 26",
      "mutated_line": "vis = [1] * 26",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [1] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if not vis[i] and mark[i] == 1:",
      "mutated_line": "if not vis[i] and mark[i] != 1:",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] != 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 1\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return -1\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 1\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj = [[] for _ in range(26)]",
      "mutated_line": "adj = [[] for _ in range(27)]",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(27)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj = [[] for _ in range(26)]",
      "mutated_line": "adj = [[] for _ in range(25)]",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(25)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj = [[] for _ in range(26)]",
      "mutated_line": "adj = [[] for _ in range(0)]",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(0)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj = [[] for _ in range(26)]",
      "mutated_line": "adj = [[] for _ in range(1)]",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(1)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj = [[] for _ in range(26)]",
      "mutated_line": "adj = [[] for _ in range(-26)]",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(-26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "u = ord(i[0]) - ord('a')",
      "mutated_line": "u = ord(i[0]) - ord('')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "v = ord(i[-1]) - ord('a')",
      "mutated_line": "v = ord(i[-1]) - ord('')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[0][0]) - ord(''), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord(''), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if not vis[i] and mark[i] == 1:",
      "mutated_line": "if not vis[i] and mark[i] == 2:",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 2:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if not vis[i] and mark[i] == 1:",
      "mutated_line": "if not vis[i] and mark[i] == 0:",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 0:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if not vis[i] and mark[i] == 1:",
      "mutated_line": "if not vis[i] and mark[i] == 0:",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 0:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if not vis[i] and mark[i] == 1:",
      "mutated_line": "if not vis[i] and mark[i] == -1:",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == -1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "u = ord(i[0]) - ord('a')",
      "mutated_line": "u = ord(i[1]) - ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[1]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "u = ord(i[0]) - ord('a')",
      "mutated_line": "u = ord(i[-1]) - ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[-1]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "u = ord(i[0]) - ord('a')",
      "mutated_line": "u = ord(i[1]) - ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[1]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "v = ord(i[-1]) - ord('a')",
      "mutated_line": "v = ord(i[+1]) - ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[+1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[0][1]) - ord('a'), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][1]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[0][-1]) - ord('a'), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][-1]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[0][1]) - ord('a'), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][1]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "v = ord(i[-1]) - ord('a')",
      "mutated_line": "v = ord(i[-2]) - ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-2]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "v = ord(i[-1]) - ord('a')",
      "mutated_line": "v = ord(i[-0]) - ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-0]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "v = ord(i[-1]) - ord('a')",
      "mutated_line": "v = ord(i[-0]) - ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-0]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "v = ord(i[-1]) - ord('a')",
      "mutated_line": "v = ord(i[--1]) - ord('a')",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[--1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[1][0]) - ord('a'), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[1][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[-1][0]) - ord('a'), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[-1][0]) - ord('a'), adj, mark)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return detect_cycle(ord(A[0][0]) - ord('a'), adj, mark)",
      "mutated_line": "return detect_cycle(ord(A[1][0]) - ord('a'), adj, mark)",
      "code": "def can_form_circle(N, A):\n\n    def dfs(node, adj, vis):\n        vis[node] = 1\n        for i in adj[node]:\n            if not vis[i]:\n                dfs(i, adj, vis)\n\n    def detect_cycle(src, adj, mark):\n        vis = [0] * 26\n        dfs(src, adj, vis)\n        for i in range(26):\n            if not vis[i] and mark[i] == 1:\n                return 0\n        return 1\n    mark = [0] * 26\n    adj = [[] for _ in range(26)]\n    in_degree = [0] * 26\n    out_degree = [0] * 26\n    for i in A:\n        u = ord(i[0]) - ord('a')\n        v = ord(i[-1]) - ord('a')\n        adj[u].append(v)\n        mark[u] = mark[v] = 1\n        in_degree[v] += 1\n        out_degree[u] += 1\n    for i in range(26):\n        if in_degree[i] != out_degree[i]:\n            return 0\n    return detect_cycle(ord(A[1][0]) - ord('a'), adj, mark)"
    }
  ]
}