{
  "task_id": "taco_18260",
  "entry_point": "min_cost_to_merge_stones",
  "mutant_count": 97,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K - 1) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) == 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) * (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) * (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if n - 1 + (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if n - 1 + (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K - 1) != 1:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 1:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K - 1) != -1:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != -1:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K - 1) != 1:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 1:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return +1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prefix = [0]",
      "mutated_line": "prefix = [1]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [1]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prefix = [0]",
      "mutated_line": "prefix = [-1]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [-1]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prefix = [0]",
      "mutated_line": "prefix = [1]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [1]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j - i + 1 <= K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 <= K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j - i + 1 >= K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 >= K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j - i + 1 != K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 != K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 1\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = -1\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 1\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) != 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res - min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res - min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res * min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res * min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(1, n - 1)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(1, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(-1, n - 1)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(-1, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(1, n - 1)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(1, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(0, n + 1)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(0, n * 1)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n * 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n + 1) % (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n + 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if n * 1 % (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if n * 1 % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K + 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K + 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K * 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K * 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -2\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -0\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -0\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return --1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "prefix.append(prefix[-1] + s)",
      "mutated_line": "prefix.append(prefix[-1] - s)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] - s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "prefix.append(prefix[-1] + s)",
      "mutated_line": "prefix.append(prefix[-1] * s)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] * s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j - i - 1 < K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i - 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if (j - i) * 1 < K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if (j - i) * 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 1\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return -1\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 1\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) * (K - 1) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) * (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if j - i + (K - 1) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if j - i + (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K - 1) == 1:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 1:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K - 1) == -1:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == -1:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K - 1) == 1:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 1:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res = prefix[j + 1] - prefix[i]",
      "mutated_line": "res = prefix[j + 1] + prefix[i]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] + prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res = prefix[j + 1] - prefix[i]",
      "mutated_line": "res = prefix[j + 1] * prefix[i]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] * prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(0, n - 2)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(0, n - 0)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(0, n - 0)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return dp(0, n - 1)",
      "mutated_line": "return dp(0, n - -1)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 2) % (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 2) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 0) % (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 0) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 0) % (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 0) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - -1) % (K - 1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - -1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K - 2) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 2) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K - 0) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 0) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K - 0) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 0) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if (n - 1) % (K - 1) != 0:",
      "mutated_line": "if (n - 1) % (K - -1) != 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - -1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j + i + 1 < K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j + i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j * i + 1 < K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j * i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j - i + 2 < K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 2 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j - i + 0 < K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 0 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j - i + 0 < K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 0 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j - i + 1 < K:",
      "mutated_line": "if j - i + -1 < K:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + -1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j + i) % (K - 1) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j + i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if j * i % (K - 1) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if j * i % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K + 1) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K + 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K * 1) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K * 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "prefix.append(prefix[-1] + s)",
      "mutated_line": "prefix.append(prefix[+1] + s)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[+1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K - 2) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 2) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K - 0) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 0) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K - 0) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 0) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (j - i) % (K - 1) == 0:",
      "mutated_line": "if (j - i) % (K - -1) == 0:",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - -1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res = prefix[j + 1] - prefix[i]",
      "mutated_line": "res = prefix[j - 1] - prefix[i]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j - 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res = prefix[j + 1] - prefix[i]",
      "mutated_line": "res = prefix[j * 1] - prefix[i]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j * 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) - dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) - dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) * dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) * dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prefix.append(prefix[-1] + s)",
      "mutated_line": "prefix.append(prefix[-2] + s)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-2] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prefix.append(prefix[-1] + s)",
      "mutated_line": "prefix.append(prefix[-0] + s)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-0] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prefix.append(prefix[-1] + s)",
      "mutated_line": "prefix.append(prefix[-0] + s)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-0] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prefix.append(prefix[-1] + s)",
      "mutated_line": "prefix.append(prefix[--1] + s)",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[--1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = prefix[j + 1] - prefix[i]",
      "mutated_line": "res = prefix[j + 2] - prefix[i]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 2] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = prefix[j + 1] - prefix[i]",
      "mutated_line": "res = prefix[j + 0] - prefix[i]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 0] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = prefix[j + 1] - prefix[i]",
      "mutated_line": "res = prefix[j + 0] - prefix[i]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 0] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = prefix[j + 1] - prefix[i]",
      "mutated_line": "res = prefix[j + -1] - prefix[i]",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + -1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid - 1, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid - 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid * 1, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid * 1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K + 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K + 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K * 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K * 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 2, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 2, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 0, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 0, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 0, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 0, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + -1, j) for mid in range(i, j, K - 1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + -1, j) for mid in range(i, j, K - 1)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 2)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 2)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 0)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 0)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 0)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 0)))\n    return dp(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1)))",
      "mutated_line": "return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - -1)))",
      "code": "from functools import lru_cache\nfrom typing import List\n\ndef min_cost_to_merge_stones(stones: List[int], K: int) -> int:\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    prefix = [0]\n    for s in stones:\n        prefix.append(prefix[-1] + s)\n\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i + 1 < K:\n            return 0\n        res = 0\n        if (j - i) % (K - 1) == 0:\n            res = prefix[j + 1] - prefix[i]\n        return res + min((dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - -1)))\n    return dp(0, n - 1)"
    }
  ]
}