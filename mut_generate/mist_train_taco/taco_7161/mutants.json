{
  "task_id": "taco_7161",
  "entry_point": "find_lowest_common_ancestor",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(500000)",
      "mutated_line": "sys.setrecursionlimit(500001)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500001)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(500000)",
      "mutated_line": "sys.setrecursionlimit(499999)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(499999)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(500000)",
      "mutated_line": "sys.setrecursionlimit(0)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(0)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(500000)",
      "mutated_line": "sys.setrecursionlimit(1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(1)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(500000)",
      "mutated_line": "sys.setrecursionlimit(-500000)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(-500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "lca = Lca(edges, 0)",
      "mutated_line": "lca = Lca(edges, 1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 1)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "lca = Lca(edges, 0)",
      "mutated_line": "lca = Lca(edges, -1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, -1)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "lca = Lca(edges, 0)",
      "mutated_line": "lca = Lca(edges, 1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 1)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.logn = 1",
      "mutated_line": "self.logn = 2",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 2\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.logn = 1",
      "mutated_line": "self.logn = 0",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 0\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.logn = 1",
      "mutated_line": "self.logn = 0",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 0\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.logn = 1",
      "mutated_line": "self.logn = -1",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = -1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while self.n >= 1 << self.logn:",
      "mutated_line": "while self.n > 1 << self.logn:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n > 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while self.n >= 1 << self.logn:",
      "mutated_line": "while self.n < 1 << self.logn:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n < 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while self.n >= 1 << self.logn:",
      "mutated_line": "while self.n == 1 << self.logn:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n == 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "self.logn += 1",
      "mutated_line": "self.logn -= 1",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn -= 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.depth = [0] * self.n",
      "mutated_line": "self.depth = [0] / self.n",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] / self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.depth = [0] * self.n",
      "mutated_line": "self.depth = [0] + self.n",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] + self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.depth = [0] * self.n",
      "mutated_line": "self.depth = [0] ** self.n",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] ** self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if self.depth[u] > self.depth[v]:",
      "mutated_line": "if self.depth[u] >= self.depth[v]:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] >= self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if self.depth[u] > self.depth[v]:",
      "mutated_line": "if self.depth[u] <= self.depth[v]:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] <= self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if self.depth[u] > self.depth[v]:",
      "mutated_line": "if self.depth[u] != self.depth[v]:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] != self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dep_diff = self.depth[v] - self.depth[u]",
      "mutated_line": "dep_diff = self.depth[v] + self.depth[u]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] + self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dep_diff = self.depth[v] - self.depth[u]",
      "mutated_line": "dep_diff = self.depth[v] * self.depth[u]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] * self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if u == v:",
      "mutated_line": "if u != v:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u != v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.logn += 1",
      "mutated_line": "self.logn += 2",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 2\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.logn += 1",
      "mutated_line": "self.logn += 0",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 0\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.logn += 1",
      "mutated_line": "self.logn += 0",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 0\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.logn += 1",
      "mutated_line": "self.logn += -1",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += -1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.parent = [[-1] * self.n for _ in range(self.logn)]",
      "mutated_line": "self.parent = [[-1] / self.n for _ in range(self.logn)]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] / self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.parent = [[-1] * self.n for _ in range(self.logn)]",
      "mutated_line": "self.parent = [[-1] + self.n for _ in range(self.logn)]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] + self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.parent = [[-1] * self.n for _ in range(self.logn)]",
      "mutated_line": "self.parent = [[-1] ** self.n for _ in range(self.logn)]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] ** self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "self.dfs(root, -1, 0)",
      "mutated_line": "self.dfs(root, +1, 0)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, +1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.dfs(root, -1, 0)",
      "mutated_line": "self.dfs(root, -1, 1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 1)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.dfs(root, -1, 0)",
      "mutated_line": "self.dfs(root, -1, -1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, -1)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.dfs(root, -1, 0)",
      "mutated_line": "self.dfs(root, -1, 1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 1)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for k in range(self.logn - 1):",
      "mutated_line": "for k in range(self.logn + 1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn + 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for k in range(self.logn - 1):",
      "mutated_line": "for k in range(self.logn * 1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn * 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if e != p:",
      "mutated_line": "if e == p:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e == p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if dep_diff >> k & 1:",
      "mutated_line": "if dep_diff >> k | 1:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k | 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn + 1, -1, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn + 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn * 1, -1, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn * 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, +1, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, +1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, -1, +1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, +1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if self.parent[k][u] != self.parent[k][v]:",
      "mutated_line": "if self.parent[k][u] == self.parent[k][v]:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] == self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while self.n >= 1 << self.logn:",
      "mutated_line": "while self.n >= 2 << self.logn:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 2 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while self.n >= 1 << self.logn:",
      "mutated_line": "while self.n >= 0 << self.logn:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 0 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while self.n >= 1 << self.logn:",
      "mutated_line": "while self.n >= 0 << self.logn:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 0 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while self.n >= 1 << self.logn:",
      "mutated_line": "while self.n >= -1 << self.logn:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= -1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.depth = [0] * self.n",
      "mutated_line": "self.depth = [1] * self.n",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [1] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.depth = [0] * self.n",
      "mutated_line": "self.depth = [-1] * self.n",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [-1] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.depth = [0] * self.n",
      "mutated_line": "self.depth = [1] * self.n",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [1] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.dfs(root, -1, 0)",
      "mutated_line": "self.dfs(root, -2, 0)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -2, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.dfs(root, -1, 0)",
      "mutated_line": "self.dfs(root, -0, 0)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -0, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.dfs(root, -1, 0)",
      "mutated_line": "self.dfs(root, -0, 0)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -0, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.dfs(root, -1, 0)",
      "mutated_line": "self.dfs(root, --1, 0)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, --1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(self.logn - 1):",
      "mutated_line": "for k in range(self.logn - 2):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 2):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(self.logn - 1):",
      "mutated_line": "for k in range(self.logn - 0):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 0):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(self.logn - 1):",
      "mutated_line": "for k in range(self.logn - 0):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 0):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(self.logn - 1):",
      "mutated_line": "for k in range(self.logn - -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - -1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p_ >= 0:",
      "mutated_line": "if p_ > 0:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ > 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p_ >= 0:",
      "mutated_line": "if p_ < 0:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ < 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p_ >= 0:",
      "mutated_line": "if p_ == 0:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ == 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.parent[0][v] = p",
      "mutated_line": "self.parent[1][v] = p",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[1][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.parent[0][v] = p",
      "mutated_line": "self.parent[-1][v] = p",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[-1][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.parent[0][v] = p",
      "mutated_line": "self.parent[1][v] = p",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[1][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if dep_diff >> k & 1:",
      "mutated_line": "if dep_diff >> k & 2:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 2:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if dep_diff >> k & 1:",
      "mutated_line": "if dep_diff >> k & 0:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 0:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if dep_diff >> k & 1:",
      "mutated_line": "if dep_diff >> k & 0:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 0:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if dep_diff >> k & 1:",
      "mutated_line": "if dep_diff >> k & -1:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & -1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 2, -1, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 2, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 0, -1, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 0, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 0, -1, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 0, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - -1, -1, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - -1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, -2, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -2, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, -0, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -0, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, -0, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -0, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, --1, -1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, --1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, -1, -2):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -2):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, -1, -0):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -0):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, -1, -0):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -0):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(self.logn - 1, -1, -1):",
      "mutated_line": "for k in range(self.logn - 1, -1, --1):",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, --1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return self.parent[0][u]",
      "mutated_line": "return self.parent[1][u]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[1][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return self.parent[0][u]",
      "mutated_line": "return self.parent[-1][u]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[-1][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return self.parent[0][u]",
      "mutated_line": "return self.parent[1][u]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[1][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "self.parent = [[-1] * self.n for _ in range(self.logn)]",
      "mutated_line": "self.parent = [[+1] * self.n for _ in range(self.logn)]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[+1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p_ >= 0:",
      "mutated_line": "if p_ >= 1:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 1:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p_ >= 0:",
      "mutated_line": "if p_ >= -1:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= -1:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p_ >= 0:",
      "mutated_line": "if p_ >= 1:",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 1:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.dfs(e, v, dep + 1)",
      "mutated_line": "self.dfs(e, v, dep - 1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep - 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.dfs(e, v, dep + 1)",
      "mutated_line": "self.dfs(e, v, dep * 1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep * 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.parent = [[-1] * self.n for _ in range(self.logn)]",
      "mutated_line": "self.parent = [[-2] * self.n for _ in range(self.logn)]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-2] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.parent = [[-1] * self.n for _ in range(self.logn)]",
      "mutated_line": "self.parent = [[-0] * self.n for _ in range(self.logn)]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-0] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.parent = [[-1] * self.n for _ in range(self.logn)]",
      "mutated_line": "self.parent = [[-0] * self.n for _ in range(self.logn)]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-0] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.parent = [[-1] * self.n for _ in range(self.logn)]",
      "mutated_line": "self.parent = [[--1] * self.n for _ in range(self.logn)]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[--1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.dfs(e, v, dep + 1)",
      "mutated_line": "self.dfs(e, v, dep + 2)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 2)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.dfs(e, v, dep + 1)",
      "mutated_line": "self.dfs(e, v, dep + 0)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 0)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.dfs(e, v, dep + 1)",
      "mutated_line": "self.dfs(e, v, dep + 0)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 0)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.dfs(e, v, dep + 1)",
      "mutated_line": "self.dfs(e, v, dep + -1)",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + -1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "self.parent[k + 1][v] = self.parent[k][p_]",
      "mutated_line": "self.parent[k - 1][v] = self.parent[k][p_]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k - 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "self.parent[k + 1][v] = self.parent[k][p_]",
      "mutated_line": "self.parent[k * 1][v] = self.parent[k][p_]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k * 1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.parent[k + 1][v] = self.parent[k][p_]",
      "mutated_line": "self.parent[k + 2][v] = self.parent[k][p_]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 2][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.parent[k + 1][v] = self.parent[k][p_]",
      "mutated_line": "self.parent[k + 0][v] = self.parent[k][p_]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 0][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.parent[k + 1][v] = self.parent[k][p_]",
      "mutated_line": "self.parent[k + 0][v] = self.parent[k][p_]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + 0][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.parent[k + 1][v] = self.parent[k][p_]",
      "mutated_line": "self.parent[k + -1][v] = self.parent[k][p_]",
      "code": "def find_lowest_common_ancestor(n, edges, queries):\n    import sys\n    sys.setrecursionlimit(500000)\n\n    class Lca:\n\n        def __init__(self, E, root):\n            self.root = root\n            self.E = E\n            self.n = len(E)\n            self.logn = 1\n            while self.n >= 1 << self.logn:\n                self.logn += 1\n            self.parent = [[-1] * self.n for _ in range(self.logn)]\n            self.depth = [0] * self.n\n            self.dfs(root, -1, 0)\n            for k in range(self.logn - 1):\n                for v in range(self.n):\n                    p_ = self.parent[k][v]\n                    if p_ >= 0:\n                        self.parent[k + -1][v] = self.parent[k][p_]\n\n        def dfs(self, v, p, dep):\n            self.parent[0][v] = p\n            self.depth[v] = dep\n            for e in self.E[v]:\n                if e != p:\n                    self.dfs(e, v, dep + 1)\n\n        def get(self, u, v):\n            if self.depth[u] > self.depth[v]:\n                (u, v) = (v, u)\n            dep_diff = self.depth[v] - self.depth[u]\n            for k in range(self.logn):\n                if dep_diff >> k & 1:\n                    v = self.parent[k][v]\n            if u == v:\n                return u\n            for k in range(self.logn - 1, -1, -1):\n                if self.parent[k][u] != self.parent[k][v]:\n                    u = self.parent[k][u]\n                    v = self.parent[k][v]\n            return self.parent[0][u]\n    lca = Lca(edges, 0)\n    results = []\n    for (u, v) in queries:\n        results.append(lca.get(u, v))\n    return results"
    }
  ]
}