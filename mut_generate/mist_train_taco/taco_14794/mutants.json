{
  "task_id": "taco_14794",
  "entry_point": "smallest_sum_of_digits_of_multiple",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K + 1] / K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] / K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K + 1] + K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] + K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K + 1] ** K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] ** K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lst[1] = 1",
      "mutated_line": "lst[1] = 2",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 2\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lst[1] = 1",
      "mutated_line": "lst[1] = 0",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 0\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lst[1] = 1",
      "mutated_line": "lst[1] = 0",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 0\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lst[1] = 1",
      "mutated_line": "lst[1] = -1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = -1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lst[1] = 1",
      "mutated_line": "lst[2] = 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[2] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lst[1] = 1",
      "mutated_line": "lst[0] = 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[0] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lst[1] = 1",
      "mutated_line": "lst[0] = 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[0] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lst[1] = 1",
      "mutated_line": "lst[-1] = 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[-1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 10 % K] >= lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] >= lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 10 % K] <= lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] <= lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 10 % K] != lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] != lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] > lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] > lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] < lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] < lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] == lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] == lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[1]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[-1]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[1]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K - 1] * K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K - 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K * 1] * K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K * 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = collections.deque([1])",
      "mutated_line": "q = collections.deque([2])",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([2])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = collections.deque([1])",
      "mutated_line": "q = collections.deque([0])",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([0])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = collections.deque([1])",
      "mutated_line": "q = collections.deque([0])",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([0])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "q = collections.deque([1])",
      "mutated_line": "q = collections.deque([-1])",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([-1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] >= lst[a] - 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] - 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] >= lst[a] * 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] * 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 1) % K] = lst[a] - 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] - 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 1) % K] = lst[a] * 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] * 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K + 2] * K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 2] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K + 0] * K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 0] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K + 0] * K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 0] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "lst = [K + 1] * K",
      "mutated_line": "lst = [K + -1] * K",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + -1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 10 * K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 * K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 10 + K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 + K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a * 10 * K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 * K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a * 10 + K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 + K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a * 10 * K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 * K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a * 10 + K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 + K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) * K] >= lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) * K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[a + 1 + K] >= lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[a + 1 + K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] >= lst[a] + 2:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 2:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] >= lst[a] + 0:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 0:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] >= lst[a] + 0:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 0:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 1) % K] >= lst[a] + -1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + -1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 1) * K] = lst[a] + 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) * K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[a + 1 + K] = lst[a] + 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[a + 1 + K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 1) % K] = lst[a] + 2",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 2\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 1) % K] = lst[a] + 0",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 0\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 1) % K] = lst[a] + 0",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 0\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 1) % K] = lst[a] + -1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + -1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "q.appendleft((a + 1) % K)",
      "mutated_line": "q.appendleft((a + 1) * K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) * K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "q.appendleft((a + 1) % K)",
      "mutated_line": "q.appendleft(a + 1 + K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft(a + 1 + K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a / 10 % K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a / 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[(a + 10) % K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[(a + 10) % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a ** 10 % K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a ** 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a / 10 % K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a / 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[(a + 10) % K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[(a + 10) % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a ** 10 % K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a ** 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a / 10 % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a / 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append((a + 10) % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append((a + 10) % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a ** 10 % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a ** 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a - 1) % K] >= lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a - 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[a * 1 % K] >= lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[a * 1 % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a - 1) % K] = lst[a] + 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a - 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[a * 1 % K] = lst[a] + 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[a * 1 % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "q.appendleft((a + 1) % K)",
      "mutated_line": "q.appendleft((a - 1) % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a - 1) % K)\n    return lst[0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "q.appendleft((a + 1) % K)",
      "mutated_line": "q.appendleft(a * 1 % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft(a * 1 % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 11 % K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 11 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 9 % K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 9 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 0 % K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 0 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * 1 % K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 1 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if lst[a * 10 % K] > lst[a]:",
      "mutated_line": "if lst[a * -10 % K] > lst[a]:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * -10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a * 11 % K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 11 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a * 9 % K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 9 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a * 0 % K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 0 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a * 1 % K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 1 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "lst[a * 10 % K] = lst[a]",
      "mutated_line": "lst[a * -10 % K] = lst[a]",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * -10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a * 11 % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 11 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a * 9 % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 9 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a * 0 % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 0 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a * 1 % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 1 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "q.append(a * 10 % K)",
      "mutated_line": "q.append(a * -10 % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * -10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 2) % K] >= lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 2) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 0) % K] >= lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 0) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + 0) % K] >= lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 0) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lst[(a + 1) % K] >= lst[a] + 1:",
      "mutated_line": "if lst[(a + -1) % K] >= lst[a] + 1:",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + -1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 2) % K] = lst[a] + 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 2) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 0) % K] = lst[a] + 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 0) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + 0) % K] = lst[a] + 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 0) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "lst[(a + 1) % K] = lst[a] + 1",
      "mutated_line": "lst[(a + -1) % K] = lst[a] + 1",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + -1) % K] = lst[a] + 1\n            q.appendleft((a + 1) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "q.appendleft((a + 1) % K)",
      "mutated_line": "q.appendleft((a + 2) % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 2) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "q.appendleft((a + 1) % K)",
      "mutated_line": "q.appendleft((a + 0) % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 0) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "q.appendleft((a + 1) % K)",
      "mutated_line": "q.appendleft((a + 0) % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + 0) % K)\n    return lst[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "q.appendleft((a + 1) % K)",
      "mutated_line": "q.appendleft((a + -1) % K)",
      "code": "import collections\n\ndef smallest_sum_of_digits_of_multiple(K: int) -> int:\n    lst = [K + 1] * K\n    q = collections.deque([1])\n    lst[1] = 1\n    while q:\n        a = q.pop()\n        if lst[a * 10 % K] > lst[a]:\n            lst[a * 10 % K] = lst[a]\n            q.append(a * 10 % K)\n        if lst[(a + 1) % K] >= lst[a] + 1:\n            lst[(a + 1) % K] = lst[a] + 1\n            q.appendleft((a + -1) % K)\n    return lst[0]"
    }
  ]
}