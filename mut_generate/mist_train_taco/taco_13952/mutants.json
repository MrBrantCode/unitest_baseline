{
  "task_id": "taco_13952",
  "entry_point": "minimum_maintenance_cost",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "self.parents[x] += self.parents[y]",
      "mutated_line": "self.parents[x] -= self.parents[y]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] -= self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 1\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = -1\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 1\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] / (n + 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] / (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] + (n + 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] + (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] ** (n + 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] ** (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] <= 0:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] <= 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] >= 0:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] >= 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] != 0:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] != 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if x == y:",
      "mutated_line": "if x != y:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x != y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if self.parents[x] > self.parents[y]:",
      "mutated_line": "if self.parents[x] >= self.parents[y]:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] >= self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if self.parents[x] > self.parents[y]:",
      "mutated_line": "if self.parents[x] <= self.parents[y]:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] <= self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if self.parents[x] > self.parents[y]:",
      "mutated_line": "if self.parents[x] != self.parents[y]:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] != self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "return -self.parents[self.find(x)]",
      "mutated_line": "return +self.parents[self.find(x)]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return +self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return self.find(x) == self.find(y)",
      "mutated_line": "return self.find(x) != self.find(y)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) != self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "res += cost",
      "mutated_line": "res -= cost",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res -= cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] * (n - 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n - 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] * (n * 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n * 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] < 1:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 1:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] < -1:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < -1:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] < 1:",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 1:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [+1] * (n + 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [+1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] * (n + 2)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 2)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] * (n + 0)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 0)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] * (n + 0)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 0)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-1] * (n + -1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + -1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return [i for i in range(self.n + 1) if self.find(i) == root]",
      "mutated_line": "return [i for i in range(self.n + 1) if self.find(i) != root]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) != root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x <= 0]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x <= 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x >= 0]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x >= 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x != 0]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x != 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))",
      "mutated_line": "return ''.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return ''.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-2] * (n + 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-2] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-0] * (n + 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-0] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [-0] * (n + 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-0] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.parents = [-1] * (n + 1)",
      "mutated_line": "self.parents = [--1] * (n + 1)",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [--1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return [i for i in range(self.n + 1) if self.find(i) == root]",
      "mutated_line": "return [i for i in range(self.n - 1) if self.find(i) == root]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n - 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return [i for i in range(self.n + 1) if self.find(i) == root]",
      "mutated_line": "return [i for i in range(self.n * 1) if self.find(i) == root]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n * 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x < 1]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 1]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x < -1]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < -1]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x < 1]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 1]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return [i for i in range(self.n + 1) if self.find(i) == root]",
      "mutated_line": "return [i for i in range(self.n + 2) if self.find(i) == root]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 2) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return [i for i in range(self.n + 1) if self.find(i) == root]",
      "mutated_line": "return [i for i in range(self.n + 0) if self.find(i) == root]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 0) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return [i for i in range(self.n + 1) if self.find(i) == root]",
      "mutated_line": "return [i for i in range(self.n + 0) if self.find(i) == root]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 0) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return [i for i in range(self.n + 1) if self.find(i) == root]",
      "mutated_line": "return [i for i in range(self.n + -1) if self.find(i) == root]",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + -1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))",
      "mutated_line": "return '\\n'.join((''.format(r, self.members(r)) for r in self.roots()))",
      "code": "def minimum_maintenance_cost(n, m, bridges):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if x == y:\n                return\n            if self.parents[x] > self.parents[y]:\n                (x, y) = (y, x)\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n + 1) if self.find(i) == root]\n\n        def roots(self):\n            return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join((''.format(r, self.members(r)) for r in self.roots()))\n\n    def kruskal(edge, N):\n        res = 0\n        node = []\n        G = UnionFind(N)\n        for (cost, p, q) in edge:\n            if not G.same(p, q):\n                G.union(p, q)\n                res += cost\n        return res\n    edge = [(cost, a, b) for (a, b, cost) in bridges]\n    edge.sort()\n    return kruskal(edge, n)"
    }
  ]
}