{
  "task_id": "taco_1841",
  "entry_point": "sign",
  "mutant_count": 97,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "eps = 1e-09",
      "mutated_line": "eps = 1.000000001",
      "code": "import math\neps = 1.000000001\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "eps = 1e-09",
      "mutated_line": "eps = -0.999999999",
      "code": "import math\neps = -0.999999999\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "eps = 1e-09",
      "mutated_line": "eps = 0",
      "code": "import math\neps = 0\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "eps = 1e-09",
      "mutated_line": "eps = 1",
      "code": "import math\neps = 1\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "eps = 1e-09",
      "mutated_line": "eps = -1e-09",
      "code": "import math\neps = -1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n > eps:",
      "mutated_line": "if n >= eps:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n >= eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n > eps:",
      "mutated_line": "if n <= eps:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n <= eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n > eps:",
      "mutated_line": "if n != eps:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n != eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < -eps:",
      "mutated_line": "if n <= -eps:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n <= -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < -eps:",
      "mutated_line": "if n >= -eps:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n >= -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < -eps:",
      "mutated_line": "if n != -eps:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n != -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 1\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return -1\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 1\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return a.x * b.y - a.y * b.x",
      "mutated_line": "return a.x * b.y + a.y * b.x",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y + a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return a.x * b.y - a.y * b.x",
      "mutated_line": "return a.x * b.y * (a.y * b.x)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y * (a.y * b.x)\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 2\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 0\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 0\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return -1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "if n < -eps:",
      "mutated_line": "if n < +eps:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < +eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return +1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return a.x * b.y - a.y * b.x",
      "mutated_line": "return a.x / b.y - a.y * b.x",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x / b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return a.x * b.y - a.y * b.x",
      "mutated_line": "return a.x + b.y - a.y * b.x",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x + b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return a.x * b.y - a.y * b.x",
      "mutated_line": "return a.x ** b.y - a.y * b.x",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x ** b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return a.x * b.y - a.y * b.x",
      "mutated_line": "return a.x * b.y - a.y / b.x",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y / b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return a.x * b.y - a.y * b.x",
      "mutated_line": "return a.x * b.y - (a.y + b.x)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - (a.y + b.x)\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return a.x * b.y - a.y * b.x",
      "mutated_line": "return a.x * b.y - a.y ** b.x",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y ** b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [0] / 3",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] / 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [0] + 3",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] + 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [0] ** 3",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] ** 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "count += order",
      "mutated_line": "count -= order",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count -= order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -2\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -0\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -0\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return --1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return Vector(self.x + v.x, self.y + v.y)",
      "mutated_line": "return Vector(self.x - v.x, self.y + v.y)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x - v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return Vector(self.x + v.x, self.y + v.y)",
      "mutated_line": "return Vector(self.x * v.x, self.y + v.y)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x * v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return Vector(self.x + v.x, self.y + v.y)",
      "mutated_line": "return Vector(self.x + v.x, self.y - v.y)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y - v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return Vector(self.x + v.x, self.y + v.y)",
      "mutated_line": "return Vector(self.x + v.x, self.y * v.y)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y * v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return Vector(self.x - v.x, self.y - v.y)",
      "mutated_line": "return Vector(self.x + v.x, self.y - v.y)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x + v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return Vector(self.x - v.x, self.y - v.y)",
      "mutated_line": "return Vector(self.x * v.x, self.y - v.y)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x * v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return Vector(self.x - v.x, self.y - v.y)",
      "mutated_line": "return Vector(self.x - v.x, self.y + v.y)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y + v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return Vector(self.x - v.x, self.y - v.y)",
      "mutated_line": "return Vector(self.x - v.x, self.y * v.y)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y * v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[1:] - polygon[:1]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] - polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[1:] * polygon[:1]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] * polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if ss == es:",
      "mutated_line": "if ss != es:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss != es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a - p, a - b) * cross(q - p, a - b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) * cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a - p, a - b) // cross(q - p, a - b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) // cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [0] * 4",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 4\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [0] * 2",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 2\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [0] * 0",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 0\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [0] * 1",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 1\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [0] * -3",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * -3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if count > 0:",
      "mutated_line": "if count >= 0:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count >= 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if count > 0:",
      "mutated_line": "if count <= 0:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count <= 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if count > 0:",
      "mutated_line": "if count != 0:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count != 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "total_t += t - previous_t",
      "mutated_line": "total_t -= t - previous_t",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t -= t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(total_t * (q - p).length())",
      "mutated_line": "results.append(total_t / (q - p).length())",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t / (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(total_t * (q - p).length())",
      "mutated_line": "results.append(total_t + (q - p).length())",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t + (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(total_t * (q - p).length())",
      "mutated_line": "results.append(total_t ** (q - p).length())",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t ** (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [1] * 3",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [1] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [-1] * 3",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [-1] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "(total_t, previous_t, count) = [0] * 3",
      "mutated_line": "(total_t, previous_t, count) = [1] * 3",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [1] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if count > 0:",
      "mutated_line": "if count > 1:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 1:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if count > 0:",
      "mutated_line": "if count > -1:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > -1:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if count > 0:",
      "mutated_line": "if count > 1:",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 1:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "total_t += t - previous_t",
      "mutated_line": "total_t += t + previous_t",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t + previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "total_t += t - previous_t",
      "mutated_line": "total_t += t * previous_t",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t * previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ss = sign(cross(a - p, q - p))",
      "mutated_line": "ss = sign(cross(a + p, q - p))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a + p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ss = sign(cross(a - p, q - p))",
      "mutated_line": "ss = sign(cross(a * p, q - p))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a * p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ss = sign(cross(a - p, q - p))",
      "mutated_line": "ss = sign(cross(a - p, q + p))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q + p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ss = sign(cross(a - p, q - p))",
      "mutated_line": "ss = sign(cross(a - p, q * p))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q * p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "es = sign(cross(b - p, q - p))",
      "mutated_line": "es = sign(cross(b + p, q - p))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b + p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "es = sign(cross(b - p, q - p))",
      "mutated_line": "es = sign(cross(b * p, q - p))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b * p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "es = sign(cross(b - p, q - p))",
      "mutated_line": "es = sign(cross(b - p, q + p))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q + p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "es = sign(cross(b - p, q - p))",
      "mutated_line": "es = sign(cross(b - p, q * p))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q * p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a + p, a - b) / cross(q - p, a - b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a + p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a * p, a - b) / cross(q - p, a - b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a * p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a - p, a + b) / cross(q - p, a - b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a + b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a - p, a * b) / cross(q - p, a - b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a * b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a - p, a - b) / cross(q + p, a - b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q + p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a - p, a - b) / cross(q * p, a - b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q * p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a - p, a - b) / cross(q - p, a + b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a + b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "t = cross(a - p, a - b) / cross(q - p, a - b)",
      "mutated_line": "t = cross(a - p, a - b) / cross(q - p, a * b)",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a * b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "intersections.append((t, es - ss))",
      "mutated_line": "intersections.append((t, es + ss))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es + ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "intersections.append((t, es - ss))",
      "mutated_line": "intersections.append((t, es * ss))",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es * ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[2:] + polygon[:1]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[2:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[0:] + polygon[:1]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[0:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[0:] + polygon[:1]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[0:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[-1:] + polygon[:1]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[-1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[1:] + polygon[:2]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:2]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[1:] + polygon[:0]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:0]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[1:] + polygon[:0]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:0]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a, b in zip(polygon, polygon[1:] + polygon[:1]):",
      "mutated_line": "for (a, b) in zip(polygon, polygon[1:] + polygon[:-1]):",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:-1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q - p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(total_t * (q - p).length())",
      "mutated_line": "results.append(total_t * (q + p).length())",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q + p).length())\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(total_t * (q - p).length())",
      "mutated_line": "results.append(total_t * (q * p).length())",
      "code": "import math\neps = 1e-09\n\ndef sign(n):\n    if n > eps:\n        return 1\n    if n < -eps:\n        return -1\n    return 0\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\nclass Vector:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector(self.x + v.x, self.y + v.y)\n\n    def __sub__(self, v):\n        return Vector(self.x - v.x, self.y - v.y)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\ndef calculate_line_polygon_intersection_length(polygon, lines):\n    results = []\n    for (p, q) in lines:\n        intersections = []\n        for (a, b) in zip(polygon, polygon[1:] + polygon[:1]):\n            ss = sign(cross(a - p, q - p))\n            es = sign(cross(b - p, q - p))\n            if ss == es:\n                continue\n            t = cross(a - p, a - b) / cross(q - p, a - b)\n            intersections.append((t, es - ss))\n        intersections = sorted(intersections)\n        (total_t, previous_t, count) = [0] * 3\n        for (t, order) in intersections:\n            if count > 0:\n                total_t += t - previous_t\n            previous_t = t\n            count += order\n        results.append(total_t * (q * p).length())\n    return results"
    }
  ]
}