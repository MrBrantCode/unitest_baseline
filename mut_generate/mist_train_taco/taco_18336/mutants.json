{
  "task_id": "taco_18336",
  "entry_point": "calculate_super_highway_cost",
  "mutant_count": 188,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 9 - 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 - 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 9 * 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 * 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n <= 2:",
      "mutated_line": "if n < 2:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n < 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n <= 2:",
      "mutated_line": "if n > 2:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n > 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n <= 2:",
      "mutated_line": "if n == 2:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n == 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 1\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = -1\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 1\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "bin = 1",
      "mutated_line": "bin = 2",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 2\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "bin = 1",
      "mutated_line": "bin = 0",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 0\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "bin = 1",
      "mutated_line": "bin = 0",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 0\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "bin = 1",
      "mutated_line": "bin = -1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = -1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) * modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) * modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = ans * modular_inverse(k + 1, modulus) - 1 + modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = ans * modular_inverse(k + 1, modulus) - 1 + modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 * 9 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 * 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 + 9 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 + 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 9 + 10",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 10\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 9 + 8",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 8\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 9 + 0",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 0\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 9 + 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 1\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 9 + -9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + -9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sm1 = 1",
      "mutated_line": "sm1 = 2",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 2\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sm1 = 1",
      "mutated_line": "sm1 = 0",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 0\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sm1 = 1",
      "mutated_line": "sm1 = 0",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 0\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sm1 = 1",
      "mutated_line": "sm1 = -1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = -1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tm1 = 0",
      "mutated_line": "tm1 = 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 1\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tm1 = 0",
      "mutated_line": "tm1 = -1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = -1\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tm1 = 0",
      "mutated_line": "tm1 = 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 1\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 1\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = -1\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 1\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = 1",
      "mutated_line": "t = 2",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 2\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = 1",
      "mutated_line": "t = 0",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 0\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = 1",
      "mutated_line": "t = 0",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 0\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = 1",
      "mutated_line": "t = -1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = -1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while r != 0:",
      "mutated_line": "while r == 0:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r == 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "bern = bernoulli_mod(1001, modulus)",
      "mutated_line": "bern = bernoulli_mod(1002, modulus)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1002, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "bern = bernoulli_mod(1001, modulus)",
      "mutated_line": "bern = bernoulli_mod(1000, modulus)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1000, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "bern = bernoulli_mod(1001, modulus)",
      "mutated_line": "bern = bernoulli_mod(0, modulus)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(0, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "bern = bernoulli_mod(1001, modulus)",
      "mutated_line": "bern = bernoulli_mod(1, modulus)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "bern = bernoulli_mod(1001, modulus)",
      "mutated_line": "bern = bernoulli_mod(-1001, modulus)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(-1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 3:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 3:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 1:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 1:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 0:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 0:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= 1:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 1:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n <= 2:",
      "mutated_line": "if n <= -2:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= -2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 1\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return -1\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 1\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k - 1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k - 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k * 1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k * 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) * modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) * modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus) + modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus) + modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) * modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) * modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) + modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) + modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 1, modulus) + 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) + 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = ans * modular_inverse(k + 1, modulus) * 1 % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = ans * modular_inverse(k + 1, modulus) * 1 % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 11 ** 9 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 11 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 9 ** 9 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 9 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 0 ** 9 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 0 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 1 ** 9 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 1 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = -10 ** 9 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = -10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 10 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 10 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 8 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 8 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 0 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 0 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** 1 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 1 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "modulus = 10 ** 9 + 9",
      "mutated_line": "modulus = 10 ** -9 + 9",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** -9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while r != 0:",
      "mutated_line": "while r != 1:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 1:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while r != 0:",
      "mutated_line": "while r != -1:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != -1:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while r != 0:",
      "mutated_line": "while r != 1:",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 1:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "q = rm1 // r",
      "mutated_line": "q = rm1 / r",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 / r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "q = rm1 // r",
      "mutated_line": "q = rm1 * r",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 * r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = temp_r - q * rm1",
      "mutated_line": "r = temp_r + q * rm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r + q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = temp_r - q * rm1",
      "mutated_line": "r = temp_r * (q * rm1)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r * (q * rm1)\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = temp_s - q * sm1",
      "mutated_line": "s = temp_s + q * sm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s + q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = temp_s - q * sm1",
      "mutated_line": "s = temp_s * (q * sm1)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s * (q * sm1)\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t = temp_t - q * tm1",
      "mutated_line": "t = temp_t + q * tm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t + q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t = temp_t - q * tm1",
      "mutated_line": "t = temp_t * (q * tm1)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t * (q * tm1)\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for m in range(n + 1):",
      "mutated_line": "for m in range(n - 1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n - 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for m in range(n + 1):",
      "mutated_line": "for m in range(n * 1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n * 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 2):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 2):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 0):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 0):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 0):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 0):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + -1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + -1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans - bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans - bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = ans * (bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = ans * (bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) / modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) / modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = (bin * (k + 1 - j) + modular_inverse(j + 1, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = (bin * (k + 1 - j) + modular_inverse(j + 1, modulus)) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = (bin * (k + 1 - j)) ** modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = (bin * (k + 1 - j)) ** modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans / modular_inverse(k + 1, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans / modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans + modular_inverse(k + 1, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans + modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans ** modular_inverse(k + 1, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans ** modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 1, modulus) - 2) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 2) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 1, modulus) - 0) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 0) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 1, modulus) - 0) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 0) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 1, modulus) - -1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - -1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = temp_r - q * rm1",
      "mutated_line": "r = temp_r - q / rm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q / rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = temp_r - q * rm1",
      "mutated_line": "r = temp_r - (q + rm1)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - (q + rm1)\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = temp_r - q * rm1",
      "mutated_line": "r = temp_r - q ** rm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q ** rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = temp_s - q * sm1",
      "mutated_line": "s = temp_s - q / sm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q / sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = temp_s - q * sm1",
      "mutated_line": "s = temp_s - (q + sm1)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - (q + sm1)\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s = temp_s - q * sm1",
      "mutated_line": "s = temp_s - q ** sm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q ** sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t = temp_t - q * tm1",
      "mutated_line": "t = temp_t - q / tm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q / tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t = temp_t - q * tm1",
      "mutated_line": "t = temp_t - (q + tm1)",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - (q + tm1)\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "t = temp_t - q * tm1",
      "mutated_line": "t = temp_t - q ** tm1",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q ** tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for m in range(n + 1):",
      "mutated_line": "for m in range(n + 2):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 2):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for m in range(n + 1):",
      "mutated_line": "for m in range(n + 0):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 0):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for m in range(n + 1):",
      "mutated_line": "for m in range(n + 0):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 0):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for m in range(n + 1):",
      "mutated_line": "for m in range(n + -1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + -1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(m, 0, -1):",
      "mutated_line": "for j in range(m, 1, -1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 1, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(m, 0, -1):",
      "mutated_line": "for j in range(m, -1, -1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, -1, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(m, 0, -1):",
      "mutated_line": "for j in range(m, 1, -1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 1, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for j in range(m, 0, -1):",
      "mutated_line": "for j in range(m, 0, +1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, +1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j - 1] - A[j]) * modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) * modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j - 1] - A[j]) + modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) + modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] / pow(n - 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] / pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + (bin * bern[j] + pow(n - 1, k + 1 - j, modulus))) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + (bin * bern[j] + pow(n - 1, k + 1 - j, modulus))) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + (bin * bern[j]) ** pow(n - 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + (bin * bern[j]) ** pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin / (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin / (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = (bin + (k + 1 - j)) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = (bin + (k + 1 - j)) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin ** (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin ** (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "A.append(modular_inverse(m + 1, modulus))",
      "mutated_line": "A.append(modular_inverse(m - 1, modulus))",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m - 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "A.append(modular_inverse(m + 1, modulus))",
      "mutated_line": "A.append(modular_inverse(m * 1, modulus))",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m * 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(m, 0, -1):",
      "mutated_line": "for j in range(m, 0, -2):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -2):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(m, 0, -1):",
      "mutated_line": "for j in range(m, 0, -0):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -0):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(m, 0, -1):",
      "mutated_line": "for j in range(m, 0, -0):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -0):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(m, 0, -1):",
      "mutated_line": "for j in range(m, 0, --1):",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, --1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j + 1] = j * (A[j - 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j + 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j * 1] = j * (A[j - 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j * 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j / (A[j - 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j / (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = (j + (A[j - 1] - A[j])) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = (j + (A[j - 1] - A[j])) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j ** (A[j - 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j ** (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res.append(A[0])",
      "mutated_line": "res.append(A[1])",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[1])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res.append(A[0])",
      "mutated_line": "res.append(A[-1])",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[-1])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res.append(A[0])",
      "mutated_line": "res.append(A[1])",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[1])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin / bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin / bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + (bin + bern[j]) * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + (bin + bern[j]) * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin ** bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin ** bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 + j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 + j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * ((k + 1) * j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * ((k + 1) * j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) * modular_inverse(j - 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j - 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) * modular_inverse(j * 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j * 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k - 1, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k - 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k * 1, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k * 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "A.append(modular_inverse(m + 1, modulus))",
      "mutated_line": "A.append(modular_inverse(m + 2, modulus))",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 2, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "A.append(modular_inverse(m + 1, modulus))",
      "mutated_line": "A.append(modular_inverse(m + 0, modulus))",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 0, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "A.append(modular_inverse(m + 1, modulus))",
      "mutated_line": "A.append(modular_inverse(m + 0, modulus))",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 0, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "A.append(modular_inverse(m + 1, modulus))",
      "mutated_line": "A.append(modular_inverse(m + -1, modulus))",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + -1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 2] = j * (A[j - 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 2] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 0] = j * (A[j - 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 0] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 0] = j * (A[j - 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 0] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - -1] = j * (A[j - 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - -1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j - 1] + A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] + A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j - 1] * A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] * A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n + 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n + 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n * 1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n * 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 + j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 + j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, (k + 1) * j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, (k + 1) * j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k - 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k - 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k * 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k * 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 2, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 2, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 0, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 0, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 0, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 0, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 1 - j) * modular_inverse(j + -1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + -1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 2, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 2, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 0, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 0, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + 0, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 0, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus",
      "mutated_line": "ans = (ans * modular_inverse(k + -1, modulus) - 1) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + -1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 2, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 2, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 0, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 0, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 0, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 0, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - -1, k + 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - -1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, k - 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k - 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, k * 1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k * 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 2 - j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 2 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 0 - j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 0 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + 0 - j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 0 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "mutated_line": "bin = bin * (k + -1 - j) * modular_inverse(j + 1, modulus) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + -1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j + 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j + 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j * 1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j * 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 2 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 2 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 0 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 0 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 0 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 0 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus",
      "mutated_line": "ans = (ans + bin * bern[j] * pow(n - 1, k + -1 - j, modulus)) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + -1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j - 2] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 2] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j - 0] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 0] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j - 0] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - 0] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "A[j - 1] = j * (A[j - 1] - A[j]) % modulus",
      "mutated_line": "A[j - 1] = j * (A[j - -1] - A[j]) % modulus",
      "code": "def calculate_super_highway_cost(n, k):\n    modulus = 10 ** 9 + 9\n\n    def euclidean_alg(a, b):\n        rm1 = a\n        sm1 = 1\n        tm1 = 0\n        r = b\n        s = 0\n        t = 1\n        while r != 0:\n            q = rm1 // r\n            temp_r = rm1\n            temp_s = sm1\n            temp_t = tm1\n            rm1 = r\n            sm1 = s\n            tm1 = t\n            r = temp_r - q * rm1\n            s = temp_s - q * sm1\n            t = temp_t - q * tm1\n        return (rm1, sm1, tm1)\n\n    def modular_inverse(n, p):\n        (r, s, t) = euclidean_alg(n, p)\n        return s\n\n    def bernoulli_mod(n, modulus):\n        res = []\n        A = []\n        for m in range(n + 1):\n            A.append(modular_inverse(m + 1, modulus))\n            for j in range(m, 0, -1):\n                A[j - 1] = j * (A[j - -1] - A[j]) % modulus\n            res.append(A[0])\n        return res\n    bern = bernoulli_mod(1001, modulus)\n    if n <= 2:\n        return 0\n    ans = 0\n    bin = 1\n    for j in range(k + 1):\n        ans = (ans + bin * bern[j] * pow(n - 1, k + 1 - j, modulus)) % modulus\n        bin = bin * (k + 1 - j) * modular_inverse(j + 1, modulus) % modulus\n    ans = (ans * modular_inverse(k + 1, modulus) - 1) % modulus\n    return ans"
    }
  ]
}