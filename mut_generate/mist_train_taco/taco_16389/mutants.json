{
  "task_id": "taco_16389",
  "entry_point": "count_permutations_modulo",
  "mutant_count": 148,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M",
      "mutated_line": "ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) * M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) * M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M",
      "mutated_line": "ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) + M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) + M\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while z1 != 1:",
      "mutated_line": "while z1 == 1:",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 == 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return x1 % M",
      "mutated_line": "return x1 * M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 * M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return x1 % M",
      "mutated_line": "return x1 + M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 + M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 3 / (N - i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 / (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 3 + (N - i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 + (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 3 ** (N - i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 ** (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 1) + 3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) + 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 1) * 3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) * 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "r -= d_r",
      "mutated_line": "r += d_r",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r += d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "d_r -= 4",
      "mutated_line": "d_r += 4",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r += 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 * N + 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N + 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 * N * 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N * 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a += 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "b -= 3",
      "mutated_line": "b += 3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b += 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "def acc_mulmod(it, init=1):",
      "mutated_line": "def acc_mulmod(it, init=2):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=2):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "def acc_mulmod(it, init=1):",
      "mutated_line": "def acc_mulmod(it, init=0):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=0):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "def acc_mulmod(it, init=1):",
      "mutated_line": "def acc_mulmod(it, init=0):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=0):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "def acc_mulmod(it, init=1):",
      "mutated_line": "def acc_mulmod(it, init=-1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=-1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(x1, y1, z1) = (1, 0, x)",
      "mutated_line": "(x1, y1, z1) = (2, 0, x)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (2, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(x1, y1, z1) = (1, 0, x)",
      "mutated_line": "(x1, y1, z1) = (0, 0, x)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (0, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(x1, y1, z1) = (1, 0, x)",
      "mutated_line": "(x1, y1, z1) = (0, 0, x)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (0, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(x1, y1, z1) = (1, 0, x)",
      "mutated_line": "(x1, y1, z1) = (-1, 0, x)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (-1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(x1, y1, z1) = (1, 0, x)",
      "mutated_line": "(x1, y1, z1) = (1, 1, x)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 1, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(x1, y1, z1) = (1, 0, x)",
      "mutated_line": "(x1, y1, z1) = (1, -1, x)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, -1, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(x1, y1, z1) = (1, 0, x)",
      "mutated_line": "(x1, y1, z1) = (1, 1, x)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 1, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(x2, y2, z2) = (0, 1, M)",
      "mutated_line": "(x2, y2, z2) = (1, 1, M)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (1, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(x2, y2, z2) = (0, 1, M)",
      "mutated_line": "(x2, y2, z2) = (-1, 1, M)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (-1, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(x2, y2, z2) = (0, 1, M)",
      "mutated_line": "(x2, y2, z2) = (1, 1, M)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (1, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(x2, y2, z2) = (0, 1, M)",
      "mutated_line": "(x2, y2, z2) = (0, 2, M)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 2, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(x2, y2, z2) = (0, 1, M)",
      "mutated_line": "(x2, y2, z2) = (0, 0, M)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 0, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(x2, y2, z2) = (0, 1, M)",
      "mutated_line": "(x2, y2, z2) = (0, 0, M)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 0, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "(x2, y2, z2) = (0, 1, M)",
      "mutated_line": "(x2, y2, z2) = (0, -1, M)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, -1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while z1 != 1:",
      "mutated_line": "while z1 != 2:",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 2:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while z1 != 1:",
      "mutated_line": "while z1 != 0:",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 0:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while z1 != 1:",
      "mutated_line": "while z1 != 0:",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 0:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while z1 != 1:",
      "mutated_line": "while z1 != -1:",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != -1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 4 * (N - i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 4 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 2 * (N - i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 2 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 0 * (N - i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 0 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 1 * (N - i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 1 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = -3 * (N - i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = -3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 3 * (N + i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N + i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = 3 * (N - i)",
      "mutated_line": "s = 3 * (N * i)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N * i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s / (s - 1) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s / (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s + (s - 1) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s + (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s ** (s - 1) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s ** (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s - 1) >> 2",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 2\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s - 1) >> 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 0\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s - 1) >> 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 0\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s - 1) >> -1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> -1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 1) - 4",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 4\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 1) - 2",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 2\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 1) - 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 0\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 1) - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 1\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 1) - -3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - -3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(2, N - i + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(2, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(0, N - i + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(0, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(0, N - i + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(0, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(-1, N - i + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(-1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(1, N - i - 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i - 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(1, (N - i) * 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, (N - i) * 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d_r -= 4",
      "mutated_line": "d_r -= 5",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 5\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d_r -= 4",
      "mutated_line": "d_r -= 3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 3\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d_r -= 4",
      "mutated_line": "d_r -= 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 0\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d_r -= 4",
      "mutated_line": "d_r -= 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 1\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d_r -= 4",
      "mutated_line": "d_r -= -4",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= -4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 / N - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 / N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 + N - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 + N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 ** N - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 ** N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 * N - 2",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 2\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 * N - 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 0\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 * N - 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 0\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 3 * N - -1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - -1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(2, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(0, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(0, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(-1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N - 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N * 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 2\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 0\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 0\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= -1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b -= 3",
      "mutated_line": "b -= 4",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 4\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b -= 3",
      "mutated_line": "b -= 2",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 2\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b -= 3",
      "mutated_line": "b -= 0",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 0\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b -= 3",
      "mutated_line": "b -= 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 1\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b -= 3",
      "mutated_line": "b -= -3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= -3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "x = x * y % M",
      "mutated_line": "x = x * y * M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y * M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "x = x * y % M",
      "mutated_line": "x = x * y + M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y + M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(x1, x2) = (x2 - d * x1, x1)",
      "mutated_line": "(x1, x2) = (x2 + d * x1, x1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 + d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(x1, x2) = (x2 - d * x1, x1)",
      "mutated_line": "(x1, x2) = (x2 * (d * x1), x1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 * (d * x1), x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(y1, y2) = (y2 - d * y1, y1)",
      "mutated_line": "(y1, y2) = (y2 + d * y1, y1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 + d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(y1, y2) = (y2 - d * y1, y1)",
      "mutated_line": "(y1, y2) = (y2 * (d * y1), y1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 * (d * y1), y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s + 1) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s + 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s * 1) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s * 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 2) - 3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 2) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 0) - 3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 0) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << 0) - 3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 0) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d_r = (s << 1) - 3",
      "mutated_line": "d_r = (s << -1) - 3",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << -1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(1, N + i + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N + i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(1, N * i + 1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N * i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(1, N - i + 2):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 2):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(1, N - i + 0):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 0):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(1, N - i + 0):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 0):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N - i + 1):",
      "mutated_line": "for j in range(1, N - i + -1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + -1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "yield (r * mod_inv(j))",
      "mutated_line": "yield (r / mod_inv(j))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r / mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "yield (r * mod_inv(j))",
      "mutated_line": "yield (r + mod_inv(j))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r + mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "yield (r * mod_inv(j))",
      "mutated_line": "yield (r ** mod_inv(j))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r ** mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 4 * N - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 4 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 2 * N - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 2 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 0 * N - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 0 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = 1 * N - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 1 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 3 * N - 1",
      "mutated_line": "b = -3 * N - 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = -3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 2):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 0):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 0):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + -1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b * (b - 1) / mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) / mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b * (b - 1) + mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) + mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield ((a * b * (b - 1)) ** mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield ((a * b * (b - 1)) ** mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "x = x * y % M",
      "mutated_line": "x = x / y % M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x / y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "x = x * y % M",
      "mutated_line": "x = (x + y) % M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = (x + y) % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "x = x * y % M",
      "mutated_line": "x = x ** y % M",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x ** y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(x1, x2) = (x2 - d * x1, x1)",
      "mutated_line": "(x1, x2) = (x2 - d / x1, x1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d / x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(x1, x2) = (x2 - d * x1, x1)",
      "mutated_line": "(x1, x2) = (x2 - (d + x1), x1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - (d + x1), x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "(x1, x2) = (x2 - d * x1, x1)",
      "mutated_line": "(x1, x2) = (x2 - d ** x1, x1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d ** x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(y1, y2) = (y2 - d * y1, y1)",
      "mutated_line": "(y1, y2) = (y2 - d / y1, y1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d / y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(y1, y2) = (y2 - d * y1, y1)",
      "mutated_line": "(y1, y2) = (y2 - (d + y1), y1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - (d + y1), y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(y1, y2) = (y2 - d * y1, y1)",
      "mutated_line": "(y1, y2) = (y2 - d ** y1, y1)",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d ** y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s - 2) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 2) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s - 0) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 0) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s - 0) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 0) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = s * (s - 1) >> 1",
      "mutated_line": "r = s * (s - -1) >> 1",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - -1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b / (b - 1) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b / (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield ((a * b + (b - 1)) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield ((a * b + (b - 1)) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield ((a * b) ** (b - 1) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield ((a * b) ** (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a / b * (b - 1) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a / b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield ((a + b) * (b - 1) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield ((a + b) * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a ** b * (b - 1) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a ** b * (b - 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b * (b + 1) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b + 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b * (b * 1) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b * 1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b * (b - 2) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 2) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b * (b - 0) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 0) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b * (b - 0) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - 0) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "yield (a * b * (b - 1) * mod_inv(i))",
      "mutated_line": "yield (a * b * (b - -1) * mod_inv(i))",
      "code": "from functools import lru_cache\n\ndef count_permutations_modulo(N, M):\n\n    @lru_cache(maxsize=None)\n    def mod_inv(x):\n        (x1, y1, z1) = (1, 0, x)\n        (x2, y2, z2) = (0, 1, M)\n        while z1 != 1:\n            (d, m) = divmod(z2, z1)\n            (x1, x2) = (x2 - d * x1, x1)\n            (y1, y2) = (y2 - d * y1, y1)\n            (z1, z2) = (m, z1)\n        return x1 % M\n\n    def gen_Y(i):\n        s = 3 * (N - i)\n        r = s * (s - 1) >> 1\n        d_r = (s << 1) - 3\n        for j in range(1, N - i + 1):\n            yield (r * mod_inv(j))\n            r -= d_r\n            d_r -= 4\n\n    def gen_X():\n        a = N\n        b = 3 * N - 1\n        for i in range(1, N + 1):\n            yield (a * b * (b - -1) * mod_inv(i))\n            a -= 1\n            b -= 3\n\n    def acc_mulmod(it, init=1):\n        x = init\n        yield x\n        for y in it:\n            x = x * y % M\n            yield x\n    ans = sum((sum(acc_mulmod(gen_Y(i), A)) for (i, A) in enumerate(acc_mulmod(gen_X())))) % M\n    return ans"
    }
  ]
}