{
  "task_id": "taco_14719",
  "entry_point": "can_cakes_be_covered",
  "mutant_count": 88,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "poss = h <= w",
      "mutated_line": "poss = h < w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h < w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "poss = h <= w",
      "mutated_line": "poss = h > w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h > w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "poss = h <= w",
      "mutated_line": "poss = h == w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h == w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 1\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = -1\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 1\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "while j < n and poss:",
      "mutated_line": "while j < n or poss:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n or poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while j < n and poss:",
      "mutated_line": "while j <= n and poss:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j <= n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while j < n and poss:",
      "mutated_line": "while j >= n and poss:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j >= n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while j < n and poss:",
      "mutated_line": "while j != n and poss:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j != n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] - h or cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h or cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j -= 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j -= 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return [i + d for i in tab]",
      "mutated_line": "return [i - d for i in tab]",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i - d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return [i + d for i in tab]",
      "mutated_line": "return [i * d for i in tab]",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i * d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w < dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w < dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w > dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w > dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w == dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w == dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w > dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w > dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w < dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w < dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w == dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w == dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 2\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 0\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 0\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += -1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if cake_positions[j] + w < dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] + w <= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w <= dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if cake_positions[j] + w < dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w >= dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if cake_positions[j] + w < dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] + w != dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w != dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 1\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 0",
      "mutated_line": "k = -1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = -1\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 1\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "while k < j and poss:",
      "mutated_line": "while k < j or poss:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j or poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 2\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 0\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 0\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += -1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] + w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] + w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] * w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] * w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] + h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] + h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] * h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] * h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] - w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] - w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] * w >= dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] * w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] - h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] - h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] * h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] * h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if cake_positions[j] + w < dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] - w < dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] - w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if cake_positions[j] + w < dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] * w < dispenser_positions[j] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] * w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if cake_positions[j] + w < dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] + w < dispenser_positions[j] - h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] - h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if cake_positions[j] + w < dispenser_positions[j] + h:",
      "mutated_line": "if cake_positions[j] + w < dispenser_positions[j] * h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] * h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cal = dispenser_positions[j] + h - cake_positions[j] - w",
      "mutated_line": "cal = dispenser_positions[j] + h - cake_positions[j] + w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] + w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cal = dispenser_positions[j] + h - cake_positions[j] - w",
      "mutated_line": "cal = (dispenser_positions[j] + h - cake_positions[j]) * w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = (dispenser_positions[j] + h - cake_positions[j]) * w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cal = dispenser_positions[j] - h - (cake_positions[j] - w)",
      "mutated_line": "cal = dispenser_positions[j] - h + (cake_positions[j] - w)",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h + (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cal = dispenser_positions[j] - h - (cake_positions[j] - w)",
      "mutated_line": "cal = (dispenser_positions[j] - h) * (cake_positions[j] - w)",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = (dispenser_positions[j] - h) * (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while k < j and poss:",
      "mutated_line": "while k <= j and poss:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k <= j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while k < j and poss:",
      "mutated_line": "while k >= j and poss:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k >= j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while k < j and poss:",
      "mutated_line": "while k != j and poss:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k != j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h and cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h and cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k -= 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cal = dispenser_positions[j] + h - cake_positions[j] - w",
      "mutated_line": "cal = dispenser_positions[j] + h + cake_positions[j] - w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h + cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cal = dispenser_positions[j] + h - cake_positions[j] - w",
      "mutated_line": "cal = (dispenser_positions[j] + h) * cake_positions[j] - w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = (dispenser_positions[j] + h) * cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cal = dispenser_positions[j] - h - (cake_positions[j] - w)",
      "mutated_line": "cal = dispenser_positions[j] + h - (cake_positions[j] - w)",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] + h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cal = dispenser_positions[j] - h - (cake_positions[j] - w)",
      "mutated_line": "cal = dispenser_positions[j] * h - (cake_positions[j] - w)",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] * h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cal = dispenser_positions[j] - h - (cake_positions[j] - w)",
      "mutated_line": "cal = dispenser_positions[j] - h - (cake_positions[j] + w)",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] + w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cal = dispenser_positions[j] - h - (cake_positions[j] - w)",
      "mutated_line": "cal = dispenser_positions[j] - h - cake_positions[j] * w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - cake_positions[j] * w\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal >= dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal >= dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal <= dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal <= dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal != dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal != dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal <= dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal <= dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal >= dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal >= dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal != dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal != dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "poss = False",
      "mutated_line": "poss = True",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = True\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 2\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 0\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 0\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += -1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cal = dispenser_positions[j] + h - cake_positions[j] - w",
      "mutated_line": "cal = dispenser_positions[j] - h - cake_positions[j] - w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] - h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cal = dispenser_positions[j] + h - cake_positions[j] - w",
      "mutated_line": "cal = dispenser_positions[j] * h - cake_positions[j] - w",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] * h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w - cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w - cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if (cake_positions[k] - w) * cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if (cake_positions[k] - w) * cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] + h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] + h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] * h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] * h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w - cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w - cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or (cake_positions[k] + w) * cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or (cake_positions[k] + w) * cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] - h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] - h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] * h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] * h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] + w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] + w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] * w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] * w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] - w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] - w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] + w + cal < dispenser_positions[k] + h:",
      "mutated_line": "if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] * w + cal < dispenser_positions[k] + h:",
      "code": "def can_cakes_be_covered(n, w, h, cake_positions, dispenser_positions):\n\n    def decali(tab, d):\n        return [i + d for i in tab]\n    poss = h <= w\n    j = 0\n    while j < n and poss:\n        if cake_positions[j] - w <= dispenser_positions[j] - h and cake_positions[j] + w >= dispenser_positions[j] + h:\n            j += 1\n        else:\n            if cake_positions[j] + w < dispenser_positions[j] + h:\n                cal = dispenser_positions[j] + h - cake_positions[j] - w\n            else:\n                cal = dispenser_positions[j] - h - (cake_positions[j] - w)\n            k = 0\n            while k < j and poss:\n                if cake_positions[k] - w + cal > dispenser_positions[k] - h or cake_positions[k] * w + cal < dispenser_positions[k] + h:\n                    poss = False\n                else:\n                    k += 1\n            if poss:\n                cake_positions = decali(cake_positions, cal)\n            j += 1\n    return poss"
    }
  ]
}