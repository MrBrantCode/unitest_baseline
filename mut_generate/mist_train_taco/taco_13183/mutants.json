{
  "task_id": "taco_13183",
  "entry_point": "max_distance_from_origin",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "engines += engines  # Duplicate the list to handle circular combinations",
      "mutated_line": "engines -= engines",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines -= engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_distance = 0",
      "mutated_line": "max_distance = 1",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 1\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_distance = 0",
      "mutated_line": "max_distance = -1",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = -1\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_distance = 0",
      "mutated_line": "max_distance = 1",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 1\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "x += nx",
      "mutated_line": "x -= nx",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x -= nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "y += ny",
      "mutated_line": "y -= ny",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y -= ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (1, 0)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (1, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (-1, 0)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (-1, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (1, 0)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (1, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, 1)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 1)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, -1)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, -1)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, 1)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 1)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = engines[i + j]",
      "mutated_line": "(nx, ny) = engines[i - j]",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i - j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = engines[i + j]",
      "mutated_line": "(nx, ny) = engines[i * j]",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i * j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) * 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) * 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, x ** 2 + y ** 2 + 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, x ** 2 + y ** 2 + 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 - y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 - y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 * y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 * y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 1.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 1.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** -0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** -0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 1)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 1)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** -0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** -0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))",
      "mutated_line": "engines += engines",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[2], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))",
      "mutated_line": "engines += engines",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[0], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))",
      "mutated_line": "engines += engines",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[0], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))",
      "mutated_line": "engines += engines",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[-1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))",
      "mutated_line": "engines += engines",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[1]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))",
      "mutated_line": "engines += engines",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[-1]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))",
      "mutated_line": "engines += engines",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[1]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x * 2 + y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x * 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x + 2 + y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x + 2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y * 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y * 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + (y + 2)) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + (y + 2)) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 3 + y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 3 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 1 + y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 1 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 0 + y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 0 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 1 + y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 1 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** -2 + y ** 2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** -2 + y ** 2) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 3) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 3) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 1) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 1) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 0) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 0) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** 1) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** 1) ** 0.5)\n    return max_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)",
      "mutated_line": "max_distance = max(max_distance, (x ** 2 + y ** -2) ** 0.5)",
      "code": "import math\n\ndef max_distance_from_origin(N, engines):\n    engines.sort(key=lambda coord: math.atan2(coord[1], coord[0]))\n    engines += engines\n    max_distance = 0\n    for i in range(N):\n        (x, y) = (0, 0)\n        for j in range(N):\n            (nx, ny) = engines[i + j]\n            x += nx\n            y += ny\n            max_distance = max(max_distance, (x ** 2 + y ** -2) ** 0.5)\n    return max_distance"
    }
  ]
}