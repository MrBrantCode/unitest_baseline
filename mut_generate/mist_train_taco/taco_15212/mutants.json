{
  "task_id": "taco_15212",
  "entry_point": "crack_safe",
  "mutant_count": 167,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "ring[a] += 1",
      "mutated_line": "ring[a] -= 1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] -= 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "ring[b] += 1",
      "mutated_line": "ring[b] -= 1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] -= 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while False:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while 2 in ring:",
      "mutated_line": "while 2 not in ring:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 not in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ring[a] //= 2",
      "mutated_line": "ring[a] //= 3",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 3\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ring[a] //= 2",
      "mutated_line": "ring[a] //= 1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 1\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ring[a] //= 2",
      "mutated_line": "ring[a] //= 0",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 0\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ring[a] //= 2",
      "mutated_line": "ring[a] //= 1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 1\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ring[a] //= 2",
      "mutated_line": "ring[a] //= -2",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= -2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ring[b] //= 2",
      "mutated_line": "ring[b] //= 3",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 3\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ring[b] //= 2",
      "mutated_line": "ring[b] //= 1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 1\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ring[b] //= 2",
      "mutated_line": "ring[b] //= 0",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 0\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ring[b] //= 2",
      "mutated_line": "ring[b] //= 1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 1\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ring[b] //= 2",
      "mutated_line": "ring[b] //= -2",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= -2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ring[a] += 1",
      "mutated_line": "ring[a] += 2",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 2\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ring[a] += 1",
      "mutated_line": "ring[a] += 0",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 0\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ring[a] += 1",
      "mutated_line": "ring[a] += 0",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 0\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ring[a] += 1",
      "mutated_line": "ring[a] += -1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += -1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ring[b] += 1",
      "mutated_line": "ring[b] += 2",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 2\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ring[b] += 1",
      "mutated_line": "ring[b] += 0",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 0\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ring[b] += 1",
      "mutated_line": "ring[b] += 0",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 0\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ring[b] += 1",
      "mutated_line": "ring[b] += -1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += -1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "modified = False",
      "mutated_line": "modified = True",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = True\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while 2 in ring:",
      "mutated_line": "while 3 in ring:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 3 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while 2 in ring:",
      "mutated_line": "while 1 in ring:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 1 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while 2 in ring:",
      "mutated_line": "while 0 in ring:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 0 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while 2 in ring:",
      "mutated_line": "while 1 in ring:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 1 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while 2 in ring:",
      "mutated_line": "while -2 in ring:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while -2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return +1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos * n, (pos + 1) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos * n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos + n, (pos + 1) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos + n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + 1) * n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) * n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, pos + 1 + n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, pos + 1 + n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('/%d' * (a + 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' * (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('/%d' + (a + 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' + (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos * n, (pos + 1) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos * n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos + n, (pos + 1) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos + n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + 1) * n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) * n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, pos + 1 + n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, pos + 1 + n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('+%d' * (a + 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' * (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('+%d' + (a + 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' + (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b = (a + 1) % n",
      "mutated_line": "b = (a + 1) * n",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) * n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b = (a + 1) % n",
      "mutated_line": "b = a + 1 + n",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = a + 1 + n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] + ring[b] >= 3:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] >= 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] + ring[b] <= 3:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] <= 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] + ring[b] != 3:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] != 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos = ring.index(2)",
      "mutated_line": "pos = ring.index(3)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(3)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos = ring.index(2)",
      "mutated_line": "pos = ring.index(1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(1)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos = ring.index(2)",
      "mutated_line": "pos = ring.index(0)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(0)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos = ring.index(2)",
      "mutated_line": "pos = ring.index(1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(1)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos = ring.index(2)",
      "mutated_line": "pos = ring.index(-2)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(-2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "increment(pos - 1)",
      "mutated_line": "increment(pos + 1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos + 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "increment(pos - 1)",
      "mutated_line": "increment(pos * 1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos * 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "halve(pos - 1)",
      "mutated_line": "halve(pos + 1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos + 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "halve(pos - 1)",
      "mutated_line": "halve(pos * 1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos * 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if all(x == 1 for x in ring):",
      "mutated_line": "if all((x != 1 for x in ring)):",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x != 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return --1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos - 1) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos - 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, pos * 1 % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, pos * 1 % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('' % (a + 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('/%d' % (a - 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a - 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('/%d' % (a * 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a * 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos - 1) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos - 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, pos * 1 % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, pos * 1 % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('' % (a + 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('+%d' % (a - 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a - 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('+%d' % (a * 1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a * 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b = (a + 1) % n",
      "mutated_line": "b = (a - 1) % n",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a - 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b = (a + 1) % n",
      "mutated_line": "b = a * 1 % n",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = a * 1 % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] - ring[b] > 3:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] - ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] * ring[b] > 3:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] * ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] + ring[b] > 4:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 4:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] + ring[b] > 2:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 2:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] + ring[b] > 0:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 0:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] + ring[b] > 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 1:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ring[a] + ring[b] > 3:",
      "mutated_line": "while ring[a] + ring[b] > -3:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > -3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 or ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 or ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "modified = True",
      "mutated_line": "modified = False",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = False\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "increment(pos - 1)",
      "mutated_line": "increment(pos - 2)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 2)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "increment(pos - 1)",
      "mutated_line": "increment(pos - 0)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 0)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "increment(pos - 1)",
      "mutated_line": "increment(pos - 0)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 0)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "increment(pos - 1)",
      "mutated_line": "increment(pos - -1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - -1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "halve(pos - 1)",
      "mutated_line": "halve(pos - 2)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 2)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "halve(pos - 1)",
      "mutated_line": "halve(pos - 0)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 0)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "halve(pos - 1)",
      "mutated_line": "halve(pos - 0)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 0)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "halve(pos - 1)",
      "mutated_line": "halve(pos - -1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - -1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if all(x == 1 for x in ring):",
      "mutated_line": "if all((x == 2 for x in ring)):",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 2 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if all(x == 1 for x in ring):",
      "mutated_line": "if all((x == 0 for x in ring)):",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 0 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if all(x == 1 for x in ring):",
      "mutated_line": "if all((x == 0 for x in ring)):",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 0 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if all(x == 1 for x in ring):",
      "mutated_line": "if all((x == -1 for x in ring)):",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == -1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + 2) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 2) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + 0) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 0) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + 0) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 0) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + -1) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + -1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('/%d' % (a + 2))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 2))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('/%d' % (a + 0))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 0))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('/%d' % (a + 0))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 0))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "record.append('/%d' % (a + 1))",
      "mutated_line": "record.append('/%d' % (a + -1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + -1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + 2) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 2) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + 0) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 0) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + 0) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 0) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(a, b) = (pos % n, (pos + 1) % n)",
      "mutated_line": "(a, b) = (pos % n, (pos + -1) % n)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + -1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('+%d' % (a + 2))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 2))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('+%d' % (a + 0))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 0))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('+%d' % (a + 0))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 0))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "record.append('+%d' % (a + 1))",
      "mutated_line": "record.append('+%d' % (a + -1))",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + -1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b = (a + 1) % n",
      "mutated_line": "b = (a + 2) % n",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 2) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b = (a + 1) % n",
      "mutated_line": "b = (a + 0) % n",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 0) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b = (a + 1) % n",
      "mutated_line": "b = (a + 0) % n",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 0) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b = (a + 1) % n",
      "mutated_line": "b = (a + -1) % n",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + -1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 != 1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 != 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 2 != 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 != 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 2 != 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 != 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] * 2 == 1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] * 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] + 2 == 1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] + 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 2 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 2 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 0 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 0 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 0 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 0 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == -1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == -1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] * 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] * 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] + 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] + 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 2:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 2:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 0:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 0:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 0:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 0:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 2 == -1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == -1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] * 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] * 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] + 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] + 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 2 == 2:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 2:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 2 == 0:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 0:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 2 == 0:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 0:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 2 == -1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == -1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 2 != 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 != 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 3 == 1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 3 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 1 == 1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 1 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 0 == 1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 0 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 1 == 1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 1 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % -2 == 1 and ring[b] % 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % -2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 3 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 3 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 1 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 1 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 0 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 0 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % 1 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 1 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ring[a] % 2 == 1 and ring[b] % 2 == 1:",
      "mutated_line": "if ring[a] % 2 == 1 and ring[b] % -2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % -2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 3 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 3 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 1 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 1 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 0 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 0 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % 1 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 1 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif ring[a] % 2 == 1:",
      "mutated_line": "elif ring[a] % -2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % -2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "increment(a - 1)",
      "mutated_line": "increment(a + 1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a + 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "increment(a - 1)",
      "mutated_line": "increment(a * 1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a * 1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] * 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] * 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] + 2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] + 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 2 == 2:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 2:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 2 == 0:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 0:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 2 == 0:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == 0:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 2 == -1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 2 == -1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "increment(a - 1)",
      "mutated_line": "increment(a - 2)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 2)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "increment(a - 1)",
      "mutated_line": "increment(a - 0)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 0)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "increment(a - 1)",
      "mutated_line": "increment(a - 0)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 0)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "increment(a - 1)",
      "mutated_line": "increment(a - -1)",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - -1)\n                elif ring[b] % 2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 3 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 3 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 1 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 1 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 0 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 0 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % 1 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % 1 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif ring[b] % 2 == 1:",
      "mutated_line": "elif ring[b] % -2 == 1:",
      "code": "def crack_safe(ring):\n    n = len(ring)\n    record = []\n\n    def halve(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] //= 2\n        ring[b] //= 2\n        record.append('/%d' % (a + 1))\n\n    def increment(pos):\n        (a, b) = (pos % n, (pos + 1) % n)\n        ring[a] += 1\n        ring[b] += 1\n        record.append('+%d' % (a + 1))\n    while True:\n        modified = False\n        for a in range(n):\n            b = (a + 1) % n\n            while ring[a] + ring[b] > 3:\n                if ring[a] % 2 == 1 and ring[b] % 2 == 1:\n                    increment(a)\n                elif ring[a] % 2 == 1:\n                    increment(a - 1)\n                elif ring[b] % -2 == 1:\n                    increment(b)\n                halve(a)\n                modified = True\n        if not modified:\n            break\n    while 2 in ring:\n        pos = ring.index(2)\n        increment(pos - 1)\n        increment(pos)\n        halve(pos - 1)\n        halve(pos)\n    if all((x == 1 for x in ring)):\n        return record\n    else:\n        return -1"
    }
  ]
}