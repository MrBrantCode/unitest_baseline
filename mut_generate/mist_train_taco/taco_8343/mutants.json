{
  "task_id": "taco_8343",
  "entry_point": "count_paths",
  "mutant_count": 162,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 - 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 * 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return -dp[-1] % MOD",
      "mutated_line": "return -dp[-1] * MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return -dp[-1] % MOD",
      "mutated_line": "return -dp[-1] + MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 * 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 + 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 8\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 6\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 0\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 1\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + -7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] / (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] / (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] + (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] + (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] ** (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] ** (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] / (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] / (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] + (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] + (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] ** (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] ** (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(fact, inv) = prepare(H + W)",
      "mutated_line": "(fact, inv) = prepare(H - W)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H - W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(fact, inv) = prepare(H + W)",
      "mutated_line": "(fact, inv) = prepare(H * W)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H * W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp = [1]",
      "mutated_line": "dp = [2]",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [2]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp = [1]",
      "mutated_line": "dp = [0]",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [0]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp = [1]",
      "mutated_line": "dp = [0]",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [0]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp = [1]",
      "mutated_line": "dp = [-1]",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [-1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 1\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = -1\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 1\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res += dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res += dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -dp[-1] % MOD",
      "mutated_line": "return +dp[-1] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return +dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 11 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 9 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 0 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 1 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = -10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 10 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 8 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 0 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 1 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** -9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n - 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n - 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n * 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n * 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(2, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(0, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(0, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(-1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n - 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n * 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] * i * MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i * MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] * i + MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i + MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] * (n - 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n - 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] * (n * 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n * 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "inv[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "inv[n] = pow(fact[n], MOD + 2, MOD)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD + 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "inv[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "inv[n] = pow(fact[n], MOD * 2, MOD)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD * 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n + 1, 0, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n + 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n * 1, 0, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n * 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 1, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, -1, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 1, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, +1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, +1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 1) * MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) * MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 1) + MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) + MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "walls.append((1, 1))",
      "mutated_line": "walls.append((2, 1))",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((2, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "walls.append((1, 1))",
      "mutated_line": "walls.append((0, 1))",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((0, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "walls.append((1, 1))",
      "mutated_line": "walls.append((0, 1))",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((0, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "walls.append((1, 1))",
      "mutated_line": "walls.append((-1, 1))",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((-1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "walls.append((1, 1))",
      "mutated_line": "walls.append((1, 2))",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 2))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "walls.append((1, 1))",
      "mutated_line": "walls.append((1, 0))",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 0))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "walls.append((1, 1))",
      "mutated_line": "walls.append((1, 0))",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 0))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "walls.append((1, 1))",
      "mutated_line": "walls.append((1, -1))",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, -1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=1):",
      "mutated_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=2):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=2):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=1):",
      "mutated_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=0):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=0):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=1):",
      "mutated_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=0):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=0):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=1):",
      "mutated_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=-1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=-1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if cx < px:",
      "mutated_line": "if cx <= px:",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx <= px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if cx < px:",
      "mutated_line": "if cx >= px:",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx >= px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if cx < px:",
      "mutated_line": "if cx != px:",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx != px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] * MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] * MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] + MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] + MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [2] * (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [2] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [0] * (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [0] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [0] * (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [0] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [-1] * (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [-1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n + 2)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 2)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n + 0)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 0)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n + 0)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 0)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n + -1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + -1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 2):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 0):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 0):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + -1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] / i % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] / i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = (fact[i - 1] + i) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = (fact[i - 1] + i) % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] ** i % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] ** i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [2] * (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [2] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [0] * (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [0] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [0] * (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [0] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [-1] * (n + 1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [-1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] * (n + 2)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 2)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] * (n + 0)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 0)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] * (n + 0)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 0)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * (n + 1)",
      "mutated_line": "inv = [1] * (n + -1)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + -1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "inv[n] = pow(fact[n], MOD - 3, MOD)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 3, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "inv[n] = pow(fact[n], MOD - 1, MOD)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 1, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "inv[n] = pow(fact[n], MOD - 0, MOD)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 0, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "inv[n] = pow(fact[n], MOD - 1, MOD)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 1, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "inv[n] = pow(fact[n], MOD - -2, MOD)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - -2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 2, 0, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 2, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 0, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 0, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - -1, 0, -1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - -1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -2):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -2):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -0):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -0):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, --1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, --1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] / (i + 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] / (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = (inv[i + 1] + (i + 1)) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = (inv[i + 1] + (i + 1)) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] ** (i + 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] ** (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=1):",
      "mutated_line": "for (i, (cy, cx)) in enumerate(walls[2:], start=1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[2:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=1):",
      "mutated_line": "for (i, (cy, cx)) in enumerate(walls[0:], start=1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[0:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=1):",
      "mutated_line": "for (i, (cy, cx)) in enumerate(walls[0:], start=1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[0:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, (cy, cx)) in enumerate(walls[1:], start=1):",
      "mutated_line": "for (i, (cy, cx)) in enumerate(walls[-1:], start=1):",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[-1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(dy, dx) = (cy - py, cx - px)",
      "mutated_line": "(dy, dx) = (cy + py, cx - px)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy + py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(dy, dx) = (cy - py, cx - px)",
      "mutated_line": "(dy, dx) = (cy * py, cx - px)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy * py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(dy, dx) = (cy - py, cx - px)",
      "mutated_line": "(dy, dx) = (cy - py, cx + px)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx + px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(dy, dx) = (cy - py, cx - px)",
      "mutated_line": "(dy, dx) = (cy - py, cx * px)",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx * px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD / inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD / inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= (dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD + inv[dx]) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= (dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD + inv[dx]) % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= (dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD) ** inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= (dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD) ** inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -dp[-1] % MOD",
      "mutated_line": "return -dp[+1] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[+1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i - 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i - 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i * 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i * 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] * MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] * MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= (dp[j] * fact[dy + dx] % MOD * inv[dy] + MOD) * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= (dp[j] * fact[dy + dx] % MOD * inv[dy] + MOD) * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -dp[-1] % MOD",
      "mutated_line": "return -dp[-2] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-2] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -dp[-1] % MOD",
      "mutated_line": "return -dp[-0] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-0] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -dp[-1] % MOD",
      "mutated_line": "return -dp[-0] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-0] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -dp[-1] % MOD",
      "mutated_line": "return -dp[--1] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[--1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i + 1] * i % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i + 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i * 1] * i % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i * 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i - 1] * (i + 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i - 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i * 1] * (i + 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i * 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 2) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 2) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 0) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 0) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + 0) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 0) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 1] * (i + -1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + -1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] * fact[dy + dx] % MOD / inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD / inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= (dp[j] * fact[dy + dx] % MOD + inv[dy]) % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= (dp[j] * fact[dy + dx] % MOD + inv[dy]) % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= (dp[j] * fact[dy + dx] % MOD) ** inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= (dp[j] * fact[dy + dx] % MOD) ** inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 2] * i % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 2] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 0] * i % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 0] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 0] * i % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 0] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - -1] * i % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - -1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 2] * (i + 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 2] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 0] * (i + 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 0] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + 0] * (i + 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 0] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv[i] = inv[i + 1] * (i + 1) % MOD",
      "mutated_line": "inv[i] = inv[i + -1] * (i + 1) % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + -1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] * fact[dy + dx] * MOD * inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy + dx] * MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= (dp[j] * fact[dy + dx] + MOD) * inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= (dp[j] * fact[dy + dx] + MOD) * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] / fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] / fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= (dp[j] + fact[dy + dx]) % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= (dp[j] + fact[dy + dx]) % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] ** fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] ** fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] * fact[dy - dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy - dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res -= dp[j] * fact[dy + dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "mutated_line": "res -= dp[j] * fact[dy * dx] % MOD * inv[dy] % MOD * inv[dx] % MOD",
      "code": "def count_paths(H, W, N, walls):\n    MOD = 10 ** 9 + 7\n\n    def prepare(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        inv = [1] * (n + 1)\n        inv[n] = pow(fact[n], MOD - 2, MOD)\n        for i in range(n - 1, 0, -1):\n            inv[i] = inv[i + 1] * (i + 1) % MOD\n        return (fact, inv)\n    walls.append((1, 1))\n    walls.append((H, W))\n    walls.sort()\n    (fact, inv) = prepare(H + W)\n    dp = [1]\n    for (i, (cy, cx)) in enumerate(walls[1:], start=1):\n        res = 0\n        for (j, (py, px)) in enumerate(walls[:i]):\n            if cx < px:\n                continue\n            (dy, dx) = (cy - py, cx - px)\n            res -= dp[j] * fact[dy * dx] % MOD * inv[dy] % MOD * inv[dx] % MOD\n            res %= MOD\n        dp.append(res)\n    return -dp[-1] % MOD"
    }
  ]
}