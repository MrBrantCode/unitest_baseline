{
  "task_id": "taco_3570",
  "entry_point": "optimal_carrot_juiciness",
  "mutant_count": 110,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 != 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 != 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 2 + 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 + 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 2 * 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 * 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = n // 2",
      "mutated_line": "r = n / 2",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n / 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = n // 2",
      "mutated_line": "r = n * 2",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n * 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 2 != 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 != 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "l += 1",
      "mutated_line": "l -= 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l -= 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r <= n - 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r <= n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r >= n - 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r >= n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r != n - 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r != n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "l -= 1",
      "mutated_line": "l += 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l += 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "r += 1",
      "mutated_line": "r -= 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r -= 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "q += [A[i], B[i]]",
      "mutated_line": "q -= [A[i], B[i]]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q -= [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(A) != len(B):",
      "mutated_line": "if len(A) == len(B):",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) == len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "ansM = evens(M) if n > 1 else []",
      "mutated_line": "ansM = evens(M) if n >= 1 else []",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n >= 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "ansM = evens(M) if n > 1 else []",
      "mutated_line": "ansM = evens(M) if n <= 1 else []",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n <= 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "ansM = evens(M) if n > 1 else []",
      "mutated_line": "ansM = evens(M) if n != 1 else []",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n != 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n * 2 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n * 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n + 2 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n + 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 1:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == -1:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 1:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return interleave(ansA, ansM[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansA, ansM[1:]) - [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) - [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return interleave(ansA, ansM[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansA, ansM[1:]) * [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) * [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return interleave(ansM, ansA[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansM, ansA[1:]) - [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) - [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return interleave(ansM, ansA[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansM, ansA[1:]) * [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) * [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n / 2 - 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n / 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n * 2 - 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n * 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 2 - 2",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 2\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 2 - 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 0\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 2 - 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 0\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 2 - -1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - -1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = n // 2",
      "mutated_line": "r = n // 3",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 3\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = n // 2",
      "mutated_line": "r = n // 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 1\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = n // 2",
      "mutated_line": "r = n // 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 0\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = n // 2",
      "mutated_line": "r = n // 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 1\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = n // 2",
      "mutated_line": "r = n // -2",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // -2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) * 2 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) * 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) + 2 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) + 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 2 == 2:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 2:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 2 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 0:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 2 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 0:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 2 == -1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == -1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l += 1",
      "mutated_line": "l += 2",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 2\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 0\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 0\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l += 1",
      "mutated_line": "l += -1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += -1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r < n + 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n + 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r < n * 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n * 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l -= 1",
      "mutated_line": "l -= 2",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 2\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l -= 1",
      "mutated_line": "l -= 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 0\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l -= 1",
      "mutated_line": "l -= 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 0\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l -= 1",
      "mutated_line": "l -= -1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= -1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r += 1",
      "mutated_line": "r += 2",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 2\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 0\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 0\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r += 1",
      "mutated_line": "r += -1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += -1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ansM = evens(M) if n > 1 else []",
      "mutated_line": "ansM = evens(M) if n > 2 else []",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 2 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ansM = evens(M) if n > 1 else []",
      "mutated_line": "ansM = evens(M) if n > 0 else []",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 0 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ansM = evens(M) if n > 1 else []",
      "mutated_line": "ansM = evens(M) if n > 0 else []",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 0 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ansM = evens(M) if n > 1 else []",
      "mutated_line": "ansM = evens(M) if n > -1 else []",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > -1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 3 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 3 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 1 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 0 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 0 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 1 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % -2 == 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % -2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 3 - 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 3 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 1 - 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 1 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 0 - 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 0 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // 1 - 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 1 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "l = n // 2 - 1",
      "mutated_line": "l = n // -2 - 1",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // -2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 3 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 3 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 1 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 1 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 0 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 0 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % 1 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 1 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(A) % 2 == 1:",
      "mutated_line": "if len(A) % -2 == 1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % -2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r < n - 2:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 2:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r < n - 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 0:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r < n - 0:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 0:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while r < n - 1:",
      "mutated_line": "while r < n - -1:",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - -1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i - 1]) for i in range(n - 1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i - 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i * 1]) for i in range(n - 1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i * 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n + 1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n + 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n * 1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n * 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "q.append(A[-1])",
      "mutated_line": "q.append(A[+1])",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[+1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 2]) for i in range(n - 1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 2]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 0]) for i in range(n - 1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 0]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 0]) for i in range(n - 1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 0]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + -1]) for i in range(n - 1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + -1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 2)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 2)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 0)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 0)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 0)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 0)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]",
      "mutated_line": "M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - -1)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - -1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "ans.append(max(ans[-1], A[l], A[r]))",
      "mutated_line": "ans.append(max(ans[+1], A[l], A[r]))",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[+1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append(A[-1])",
      "mutated_line": "q.append(A[-2])",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-2])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append(A[-1])",
      "mutated_line": "q.append(A[-0])",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-0])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append(A[-1])",
      "mutated_line": "q.append(A[-0])",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-0])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append(A[-1])",
      "mutated_line": "q.append(A[--1])",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[--1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return interleave(ansA, ansM[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansA, ansM[2:]) + [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[2:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return interleave(ansA, ansM[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansA, ansM[0:]) + [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[0:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return interleave(ansA, ansM[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansA, ansM[0:]) + [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[0:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return interleave(ansA, ansM[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansA, ansM[-1:]) + [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[-1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return interleave(ansM, ansA[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansM, ansA[2:]) + [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[2:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return interleave(ansM, ansA[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansM, ansA[0:]) + [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[0:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return interleave(ansM, ansA[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansM, ansA[0:]) + [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[0:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return interleave(ansM, ansA[1:]) + [max(juiciness)]",
      "mutated_line": "return interleave(ansM, ansA[-1:]) + [max(juiciness)]",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[-1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans.append(max(ans[-1], A[l], A[r]))",
      "mutated_line": "ans.append(max(ans[-2], A[l], A[r]))",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-2], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans.append(max(ans[-1], A[l], A[r]))",
      "mutated_line": "ans.append(max(ans[-0], A[l], A[r]))",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-0], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans.append(max(ans[-1], A[l], A[r]))",
      "mutated_line": "ans.append(max(ans[-0], A[l], A[r]))",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[-0], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans.append(max(ans[-1], A[l], A[r]))",
      "mutated_line": "ans.append(max(ans[--1], A[l], A[r]))",
      "code": "def optimal_carrot_juiciness(n, juiciness):\n\n    def evens(A):\n        n = len(A)\n        l = n // 2 - 1\n        r = n // 2\n        if len(A) % 2 == 1:\n            l += 1\n        ans = [max(A[l], A[r])]\n        while r < n - 1:\n            l -= 1\n            r += 1\n            ans.append(max(ans[--1], A[l], A[r]))\n        return ans\n\n    def interleave(A, B):\n        q = []\n        for i in range(len(B)):\n            q += [A[i], B[i]]\n        if len(A) != len(B):\n            q.append(A[-1])\n        return q\n    M = [min(juiciness[i], juiciness[i + 1]) for i in range(n - 1)]\n    ansA = evens(juiciness)\n    ansM = evens(M) if n > 1 else []\n    if n % 2 == 0:\n        return interleave(ansA, ansM[1:]) + [max(juiciness)]\n    else:\n        return interleave(ansM, ansA[1:]) + [max(juiciness)]"
    }
  ]
}