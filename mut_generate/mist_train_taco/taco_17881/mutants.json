{
  "task_id": "taco_17881",
  "entry_point": "find_scenery_beauty",
  "mutant_count": 91,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dep = [0] * n",
      "mutated_line": "dep = [0] / n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] / n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dep = [0] * n",
      "mutated_line": "dep = [0] + n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] + n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dep = [0] * n",
      "mutated_line": "dep = [0] ** n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] ** n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "par = [0] * n",
      "mutated_line": "par = [0] / n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] / n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "par = [0] * n",
      "mutated_line": "par = [0] + n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] + n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "par = [0] * n",
      "mutated_line": "par = [0] ** n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] ** n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "num = [1] * n",
      "mutated_line": "num = [1] / n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] / n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "num = [1] * n",
      "mutated_line": "num = [1] + n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] + n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "num = [1] * n",
      "mutated_line": "num = [1] ** n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] ** n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bfs(0)",
      "mutated_line": "bfs(1)",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(1)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bfs(0)",
      "mutated_line": "bfs(-1)",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(-1)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bfs(0)",
      "mutated_line": "bfs(1)",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(1)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 1\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = -1\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 1\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dep[a] < dep[b]:",
      "mutated_line": "if dep[a] <= dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] <= dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dep[a] < dep[b]:",
      "mutated_line": "if dep[a] >= dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] >= dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dep[a] < dep[b]:",
      "mutated_line": "if dep[a] != dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] != dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while dep[a] > dep[b]:",
      "mutated_line": "while dep[a] >= dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] >= dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while dep[a] > dep[b]:",
      "mutated_line": "while dep[a] <= dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] <= dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while dep[a] > dep[b]:",
      "mutated_line": "while dep[a] != dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] != dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while a != b:",
      "mutated_line": "while a == b:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a == b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "return cnt > 0",
      "mutated_line": "return cnt >= 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt >= 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "return cnt > 0",
      "mutated_line": "return cnt <= 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt <= 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "return cnt > 0",
      "mutated_line": "return cnt != 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt != 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if dep[a] < dep[b]:",
      "mutated_line": "if dep[a] <= dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] <= dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if dep[a] < dep[b]:",
      "mutated_line": "if dep[a] >= dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] >= dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if dep[a] < dep[b]:",
      "mutated_line": "if dep[a] != dep[b]:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] != dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dep = [0] * n",
      "mutated_line": "dep = [1] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [1] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dep = [0] * n",
      "mutated_line": "dep = [-1] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [-1] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dep = [0] * n",
      "mutated_line": "dep = [1] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [1] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "par = [0] * n",
      "mutated_line": "par = [1] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [1] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "par = [0] * n",
      "mutated_line": "par = [-1] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [-1] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "par = [0] * n",
      "mutated_line": "par = [1] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [1] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "num = [1] * n",
      "mutated_line": "num = [2] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [2] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "num = [1] * n",
      "mutated_line": "num = [0] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [0] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "num = [1] * n",
      "mutated_line": "num = [0] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [0] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "num = [1] * n",
      "mutated_line": "num = [-1] * n",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [-1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if num[a] <= g:",
      "mutated_line": "if num[a] < g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] < g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if num[a] <= g:",
      "mutated_line": "if num[a] > g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] > g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if num[a] <= g:",
      "mutated_line": "if num[a] == g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] == g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt -= 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if num[a] <= g:",
      "mutated_line": "if num[a] < g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] < g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if num[a] <= g:",
      "mutated_line": "if num[a] > g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] > g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if num[a] <= g:",
      "mutated_line": "if num[a] == g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] == g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt -= 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if num[b] <= g:",
      "mutated_line": "if num[b] < g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] < g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if num[b] <= g:",
      "mutated_line": "if num[b] > g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] > g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if num[b] <= g:",
      "mutated_line": "if num[b] == g:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] == g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt -= 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return cnt > 0",
      "mutated_line": "return cnt > 1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 1\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return cnt > 0",
      "mutated_line": "return cnt > -1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > -1\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return cnt > 0",
      "mutated_line": "return cnt > 1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 1\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "queries.sort(reverse=True, key=lambda x: x[2])",
      "mutated_line": "for (a, b, g) in queries:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=False, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return +1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "que.append((-1, root, 0))",
      "mutated_line": "que.append((+1, root, 0))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((+1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que.append((-1, root, 0))",
      "mutated_line": "que.append((-1, root, 1))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 1))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que.append((-1, root, 0))",
      "mutated_line": "que.append((-1, root, -1))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, -1))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que.append((-1, root, 0))",
      "mutated_line": "que.append((-1, root, 1))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 1))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if to != p:",
      "mutated_line": "if to == p:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to == p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 2\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 0\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 0\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += -1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 2\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 0\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 0\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += -1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 2\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 0\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 0\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += -1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -2\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -0\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -0\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return --1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que.append((-1, root, 0))",
      "mutated_line": "que.append((-2, root, 0))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-2, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que.append((-1, root, 0))",
      "mutated_line": "que.append((-0, root, 0))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-0, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que.append((-1, root, 0))",
      "mutated_line": "que.append((-0, root, 0))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-0, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que.append((-1, root, 0))",
      "mutated_line": "que.append((--1, root, 0))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((--1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "queries.sort(reverse=True, key=lambda x: x[2])",
      "mutated_line": "for (a, b, g) in queries:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[3])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "queries.sort(reverse=True, key=lambda x: x[2])",
      "mutated_line": "for (a, b, g) in queries:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[1])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "queries.sort(reverse=True, key=lambda x: x[2])",
      "mutated_line": "for (a, b, g) in queries:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[0])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "queries.sort(reverse=True, key=lambda x: x[2])",
      "mutated_line": "for (a, b, g) in queries:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[1])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "queries.sort(reverse=True, key=lambda x: x[2])",
      "mutated_line": "for (a, b, g) in queries:",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[-2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "que.append((v, to, d + 1))",
      "mutated_line": "que.append((v, to, d - 1))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d - 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "que.append((v, to, d + 1))",
      "mutated_line": "que.append((v, to, d * 1))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d * 1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "que.append((v, to, d + 1))",
      "mutated_line": "que.append((v, to, d + 2))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 2))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "que.append((v, to, d + 1))",
      "mutated_line": "que.append((v, to, d + 0))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 0))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "que.append((v, to, d + 1))",
      "mutated_line": "que.append((v, to, d + 0))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + 0))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "que.append((v, to, d + 1))",
      "mutated_line": "que.append((v, to, d + -1))",
      "code": "from collections import deque\n\ndef find_scenery_beauty(n, edges, queries):\n    G = [[] for _ in range(n)]\n    for (a, b) in edges:\n        G[a].append(b)\n        G[b].append(a)\n    dep = [0] * n\n    par = [0] * n\n\n    def bfs(root):\n        que = deque()\n        que.append((-1, root, 0))\n        while que:\n            (p, v, d) = que.pop()\n            dep[v] = d\n            par[v] = p\n            for to in G[v]:\n                if to != p:\n                    que.append((v, to, d + -1))\n    bfs(0)\n    num = [1] * n\n\n    def lca(a, b, g):\n        cnt = 0\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        while dep[a] > dep[b]:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            a = par[a]\n        while a != b:\n            if num[a] <= g:\n                num[a] = g\n                cnt += 1\n            if num[b] <= g:\n                num[b] = g\n                cnt += 1\n            a = par[a]\n            b = par[b]\n        return cnt > 0\n    queries.sort(reverse=True, key=lambda x: x[2])\n    for (a, b, g) in queries:\n        if not lca(a, b, g):\n            return -1\n    ans = []\n    for (a, b) in edges:\n        if dep[a] < dep[b]:\n            (a, b) = (b, a)\n        ans.append(num[a])\n    return ans"
    }
  ]
}