{
  "task_id": "taco_8441",
  "entry_point": "calculate_minimal_travel_length",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 2 + result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 + result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 2 * result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 * result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 1\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "total = 0",
      "mutated_line": "total = -1",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = -1\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 1\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "single = 0",
      "mutated_line": "single = 1",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 1\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "single = 0",
      "mutated_line": "single = -1",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = -1\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "single = 0",
      "mutated_line": "single = 1",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 1\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = dfs(0, -1, adjacency_list)",
      "mutated_line": "result = dfs(1, -1, adjacency_list)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(1, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = dfs(0, -1, adjacency_list)",
      "mutated_line": "result = dfs(-1, -1, adjacency_list)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(-1, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = dfs(0, -1, adjacency_list)",
      "mutated_line": "result = dfs(1, -1, adjacency_list)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(1, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "result = dfs(0, -1, adjacency_list)",
      "mutated_line": "result = dfs(0, +1, adjacency_list)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, +1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] / 2 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] / 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] + 2 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] + 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] ** 2 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] ** 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if nxt != prev:",
      "mutated_line": "if nxt == prev:",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt == prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "total += temp[0] + weight",
      "mutated_line": "total -= temp[0] + weight",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total -= temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = dfs(0, -1, adjacency_list)",
      "mutated_line": "result = dfs(0, -2, adjacency_list)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -2, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = dfs(0, -1, adjacency_list)",
      "mutated_line": "result = dfs(0, -0, adjacency_list)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -0, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = dfs(0, -1, adjacency_list)",
      "mutated_line": "result = dfs(0, -0, adjacency_list)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -0, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = dfs(0, -1, adjacency_list)",
      "mutated_line": "result = dfs(0, --1, adjacency_list)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, --1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 3 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 3 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 1 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 1 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 0 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 0 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 1 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 1 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * -2 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * -2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 2 - result[2]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[2]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 2 - result[0]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[0]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 2 - result[0]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[0]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[0] * 2 - result[-1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[-1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 1].append((y + 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y + 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 1].append((y * 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y * 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 1].append((x + 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x + 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 1].append((x * 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x * 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "total += temp[0] + weight",
      "mutated_line": "total += temp[0] - weight",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] - weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "total += temp[0] + weight",
      "mutated_line": "total += temp[0] * weight",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] * weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[1] * 2 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[1] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[-1] * 2 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[-1] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimal_travel_length = result[0] * 2 - result[1]",
      "mutated_line": "minimal_travel_length = result[1] * 2 - result[1]",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[1] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x + 1].append((y - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x + 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x * 1].append((y - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x * 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 1].append((y - 2, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 2, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 1].append((y - 0, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 0, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 1].append((y - 0, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 0, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 1].append((y - -1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - -1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y + 1].append((x - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y + 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y * 1].append((x - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y * 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 1].append((x - 2, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 2, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 1].append((x - 0, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 0, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 1].append((x - 0, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 0, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 1].append((x - -1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - -1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "single = max(single, temp[1] + weight)",
      "mutated_line": "single = max(single, temp[1] - weight)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] - weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "single = max(single, temp[1] + weight)",
      "mutated_line": "single = max(single, temp[1] * weight)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] * weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 2].append((y - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 2].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 0].append((y - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 0].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - 0].append((y - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 0].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adjacency_list[x - 1].append((y - 1, w))",
      "mutated_line": "adjacency_list[x - -1].append((y - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - -1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 2].append((x - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 2].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 0].append((x - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 0].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - 0].append((x - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 0].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "adjacency_list[y - 1].append((x - 1, w))",
      "mutated_line": "adjacency_list[y - -1].append((x - 1, w))",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - -1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "total += temp[0] + weight",
      "mutated_line": "total += temp[1] + weight",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[1] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "total += temp[0] + weight",
      "mutated_line": "total += temp[-1] + weight",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[-1] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "total += temp[0] + weight",
      "mutated_line": "total += temp[1] + weight",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[1] + weight\n                single = max(single, temp[1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "single = max(single, temp[1] + weight)",
      "mutated_line": "single = max(single, temp[2] + weight)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[2] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "single = max(single, temp[1] + weight)",
      "mutated_line": "single = max(single, temp[0] + weight)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[0] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "single = max(single, temp[1] + weight)",
      "mutated_line": "single = max(single, temp[0] + weight)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[0] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "single = max(single, temp[1] + weight)",
      "mutated_line": "single = max(single, temp[-1] + weight)",
      "code": "def calculate_minimal_travel_length(n, edges):\n    \"\"\"\n    Calculate the minimal length of Shapur's travel to visit all cities starting from city 1.\n\n    Parameters:\n    - n (int): The number of cities.\n    - edges (list of tuples): Each tuple contains three integers (xi, yi, wi) representing \n      the two cities connected by a road and the length of that road.\n\n    Returns:\n    - minimal_travel_length (int): The minimal length of Shapur's travel.\n    \"\"\"\n    adjacency_list = [list() for _ in range(n)]\n    for (x, y, w) in edges:\n        adjacency_list[x - 1].append((y - 1, w))\n        adjacency_list[y - 1].append((x - 1, w))\n\n    def dfs(cur, prev, edges):\n        total = 0\n        single = 0\n        for (nxt, weight) in edges[cur]:\n            if nxt != prev:\n                temp = dfs(nxt, cur, edges)\n                total += temp[0] + weight\n                single = max(single, temp[-1] + weight)\n        return (total, single)\n    result = dfs(0, -1, adjacency_list)\n    minimal_travel_length = result[0] * 2 - result[1]\n    return minimal_travel_length"
    }
  ]
}