{
  "task_id": "taco_7771",
  "entry_point": "can_kate_escape",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(kate_positions) != 1:",
      "mutated_line": "if len(kate_positions) == 1:",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) == 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(kate_positions) != 1:",
      "mutated_line": "if len(kate_positions) != 2:",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 2:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(kate_positions) != 1:",
      "mutated_line": "if len(kate_positions) != 0:",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 0:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(kate_positions) != 1:",
      "mutated_line": "if len(kate_positions) != 0:",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 0:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(kate_positions) != 1:",
      "mutated_line": "if len(kate_positions) != -1:",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != -1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "kate_pos = kate_positions[0]",
      "mutated_line": "kate_pos = kate_positions[1]",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[1]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "kate_pos = kate_positions[0]",
      "mutated_line": "kate_pos = kate_positions[-1]",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[-1]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "kate_pos = kate_positions[0]",
      "mutated_line": "kate_pos = kate_positions[1]",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[1]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(1, 1), (0, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(1, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(-1, 1), (0, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(-1, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(1, 1), (0, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(1, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 2), (0, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 2), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 0), (0, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 0), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 0), (0, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 0), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, -1), (0, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, -1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (1, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (1, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (-1, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (-1, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (1, -1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (1, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, +1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, +1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (2, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (2, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (0, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (0, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (0, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (0, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (-1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (-1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 1), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 1), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, -1), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, -1), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 1), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 1), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 0), (+1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (+1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 1)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 1)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, -1)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, -1)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 1)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 1)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']",
      "mutated_line": "kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] != 'k']",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] != 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "raise ValueError(\"There should be exactly one 'k' in the maze.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError('')\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return False\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -2), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -2), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -0), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -0), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -0), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -0), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, --1), (1, 0), (-1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, --1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-2, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-2, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-0, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-0, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-0, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-0, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}",
      "mutated_line": "MOVES = {(0, 1), (0, -1), (1, 0), (--1, 0)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (--1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']",
      "mutated_line": "kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == '']",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == '']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES",
      "mutated_line": "neighbors = {(x - dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x - dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES",
      "mutated_line": "neighbors = {(x * dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x * dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES",
      "mutated_line": "neighbors = {(x + dx, y - dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y - dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES",
      "mutated_line": "neighbors = {(x + dx, y * dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y * dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) or 0 <= y + dy < len(maze[x + dx]) or maze[x + dx][y + dy] == ' ' or ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) or 0 <= y + dy < len(maze[x + dx]) or maze[x + dx][y + dy] == ' ' or ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) or 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) or 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 < x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 < x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 > x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 > x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 == x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 == x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 < y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 < y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 > y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 > y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 == y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 == y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "and maze[x + dx][y + dy] == ' '",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] != ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] != ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "and (x + dx, y + dy) not in seen}",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 < x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 < x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 > x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 > x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 == x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 == x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 0 < y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 < y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 0 > y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 > y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 0 == y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 == y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if -1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if -1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x - dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x - dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x * dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x * dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 1 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 1 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and -1 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and -1 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 1 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 1 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y - dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y - dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y * dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y * dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "and maze[x + dx][y + dy] == ' '",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == '') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == '') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (-1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (-1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (1 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x - dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x - dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x * dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x * dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 1 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 1 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and -1 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and -1 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 1 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 1 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y - dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y - dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y * dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y * dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "and maze[x + dx][y + dy] == ' '",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y - dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y - dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "and maze[x + dx][y + dy] == ' '",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y * dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y * dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "and (x + dx, y + dy) not in seen}",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x - dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x - dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "and (x + dx, y + dy) not in seen}",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x * dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x * dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "and (x + dx, y + dy) not in seen}",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y - dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y - dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "and (x + dx, y + dy) not in seen}",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y * dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y * dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x - dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x - dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x * dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x * dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "and maze[x + dx][y + dy] == ' '",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x - dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x - dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "and maze[x + dx][y + dy] == ' '",
      "mutated_line": "neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x * dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x * dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x - dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x - dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx])) for (dx, dy) in MOVES)):",
      "mutated_line": "if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x * dx])) for (dx, dy) in MOVES)):",
      "code": "def can_kate_escape(maze):\n    MOVES = {(0, 1), (0, -1), (1, 0), (-1, 0)}\n    kate_positions = [(x, y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k']\n    if len(kate_positions) != 1:\n        raise ValueError(\"There should be exactly one 'k' in the maze.\")\n    kate_pos = kate_positions[0]\n    seen = set([kate_pos])\n    pos_set = set([kate_pos])\n    while pos_set:\n        (x, y) = pos_set.pop()\n        if any((not (0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x * dx])) for (dx, dy) in MOVES)):\n            return True\n        neighbors = {(x + dx, y + dy) for (dx, dy) in MOVES if 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[x + dx]) and (maze[x + dx][y + dy] == ' ') and ((x + dx, y + dy) not in seen)}\n        pos_set |= neighbors\n        seen |= neighbors\n    return False"
    }
  ]
}