{
  "task_id": "taco_10475",
  "entry_point": "find_optimal_relabeling",
  "mutant_count": 91,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] / (n + 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] / (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] + (n + 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] + (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] ** (n + 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] ** (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "m -= b",
      "mutated_line": "m += b",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m += b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k = 1",
      "mutated_line": "k = 2",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 2\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 0\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 0\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k = 1",
      "mutated_line": "k = -1",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = -1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k -= 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] * (n - 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n - 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] * (n * 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n * 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(2, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(0, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(0, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(-1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n - 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n * 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if vis[i] < 0:",
      "mutated_line": "if vis[i] <= 0:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] <= 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if vis[i] < 0:",
      "mutated_line": "if vis[i] >= 0:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] >= 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if vis[i] < 0:",
      "mutated_line": "if vis[i] != 0:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] != 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "b = m & -m",
      "mutated_line": "b = m | -m",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m | -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in subs[0]:",
      "mutated_line": "for i in subs[1]:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[1]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in subs[0]:",
      "mutated_line": "for i in subs[-1]:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[-1]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in subs[0]:",
      "mutated_line": "for i in subs[1]:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[1]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in subs[1]:",
      "mutated_line": "for i in subs[2]:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[2]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in subs[1]:",
      "mutated_line": "for i in subs[0]:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[0]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in subs[1]:",
      "mutated_line": "for i in subs[0]:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[0]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in subs[1]:",
      "mutated_line": "for i in subs[-1]:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[-1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while k in st:",
      "mutated_line": "while k not in st:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k not in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k -= 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 2\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 0\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 0\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += -1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [+1] * (n + 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [+1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] * (n + 2)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 2)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] * (n + 0)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 0)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] * (n + 0)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 0)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-1] * (n + -1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + -1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 2):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 0):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 0):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + -1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if vis[i] < 0:",
      "mutated_line": "if vis[i] < 1:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 1:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if vis[i] < 0:",
      "mutated_line": "if vis[i] < -1:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < -1:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if vis[i] < 0:",
      "mutated_line": "if vis[i] < 1:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 1:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis[i] = 0",
      "mutated_line": "vis[i] = 1",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 1\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis[i] = 0",
      "mutated_line": "vis[i] = -1",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = -1\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis[i] = 0",
      "mutated_line": "vis[i] = 1",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 1\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "m = len(subs[0])",
      "mutated_line": "m = len(subs[1])",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[1])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "m = len(subs[0])",
      "mutated_line": "m = len(subs[-1])",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[-1])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "m = len(subs[0])",
      "mutated_line": "m = len(subs[1])",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[1])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "b = m & -m",
      "mutated_line": "b = m & +m",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & +m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 2\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 0\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 0\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += -1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ' '.join(map(str, vis[1:]))",
      "mutated_line": "return ''.join(map(str, vis[1:]))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ''.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-2] * (n + 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-2] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-0] * (n + 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-0] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [-0] * (n + 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-0] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "vis = [-1] * (n + 1)",
      "mutated_line": "vis = [--1] * (n + 1)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [--1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "g = [set() for _ in range(n + 1)]",
      "mutated_line": "g = [set() for _ in range(n - 1)]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n - 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "g = [set() for _ in range(n + 1)]",
      "mutated_line": "g = [set() for _ in range(n * 1)]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n * 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "g = [set() for _ in range(n + 1)]",
      "mutated_line": "g = [set() for _ in range(n + 2)]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 2)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "g = [set() for _ in range(n + 1)]",
      "mutated_line": "g = [set() for _ in range(n + 0)]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 0)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "g = [set() for _ in range(n + 1)]",
      "mutated_line": "g = [set() for _ in range(n + 0)]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 0)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "g = [set() for _ in range(n + 1)]",
      "mutated_line": "g = [set() for _ in range(n + -1)]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + -1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if vis[v] < 0:",
      "mutated_line": "if vis[v] <= 0:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] <= 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if vis[v] < 0:",
      "mutated_line": "if vis[v] >= 0:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] >= 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if vis[v] < 0:",
      "mutated_line": "if vis[v] != 0:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] != 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ' '.join(map(str, vis[1:]))",
      "mutated_line": "return ' '.join(map(str, vis[2:]))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[2:]))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ' '.join(map(str, vis[1:]))",
      "mutated_line": "return ' '.join(map(str, vis[0:]))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[0:]))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ' '.join(map(str, vis[1:]))",
      "mutated_line": "return ' '.join(map(str, vis[0:]))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[0:]))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ' '.join(map(str, vis[1:]))",
      "mutated_line": "return ' '.join(map(str, vis[-1:]))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[-1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "subs[0].append(i)",
      "mutated_line": "subs[1].append(i)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[1].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "subs[0].append(i)",
      "mutated_line": "subs[-1].append(i)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[-1].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "subs[0].append(i)",
      "mutated_line": "subs[1].append(i)",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[1].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis[v] < 0:",
      "mutated_line": "if vis[v] < 1:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 1:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis[v] < 0:",
      "mutated_line": "if vis[v] < -1:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < -1:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis[v] < 0:",
      "mutated_line": "if vis[v] < 1:",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 1:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vis[v] = 1 - vis[u]",
      "mutated_line": "vis[v] = 1 + vis[u]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 + vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vis[v] = 1 - vis[u]",
      "mutated_line": "vis[v] = 1 * vis[u]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 * vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val.extend(list(range(b, b << 1)))",
      "mutated_line": "val.extend(list(range(b, b << 2)))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 2)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val.extend(list(range(b, b << 1)))",
      "mutated_line": "val.extend(list(range(b, b << 0)))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 0)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val.extend(list(range(b, b << 1)))",
      "mutated_line": "val.extend(list(range(b, b << 0)))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 0)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val.extend(list(range(b, b << 1)))",
      "mutated_line": "val.extend(list(range(b, b << -1)))",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << -1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis[v] = 1 - vis[u]",
      "mutated_line": "vis[v] = 2 - vis[u]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 2 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis[v] = 1 - vis[u]",
      "mutated_line": "vis[v] = 0 - vis[u]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 0 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis[v] = 1 - vis[u]",
      "mutated_line": "vis[v] = 0 - vis[u]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 0 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis[v] = 1 - vis[u]",
      "mutated_line": "vis[v] = -1 - vis[u]",
      "code": "def find_optimal_relabeling(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = -1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))"
    }
  ]
}