{
  "task_id": "taco_1225",
  "entry_point": "modiFun",
  "mutant_count": 230,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "modul = 998244353",
      "mutated_line": "modul = 998244354",
      "code": "from math import gcd, sqrt\nmodul = 998244354\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "modul = 998244353",
      "mutated_line": "modul = 998244352",
      "code": "from math import gcd, sqrt\nmodul = 998244352\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "modul = 998244353",
      "mutated_line": "modul = 0",
      "code": "from math import gcd, sqrt\nmodul = 0\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "modul = 998244353",
      "mutated_line": "modul = 1",
      "code": "from math import gcd, sqrt\nmodul = 1\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "modul = 998244353",
      "mutated_line": "modul = -998244353",
      "code": "from math import gcd, sqrt\nmodul = -998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if b == 1:",
      "mutated_line": "if b != 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b != 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while g != 1:",
      "mutated_line": "while g == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g == 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count -= 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return +1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if 1 % m == x:",
      "mutated_line": "if 1 % m != x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m != x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == 0 or m == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 or m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == 0 or n != 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 or n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) - 1 + m) * m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) * m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = pow(2, n, m) - 1 + m + m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = pow(2, n, m) - 1 + m + m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if power == -1:",
      "mutated_line": "if power != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power != -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul * modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul * modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul + modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul + modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if answ == 0:",
      "mutated_line": "if answ != 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ != 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if answ == 1:",
      "mutated_line": "if answ != 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ != 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 2:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 2:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 0:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 0:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if b == 1:",
      "mutated_line": "if b == -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == -1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 1\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return -1\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 1\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(count, t, g) = (0, 1, gcd(a, p))",
      "mutated_line": "(count, t, g) = (1, 1, gcd(a, p))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (1, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(count, t, g) = (0, 1, gcd(a, p))",
      "mutated_line": "(count, t, g) = (-1, 1, gcd(a, p))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (-1, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(count, t, g) = (0, 1, gcd(a, p))",
      "mutated_line": "(count, t, g) = (1, 1, gcd(a, p))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (1, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(count, t, g) = (0, 1, gcd(a, p))",
      "mutated_line": "(count, t, g) = (0, 2, gcd(a, p))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 2, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(count, t, g) = (0, 1, gcd(a, p))",
      "mutated_line": "(count, t, g) = (0, 0, gcd(a, p))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 0, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(count, t, g) = (0, 1, gcd(a, p))",
      "mutated_line": "(count, t, g) = (0, 0, gcd(a, p))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 0, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(count, t, g) = (0, 1, gcd(a, p))",
      "mutated_line": "(count, t, g) = (0, -1, gcd(a, p))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, -1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while g != 1:",
      "mutated_line": "while g != 2:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 2:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while g != 1:",
      "mutated_line": "while g != 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 0:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while g != 1:",
      "mutated_line": "while g != 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 0:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while g != 1:",
      "mutated_line": "while g != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != -1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if b % g:",
      "mutated_line": "if b * g:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b * g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if b % g:",
      "mutated_line": "if b + g:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b + g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p = p // g",
      "mutated_line": "p = p / g",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p / g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p = p // g",
      "mutated_line": "p = p * g",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p * g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "b = b // g",
      "mutated_line": "b = b / g",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b / g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "b = b // g",
      "mutated_line": "b = b * g",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b * g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 2\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 0\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 0\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += -1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if b == t:",
      "mutated_line": "if b != t:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b != t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = base * a % p",
      "mutated_line": "base = base * a * p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a * p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = base * a % p",
      "mutated_line": "base = base * a + p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a + p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(2, m + 2):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(2, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(0, m + 2):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(0, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(0, m + 2):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(0, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(-1, m + 2):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(-1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(1, m - 2):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m - 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(1, m * 2):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m * 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp = temp * base % p",
      "mutated_line": "temp = temp * base * p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base * p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp = temp * base % p",
      "mutated_line": "temp = temp * base + p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base + p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if temp in hash.keys():",
      "mutated_line": "if temp not in hash.keys():",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp not in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -2\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -0\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -0\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return --1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if 1 % m == x:",
      "mutated_line": "if 1 * m == x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 * m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if 1 % m == x:",
      "mutated_line": "if 1 + m == x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 + m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 1\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return -1\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 1\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x != 0 and m == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x != 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == 0 and m != 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m != 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 1\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return -1\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 1\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x != 0 and n != 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x != 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == 0 and n == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n == 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 2\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 0\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 0\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return -1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) - 1 - m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 - m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) - 1) * m % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1) * m % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "if power == -1:",
      "mutated_line": "if power == +1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == +1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return +1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) * modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) * modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = (pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) + modul) % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = (pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) + modul) % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if answ == 0:",
      "mutated_line": "if answ == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 1:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if answ == 0:",
      "mutated_line": "if answ == -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == -1:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if answ == 0:",
      "mutated_line": "if answ == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 1:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if 1 % m != x:",
      "mutated_line": "if 1 % m == x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m == x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if answ == 1:",
      "mutated_line": "if answ == 2:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 2:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if answ == 1:",
      "mutated_line": "if answ == 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 0:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if answ == 1:",
      "mutated_line": "if answ == 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 0:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if answ == 1:",
      "mutated_line": "if answ == -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == -1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "LCR",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 % m != x and n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x and n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "answ -= 1",
      "mutated_line": "answ += 1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ += 1\n    return answ"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return +1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t = int(int(int(t * a) // g) % p)",
      "mutated_line": "t = int(int(int(t * a) // g) * p)",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) * p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t = int(int(int(t * a) // g) % p)",
      "mutated_line": "t = int(int(int(t * a) // g) + p)",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) + p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) - 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) - 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) * 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) * 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = base * a % p",
      "mutated_line": "base = base / a % p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base / a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = base * a % p",
      "mutated_line": "base = (base + a) % p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = (base + a) % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base = base * a % p",
      "mutated_line": "base = base ** a % p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base ** a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(1, m + 3):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 3):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(1, m + 1):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 1):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 0):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(1, m + 1):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 1):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, m + 2):",
      "mutated_line": "for i in range(1, m + -2):",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + -2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp = temp * base % p",
      "mutated_line": "temp = temp / base % p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp / base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp = temp * base % p",
      "mutated_line": "temp = (temp + base) % p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = (temp + base) % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp = temp * base % p",
      "mutated_line": "temp = temp ** base % p",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp ** base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return i * m - hash[temp] + count",
      "mutated_line": "return i * m - hash[temp] - count",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] - count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return i * m - hash[temp] + count",
      "mutated_line": "return (i * m - hash[temp]) * count",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return (i * m - hash[temp]) * count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if 1 % m == x:",
      "mutated_line": "if 2 % m == x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 2 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if 1 % m == x:",
      "mutated_line": "if 0 % m == x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 0 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if 1 % m == x:",
      "mutated_line": "if 0 % m == x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 0 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if 1 % m == x:",
      "mutated_line": "if -1 % m == x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if -1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == 1 and m == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 1 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == -1 and m == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == -1 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == 1 and m == 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 1 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == 0 and m == 2:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 2:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == 0 and m == 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 0:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == 0 and m == 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 0:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0 and m == 1:",
      "mutated_line": "if x == 0 and m == -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == -1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == 1 and n != 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 1 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == -1 and n != 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == -1 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == 1 and n != 1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 1 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == 0 and n != 2:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 2:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == 0 and n != 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 0:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == 0 and n != 0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 0:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x == 0 and n != 1:",
      "mutated_line": "if x == 0 and n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != -1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) + 1 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) + 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) * 1 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) * 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if power == -1:",
      "mutated_line": "if power == -2:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -2:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if power == -1:",
      "mutated_line": "if power == -0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -0:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if power == -1:",
      "mutated_line": "if power == -0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -0:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if power == -1:",
      "mutated_line": "if power == --1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == --1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -2\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -0\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -0\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return --1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) / (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) / (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = (pow(2, n - 1, modul) + (pow(2, power, modul) - 1 + modul)) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = (pow(2, n - 1, modul) + (pow(2, power, modul) - 1 + modul)) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) ** (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) ** (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if 1 % m != x:",
      "mutated_line": "if 1 * m != x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 * m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if 1 % m != x:",
      "mutated_line": "if 1 + m != x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 + m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "answ = -1",
      "mutated_line": "answ = +1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = +1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 % m == x or n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m == x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 % m != x or n == -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n == -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "answ -= 1",
      "mutated_line": "answ -= 2",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 2\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "answ -= 1",
      "mutated_line": "answ -= 0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 0\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "answ -= 1",
      "mutated_line": "answ -= 0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 0\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "answ -= 1",
      "mutated_line": "answ -= -1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= -1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -2\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -0\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -0\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return --1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 2))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 2))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 0))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 0))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 0))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 0))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + -1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + -1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return i * m - hash[temp] + count",
      "mutated_line": "return i * m + hash[temp] + count",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m + hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return i * m - hash[temp] + count",
      "mutated_line": "return i * m * hash[temp] + count",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m * hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) - 2 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 2 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) - 0 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 0 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) - 0 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 0 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(2, n, m) - -1 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - -1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 - modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 - modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * ((pow(2, power, modul) - 1) * modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * ((pow(2, power, modul) - 1) * modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if 1 % m != x:",
      "mutated_line": "if 2 % m != x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 2 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if 1 % m != x:",
      "mutated_line": "if 0 % m != x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 0 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if 1 % m != x:",
      "mutated_line": "if 0 % m != x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 0 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if 1 % m != x:",
      "mutated_line": "if -1 % m != x:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if -1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "answ = -1",
      "mutated_line": "answ = -2",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -2\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "answ = -1",
      "mutated_line": "answ = -0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -0\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "answ = -1",
      "mutated_line": "answ = -0",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -0\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "answ = -1",
      "mutated_line": "answ = --1",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = --1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 * m != x or n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 * m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 + m != x or n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 + m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 % m != x or n != +1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != +1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t = int(int(int(t * a) // g) % p)",
      "mutated_line": "t = int(int(int(t * a) / g) % p)",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) / g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t = int(int(int(t * a) // g) % p)",
      "mutated_line": "t = int(int(int(t * a) * g) % p)",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) * g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 / p) + 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 / p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 + p) + 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 + p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 ** p) + 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 ** p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return i * m - hash[temp] + count",
      "mutated_line": "return i / m - hash[temp] + count",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i / m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return i * m - hash[temp] + count",
      "mutated_line": "return i + m - hash[temp] + count",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i + m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return i * m - hash[temp] + count",
      "mutated_line": "return i ** m - hash[temp] + count",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i ** m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(3, n, m) - 1 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(3, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(1, n, m) - 1 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(1, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(0, n, m) - 1 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(0, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(1, n, m) - 1 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(1, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "var = (pow(2, n, m) - 1 + m) % m",
      "mutated_line": "var = (pow(-2, n, m) - 1 + m) % m",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(-2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(3, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(3, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(1, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(1, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(0, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(0, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(1, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(1, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(-2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(-2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n + 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n + 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n * 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n * 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) + 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) + 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) * 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) * 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 2 % m != x or n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 2 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 0 % m != x or n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 0 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 0 % m != x or n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 0 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if -1 % m != x or n != -1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if -1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 % m != x or n != -2:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -2:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 % m != x or n != -0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -0:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 % m != x or n != -0:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -0:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if 1 % m != x or n != -1:",
      "mutated_line": "if 1 % m != x or n != --1:",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != --1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(2.0 * p) + 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(2.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(0.0 * p) + 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(0.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(0 * p) + 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))",
      "mutated_line": "(hash, base, m) = ({}, b, int(sqrt(-1.0 * p) + 1))",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(-1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 2, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 2, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 0, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 0, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 0, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 0, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - -1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - -1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 2 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 2 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 0 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 0 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 0 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 0 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - -1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - -1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t = int(int(int(t * a) // g) % p)",
      "mutated_line": "t = int(int(int(t / a) // g) % p)",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t / a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t = int(int(int(t * a) // g) % p)",
      "mutated_line": "t = int(int(int(t + a) // g) % p)",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t + a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t = int(int(int(t * a) // g) % p)",
      "mutated_line": "t = int(int(int(t ** a) // g) % p)",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t ** a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(3, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(3, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(1, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(1, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(0, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(0, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(1, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(1, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "answ = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul",
      "mutated_line": "answ = pow(2, n - 1, modul) * (pow(-2, power, modul) - 1 + modul) % modul % modul",
      "code": "from math import gcd, sqrt\nmodul = 998244353\n\ndef modiFun(a, b, p):\n    a %= p\n    b %= p\n    if b == 1:\n        return 0\n    (count, t, g) = (0, 1, gcd(a, p))\n    while g != 1:\n        if b % g:\n            return -1\n        p = p // g\n        b = b // g\n        t = int(int(int(t * a) // g) % p)\n        count += 1\n        if b == t:\n            return count\n        g = gcd(a, p)\n    (hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\n    for i in range(m):\n        hash[base] = i\n        base = base * a % p\n    (base, temp) = (pow(a, m, p), t)\n    for i in range(1, m + 2):\n        temp = temp * base % p\n        if temp in hash.keys():\n            return i * m - hash[temp] + count\n    return -1\n\ndef find_smallest_beauty(n, x, m):\n    if 1 % m == x:\n        return 0\n    if x == 0 and m == 1:\n        return 0\n    if x == 0 and n != 1:\n        return 1\n    var = (pow(2, n, m) - 1 + m) % m\n    power = modiFun(var, x, m)\n    if power == -1:\n        return -1\n    answ = pow(2, n - 1, modul) * (pow(-2, power, modul) - 1 + modul) % modul % modul\n    if answ == 0:\n        if 1 % m != x:\n            answ = -1\n    if answ == 1:\n        if 1 % m != x or n != -1:\n            answ -= 1\n    return answ"
    }
  ]
}