{
  "task_id": "taco_179",
  "entry_point": "find_point_of_failure",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 49,
      "original_line": "if cycle and not g.find_cycle(cycle):",
      "mutated_line": "if cycle or not g.find_cycle(cycle):",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle or not g.find_cycle(cycle):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] / (self.node_num + 1)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] / (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] + (self.node_num + 1)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] + (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] ** (self.node_num + 1)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] ** (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "visited[v] = True",
      "mutated_line": "visited[v] = False",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = False\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] * (self.node_num - 1)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num - 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] * (self.node_num * 1)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num * 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if not visited[i] and i not in deleted:",
      "mutated_line": "if not visited[i] or i not in deleted:",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] or i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if next_v == parent[v]:",
      "mutated_line": "if next_v != parent[v]:",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v != parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if next_v not in deleted:",
      "mutated_line": "if next_v in deleted:",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [True] * (self.node_num + 1)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [True] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] * (self.node_num + 2)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 2)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] * (self.node_num + 0)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 0)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] * (self.node_num + 0)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 0)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "visited = [False] * (self.node_num + 1)",
      "mutated_line": "visited = [False] * (self.node_num + -1)",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + -1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if not visited[i] and i not in deleted:",
      "mutated_line": "if not visited[i] and i in deleted:",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v != v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while next_v != v:",
      "mutated_line": "while next_v == v:",
      "code": "from collections import defaultdict\n\nclass UndirectedGraph:\n\n    def __init__(self, node_num):\n        self.node_num = node_num\n        self.graph = defaultdict(list)\n\n    def add_edge(self, v, w):\n        self.graph[v].append(w)\n        self.graph[w].append(v)\n\n    def _find(self, v, visited, deleted):\n        stack = [v]\n        parent = defaultdict(int)\n        while stack:\n            v = stack.pop()\n            for next_v in self.graph[v]:\n                if next_v == parent[v]:\n                    continue\n                if visited[next_v]:\n                    path = [v]\n                    while next_v == v:\n                        v = parent[v]\n                        path.append(v)\n                    return path\n                if next_v not in deleted:\n                    parent[next_v] = v\n                    stack.append(next_v)\n            visited[v] = True\n        return None\n\n    def find_cycle(self, del_nodes):\n        visited = [False] * (self.node_num + 1)\n        deleted = set(del_nodes)\n        for i in self.graph:\n            if not visited[i] and i not in deleted:\n                cycle = self._find(i, visited, deleted)\n                if cycle:\n                    return cycle\n        return []\n\ndef find_point_of_failure(n, edges):\n    g = UndirectedGraph(n)\n    for (u, v) in edges:\n        g.add_edge(u, v)\n    cycle = g.find_cycle([])\n    if cycle and (not g.find_cycle(cycle)):\n        cycle.sort()\n        for node in cycle:\n            if not g.find_cycle([node]):\n                return node\n    return -1"
    }
  ]
}