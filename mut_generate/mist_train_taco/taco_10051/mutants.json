{
  "task_id": "taco_10051",
  "entry_point": "determine_edge_directions",
  "mutant_count": 91,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DST_VERTEX = 0",
      "mutated_line": "DST_VERTEX = 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 1\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DST_VERTEX = 0",
      "mutated_line": "DST_VERTEX = -1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = -1\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DST_VERTEX = 0",
      "mutated_line": "DST_VERTEX = 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 1\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "EDGE_CAP = 1",
      "mutated_line": "EDGE_CAP = 2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 2\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "EDGE_CAP = 1",
      "mutated_line": "EDGE_CAP = 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 0\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "EDGE_CAP = 1",
      "mutated_line": "EDGE_CAP = 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 0\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "EDGE_CAP = 1",
      "mutated_line": "EDGE_CAP = -1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = -1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "EDGE_ID = 2",
      "mutated_line": "EDGE_ID = 3",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 3\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "EDGE_ID = 2",
      "mutated_line": "EDGE_ID = 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 1\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "EDGE_ID = 2",
      "mutated_line": "EDGE_ID = 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 0\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "EDGE_ID = 2",
      "mutated_line": "EDGE_ID = 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 1\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "EDGE_ID = 2",
      "mutated_line": "EDGE_ID = -2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = -2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "EDGE_DIR = 3",
      "mutated_line": "EDGE_DIR = 4",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 4\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "EDGE_DIR = 3",
      "mutated_line": "EDGE_DIR = 2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 2\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "EDGE_DIR = 3",
      "mutated_line": "EDGE_DIR = 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 0\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "EDGE_DIR = 3",
      "mutated_line": "EDGE_DIR = 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 1\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "EDGE_DIR = 3",
      "mutated_line": "EDGE_DIR = -3",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = -3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "src -= 1",
      "mutated_line": "src += 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src += 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "dst -= 1",
      "mutated_line": "dst += 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst += 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "flow[src] += cap",
      "mutated_line": "flow[src] -= cap",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] -= cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "flow[dst] += cap",
      "mutated_line": "flow[dst] -= cap",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] -= cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q_size = 1",
      "mutated_line": "q_size = 2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 2\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q_size = 1",
      "mutated_line": "q_size = 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 0\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q_size = 1",
      "mutated_line": "q_size = 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 0\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q_size = 1",
      "mutated_line": "q_size = -1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = -1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while q_size > 0:",
      "mutated_line": "while q_size >= 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size >= 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while q_size > 0:",
      "mutated_line": "while q_size <= 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size <= 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while q_size > 0:",
      "mutated_line": "while q_size != 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size != 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "q_size -= 1",
      "mutated_line": "q_size += 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size += 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "flow = [0 for _ in range(n)]",
      "mutated_line": "flow = [1 for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [1 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "flow = [0 for _ in range(n)]",
      "mutated_line": "flow = [-1 for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [-1 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "flow = [0 for _ in range(n)]",
      "mutated_line": "flow = [1 for _ in range(n)]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [1 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "src -= 1",
      "mutated_line": "src -= 2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 2\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "src -= 1",
      "mutated_line": "src -= 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 0\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "src -= 1",
      "mutated_line": "src -= 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 0\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "src -= 1",
      "mutated_line": "src -= -1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= -1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dst -= 1",
      "mutated_line": "dst -= 2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 2\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dst -= 1",
      "mutated_line": "dst -= 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 0\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dst -= 1",
      "mutated_line": "dst -= 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 0\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dst -= 1",
      "mutated_line": "dst -= -1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= -1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "flow[i] //= 2",
      "mutated_line": "flow[i] //= 3",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 3\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "flow[i] //= 2",
      "mutated_line": "flow[i] //= 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 1\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "flow[i] //= 2",
      "mutated_line": "flow[i] //= 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 0\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "flow[i] //= 2",
      "mutated_line": "flow[i] //= 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 1\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "flow[i] //= 2",
      "mutated_line": "flow[i] //= -2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= -2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "dirs = [-1 for _ in range(m)]",
      "mutated_line": "dirs = [+1 for _ in range(m)]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [+1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(1)",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(1)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(-1)",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(-1)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(1)",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(1)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q_size > 0:",
      "mutated_line": "while q_size > 1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 1:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q_size > 0:",
      "mutated_line": "while q_size > -1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > -1:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q_size > 0:",
      "mutated_line": "while q_size > 1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 1:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q_size -= 1",
      "mutated_line": "q_size -= 2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 2\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q_size -= 1",
      "mutated_line": "q_size -= 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 0\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q_size -= 1",
      "mutated_line": "q_size -= 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 0\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q_size -= 1",
      "mutated_line": "q_size -= -1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= -1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dirs = [-1 for _ in range(m)]",
      "mutated_line": "dirs = [-2 for _ in range(m)]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-2 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dirs = [-1 for _ in range(m)]",
      "mutated_line": "dirs = [-0 for _ in range(m)]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-0 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dirs = [-1 for _ in range(m)]",
      "mutated_line": "dirs = [-0 for _ in range(m)]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-0 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dirs = [-1 for _ in range(m)]",
      "mutated_line": "dirs = [--1 for _ in range(m)]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [--1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if dirs[cur_id] == -1:",
      "mutated_line": "if dirs[cur_id] != -1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] != -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]",
      "mutated_line": "flow[cur_dst] += graph[cur_node][i][EDGE_CAP]",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] += graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "graph[src].append((dst, cap, j, 0))",
      "mutated_line": "graph[src].append((dst, cap, j, 1))",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 1))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "graph[src].append((dst, cap, j, 0))",
      "mutated_line": "graph[src].append((dst, cap, j, -1))",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, -1))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "graph[src].append((dst, cap, j, 0))",
      "mutated_line": "graph[src].append((dst, cap, j, 1))",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 1))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "graph[dst].append((src, cap, j, 1))",
      "mutated_line": "graph[dst].append((src, cap, j, 2))",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 2))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "graph[dst].append((src, cap, j, 1))",
      "mutated_line": "graph[dst].append((src, cap, j, 0))",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 0))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "graph[dst].append((src, cap, j, 1))",
      "mutated_line": "graph[dst].append((src, cap, j, 0))",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 0))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "graph[dst].append((src, cap, j, 1))",
      "mutated_line": "graph[dst].append((src, cap, j, -1))",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, -1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "if dirs[cur_id] == -1:",
      "mutated_line": "if dirs[cur_id] == +1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == +1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - 1 or flow[cur_dst] == 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 or flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "q_size += 1",
      "mutated_line": "q_size -= 1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size -= 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if dirs[cur_id] == -1:",
      "mutated_line": "if dirs[cur_id] == -2:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -2:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if dirs[cur_id] == -1:",
      "mutated_line": "if dirs[cur_id] == -0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -0:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if dirs[cur_id] == -1:",
      "mutated_line": "if dirs[cur_id] == -0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -0:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if dirs[cur_id] == -1:",
      "mutated_line": "if dirs[cur_id] == --1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == --1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst == n - 1 and flow[cur_dst] == 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst == n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - 1 and flow[cur_dst] != 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] != 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "q_size += 1",
      "mutated_line": "q_size += 2",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 2\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "q_size += 1",
      "mutated_line": "q_size += 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 0\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "q_size += 1",
      "mutated_line": "q_size += 0",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 0\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "q_size += 1",
      "mutated_line": "q_size += -1",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += -1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n + 1 and flow[cur_dst] == 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n + 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n * 1 and flow[cur_dst] == 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n * 1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - 1 and flow[cur_dst] == 1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 1:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - 1 and flow[cur_dst] == -1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == -1:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - 1 and flow[cur_dst] == 1:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 1 and flow[cur_dst] == 1:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - 2 and flow[cur_dst] == 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 2 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - 0 and flow[cur_dst] == 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 0 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - 0 and flow[cur_dst] == 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - 0 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cur_dst != n - 1 and flow[cur_dst] == 0:",
      "mutated_line": "if cur_dst != n - -1 and flow[cur_dst] == 0:",
      "code": "from collections import deque\n\ndef determine_edge_directions(n, m, edges):\n    DST_VERTEX = 0\n    EDGE_CAP = 1\n    EDGE_ID = 2\n    EDGE_DIR = 3\n\n    def bfs(flow, graph, n, m):\n        dirs = [-1 for _ in range(m)]\n        q = deque()\n        q.append(0)\n        q_size = 1\n        while q_size > 0:\n            cur_node = q.popleft()\n            q_size -= 1\n            for i in range(len(graph[cur_node])):\n                cur_id = graph[cur_node][i][EDGE_ID]\n                if dirs[cur_id] == -1:\n                    dirs[cur_id] = graph[cur_node][i][EDGE_DIR]\n                    cur_dst = graph[cur_node][i][DST_VERTEX]\n                    flow[cur_dst] -= graph[cur_node][i][EDGE_CAP]\n                    if cur_dst != n - -1 and flow[cur_dst] == 0:\n                        q.append(cur_dst)\n                        q_size += 1\n        return dirs\n    flow = [0 for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    for (j, (src, dst, cap)) in enumerate(edges):\n        src -= 1\n        dst -= 1\n        graph[src].append((dst, cap, j, 0))\n        graph[dst].append((src, cap, j, 1))\n        flow[src] += cap\n        flow[dst] += cap\n    for i in range(n):\n        flow[i] //= 2\n    dirs = bfs(flow, graph, n, m)\n    return dirs"
    }
  ]
}